<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梁大红的技术Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liangdahong.com/"/>
  <updated>2021-01-24T16:08:09.000Z</updated>
  <id>https://liangdahong.com/</id>
  
  <author>
    <name>梁大红</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS中如何自动监控控制器内存泄漏</title>
    <link href="https://liangdahong.com/2020/06/08/iOS%E4%B8%AD%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8E%A7%E5%88%B6%E5%99%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>https://liangdahong.com/2020/06/08/iOS中如何自动监控控制器内存泄漏/</id>
    <published>2020-06-08T14:41:53.000Z</published>
    <updated>2021-01-24T16:08:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h2><p>所谓<strong>内存泄露</strong>，通俗讲就是 <strong>该释放</strong> 的时候一直 <strong>得不到释放</strong>。</p><a id="more"></a><p>控制器通常从 <strong>创建</strong> 到 <strong>显示</strong> 到 <strong>释放</strong>  要经过一系列的 <strong>生命周期</strong> 方法，大概如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithNibName:(nullable NSString *)nibNameOrNil bundle:(nullable NSBundle *)nibBundleOrNil;</span><br><span class="line">- (nullable instancetype)initWithCoder:(NSCoder *)coder;</span><br><span class="line">- (void)loadView;</span><br><span class="line">- (void)loadViewIfNeeded</span><br><span class="line">- (void)viewWillUnload</span><br><span class="line">- (void)viewDidUnload</span><br><span class="line">- (void)viewDidLoad;</span><br><span class="line">- (void)viewWillAppear:(BOOL)animated;</span><br><span class="line">- (void)viewDidAppear:(BOOL)animated;</span><br><span class="line">- (void)viewWillDisappear:(BOOL)animated;</span><br><span class="line">- (void)viewDidDisappear:(BOOL)animated;</span><br><span class="line">- (void)viewWillLayoutSubviews</span><br><span class="line">- (void)viewDidLayoutSubviews</span><br><span class="line">- (void)dealloc&#123;&#125;</span><br></pre></td></tr></table></figure><p>一般情况，如果控制器没有内存泄漏，一般会经过 <code>viewDidLoad</code>  和 <code>dealloc</code> 方法。</p><p>我们可以从上面的 <code>2</code> 个方法入手，如果一个控制器经过了 <code>viewDidLoad</code>,  同时在 <strong>应该释放</strong> 的时候一直没有  <strong>dealloc</strong>，那么基本可以确定控制器泄漏了【当然有特殊情况，如：在一些特殊场景下开发者特意不让其释放】，问题来了，什么时候是控制器应该释放的时候呢 ？</p><p>触发了如下方法的时候可以基本确定相关控制器需要释放【欢迎补充】：</p><ul><li><code>UIViewController</code> 触发了 <code>dismissViewControllerAnimated:completion:</code> </li></ul><ul><li><p><code>UINavigationController</code> 触发了 <code>popViewControllerAnimated:</code></p></li><li><p><code>UINavigationController</code> 触发了 <code>popToViewController:animated:</code></p></li><li><p><code>UINavigationController</code> 触发了 <code>popToRootViewControllerAnimated:</code></p></li><li><p><code>UINavigationController</code> 触发了 <code>popViewControllerAnimated:</code></p></li><li><p><code>UINavigationController</code> 触发了 <code>setViewControllers:</code></p></li><li><p><code>UINavigationController</code> 触发了 <code>setViewControllers:animated:</code></p></li></ul><ul><li><p><code>UITabBarController</code> 触发了 <code>setViewControllers:</code></p></li><li><p><code>UITabBarController</code> 触发了 <code>setViewControllers:animated:</code> </p></li></ul><ul><li><code>UIPageViewController</code> 触发了 <code>setViewControllers:direction:animated:completion:</code></li><li><code>UISplitViewController</code> 触发了 <code>setViewControllers:</code> </li><li><code>UIWindow</code> 触发了 <code>rootViewController</code></li><li>…等。</li></ul><p>我们可以从上面的分析出发，在 <code>viewDidLoad</code> 的时候记录控制器，然后在控制器  <code>dealloc</code> 的时候清除记录，在需要释放的时候把相关控制器标记为将要释放，然后把相关的统计数据呈现出来即可。</p><h2 id="AMLeaksFinder-的处理逻辑"><a href="#AMLeaksFinder-的处理逻辑" class="headerlink" title="AMLeaksFinder 的处理逻辑"></a>AMLeaksFinder 的处理逻辑</h2><ul><li><code>hook</code> 控制器的 <code>viewDidLoad</code> 方法，同时做相关的逻辑操作，注意不要强引用。</li></ul><p><img src="https://user-images.githubusercontent.com/12118567/82640835-dcd36100-9c3d-11ea-8252-a1602aa46baf.png" alt="image"><br><img src="https://user-images.githubusercontent.com/12118567/82641054-4bb0ba00-9c3e-11ea-97fc-f1236fed1ae3.png" alt="image"><br><img src="https://user-images.githubusercontent.com/12118567/82641065-4fdcd780-9c3e-11ea-805b-77e1eff73cb6.png" alt="image"></p><ul><li><code>hook</code> <code>UINavigationController</code> 的 <code>setViewControllers:</code> 和相关 <code>pop</code> 方法，把相关的控制器设置为将要释放【 <code>控制器A需要释放，那么控制器 A 包括它的子子孙孙控制器全部需要释放</code> 】。</li></ul><p><img src="https://user-images.githubusercontent.com/12118567/82641110-6420d480-9c3e-11ea-8c23-300050715101.png" alt="image"><br><img src="https://user-images.githubusercontent.com/12118567/82641197-8b77a180-9c3e-11ea-8436-0cea58c96ba8.png" alt="image"><br><img src="https://user-images.githubusercontent.com/12118567/82641330-c4b01180-9c3e-11ea-8799-a7214738a910.png" alt="image"></p><ul><li>在自定义专门监控控制器释放的 <code>class</code> 的 <code>dealloc</code> 里处理相关逻辑，代码如下：</li></ul><p><img src="https://user-images.githubusercontent.com/12118567/82641484-fb862780-9c3e-11ea-98cd-07ed1c58046f.png" alt="image"></p><ul><li><code>UI</code> 实时统计出当前统计的控制器数据即可。</li><li>其中用到了 <code>2</code> 个自定义类，其中 <code>AMMemoryLeakDeallocModel</code> 主要是为了监控控制器的释放，<code>AMMemoryLeakModel</code> 是为了统计数据。</li></ul><h2 id="AMLeaksFinder-原理图"><a href="#AMLeaksFinder-原理图" class="headerlink" title="AMLeaksFinder 原理图"></a>AMLeaksFinder 原理图</h2><p><img src="https://user-images.githubusercontent.com/12118567/105628096-dbfe6900-5e75-11eb-901c-58639c8a1a37.png" alt=""></p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><ul><li><a href="https://github.com/liangdahong/AMLeaksFinder/blob/master/README.md#效果演示" target="_blank" rel="noopener">效果图</a></li></ul><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><ul><li>更多详细内容请查询源码 <a href="https://github.com/liangdahong/AMLeaksFinder" target="_blank" rel="noopener">https://github.com/liangdahong/AMLeaksFinder</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/Tencent/MLeaksFinder" target="_blank" rel="noopener">https://github.com/Tencent/MLeaksFinder</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原理介绍&quot;&gt;&lt;a href=&quot;#原理介绍&quot; class=&quot;headerlink&quot; title=&quot;原理介绍&quot;&gt;&lt;/a&gt;原理介绍&lt;/h2&gt;&lt;p&gt;所谓&lt;strong&gt;内存泄露&lt;/strong&gt;，通俗讲就是 &lt;strong&gt;该释放&lt;/strong&gt; 的时候一直 &lt;strong&gt;得不到释放&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="00-技术-iOS" scheme="https://liangdahong.com/categories/00-%E6%8A%80%E6%9C%AF-iOS/"/>
    
    
      <category term="iOS" scheme="https://liangdahong.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>正确高效使用 Google</title>
    <link href="https://liangdahong.com/2018/07/11/%E6%AD%A3%E7%A1%AE%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8-Google/"/>
    <id>https://liangdahong.com/2018/07/11/正确高效使用-Google/</id>
    <published>2018-07-11T03:30:49.000Z</published>
    <updated>2021-01-24T16:08:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><a id="more"></a><ul><li>文章来自 <strong>七年就是一辈子-李笑来</strong></li></ul><blockquote><p>研究这个词，在英文中是research，我把它理解为 re-search，实际上各种语言是相通的，所谓re-search其实就是“反复搜索”，就是“上下求索”（路漫漫其修远兮，吾将上下而求索）。所以，如果你想学点什么，就要善于搜索。而在这个时代里，最好的搜索工具就是 Google。</p></blockquote><blockquote><p>搜索引擎之所以迷人，就是因为它就好像望远镜一样：</p></blockquote><blockquote><p>能让你看到你原本完全看不到的东西……</p></blockquote><blockquote><p>互联网就好像那浩瀚的宇宙，里面几乎什么都有，只要你肯用“望远镜”去看、用搜索引擎去搜……</p></blockquote><blockquote><p>搜索引擎是公开的，人人都可以用的，可偏偏大多数人不用、不会用，甚至错误地用…… 于是人与人之间的差异多了另外一个不断延展的维度。在这个维度上你不如人家你能怪谁？</p></blockquote><blockquote><p>最烂的提问是：“我连不上 Google 怎么办呀？” 答案是“自己想办法” —— 如果你在乎，你就肯花时间自己解决这个问题，如果你不在乎，就不用在乎了。</p></blockquote><h2 id="使用“本尊”"><a href="#使用“本尊”" class="headerlink" title="使用“本尊”"></a>使用“本尊”</h2><p>最好使用 <a href="http://www.google.com/ncr" target="_blank" rel="noopener">http://www.google.com/ncr</a> NCR: No Country Redirection，而不是<a href="http://www.google.com.hk；有时，直接输入http://www.google.com也会被自动转到“本地Google”，比如，我用日本的" target="_blank" rel="noopener">http://www.google.com.hk；有时，直接输入http://www.google.com也会被自动转到“本地Google”，比如，我用日本的</a> VPN，浏览器就会把我转到<a href="http://www.google.co.jp……" target="_blank" rel="noopener">http://www.google.co.jp……</a></p><h2 id="优先使用英文关键字搜索"><a href="#优先使用英文关键字搜索" class="headerlink" title="优先使用英文关键字搜索"></a>优先使用英文关键字搜索</h2><p>这是个好习惯。别说不会英文，不会就学，没那么难。</p><h2 id="基本技巧"><a href="#基本技巧" class="headerlink" title="基本技巧"></a>基本技巧</h2><p>Google 搜索引擎也许是世界上最简单的应用界面，只有一个输入框和一个按钮。然而，用好它还是需要花点时间去学习的。Google 有帮助文档，还专门设计了个学习网站 A Google A Day</p><h3 id="加号"><a href="#加号" class="headerlink" title="加号"></a>加号</h3><p>在 Google 的输入框里，所有的空格都被 Google 理解为加号+。如果你输入的是 purpose of education那么 Google 返回的文章里既有“purpose”存在，也有“education”存在，但不一定有“purpose of education”存在。另外，过分常用的、单独存在没有意义的词汇往往被忽略掉，比如冠词“a”、“the”；介词“of”、“in”、“on”、“at”、“to”；连词“and”、“or”、“but”；从属连词“that”、“which”、“when”；代词“my”、“his”、“them”等等。</p><h3 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h3><p>如果你想要找含有“purpose of education”这个词组的文章，那么你必须输入”purpose of education”。现在的 Google 已经可以处理 utf-8 大字符集了，所以，即便你在输入的时候使用的是全角字符（不是半角字符的”而是“或者”）Google也照样能够正确处理。比较一下两种输入返回的结果：purpose of education vs.“purpose of education”。再试试 the most important benefit of education 和 “the most important benefit of education”。这就是引号（“……”）的作用——返回“完整匹配”的结果。</p><h3 id="减号"><a href="#减号" class="headerlink" title="减号"></a>减号</h3><p>为了进一步筛选搜索结果，还需要学会另外一个符号——减号-。比如，“the most important benefit of education” – “united states”要求Google返回含有“the most important benefit of education”但不存在“united states”的文章。</p><h3 id="星号"><a href="#星号" class="headerlink" title="星号"></a>星号</h3><p>另外一个威力无穷的符号是星号<em>。Google 支持通配符搜索，即搜索字符串中可以包含星号</em>，用来替代任意字符串。比如，“the most * examples of censorship”将会返回含有类似“the most outrageous examples of censorship”、“the most brazen examples of censorship”、“the most heinous examples of censorship”、“the most stupidest examples of censorship”、“the most dangerous examples of censorship”、“the most egregious examples of censorship”、“the most prolific examples of censorship”、“the most absurd examples of censorship”……</p><h3 id="波浪号"><a href="#波浪号" class="headerlink" title="波浪号"></a>波浪号</h3><p>还有一个运用相当灵活、经常带来意外收获的符号是波浪号~。把波浪号~加在某个单词前面，是在告诉 Google：除了给出的关键字之外，还要搜索与波浪号~后面的那个单词相关的词汇。比如，搜索the importance of ~censorship的结果中包含着“the importance of censorship”，也包含着与censorship相关的另外一个词汇“propaganda”——“the importance of propaganda”。</p><h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><h3 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h3><p>再学一个在指定网站中搜索的语法“site:”。比如，“the purpose of education” site:<a href="http://www.time.com/就是要求" target="_blank" rel="noopener">http://www.time.com/就是要求</a> Google 只返回 <a href="http://www.time.com" target="_blank" rel="noopener">http://www.time.com</a> 这个网站里的含有“the purpose of education”的文章。</p><h3 id="定制搜索"><a href="#定制搜索" class="headerlink" title="定制搜索"></a>定制搜索</h3><p>2006年，Google 推出了“co-op”服务（自定义搜索引擎）。其中最常用的功能之一就是可以指定 Google 搜索一个或者若干个指定的网站——相当于前面提到的 Google 语法“site:”的扩展。比如，我就曾经为我的学生定制了一个 Google cse（Custom Search Engine）——Search News Media。不妨看看在这个自定义搜索引擎上搜索censorship返回的结果（GRE/SAT 的作文考试中，都有很多关于“censorship”的作文题）。这个 cse 只搜索以下10个网站：</p><ul><li><a href="http://www.economist.com/" target="_blank" rel="noopener">http://www.economist.com/</a></li><li><a href="http://www.cnn.com/" target="_blank" rel="noopener">http://www.cnn.com/</a></li><li><a href="http://www.time.com/" target="_blank" rel="noopener">http://www.time.com/</a></li><li><a href="http://nytimes.com/" target="_blank" rel="noopener">http://nytimes.com/</a></li><li><a href="http://www.washingtonpost.com/" target="_blank" rel="noopener">http://www.washingtonpost.com/</a></li><li><a href="http://www.usnews.com/" target="_blank" rel="noopener">http://www.usnews.com/</a></li><li><a href="http://usatoday.com/" target="_blank" rel="noopener">http://usatoday.com/</a></li><li><a href="http://www.reuters.com/" target="_blank" rel="noopener">http://www.reuters.com/</a></li><li><a href="http://www.bbc.co.uk/" target="_blank" rel="noopener">http://www.bbc.co.uk/</a></li><li><a href="http://en.wikinews.org/" target="_blank" rel="noopener">http://en.wikinews.org/</a></li></ul><h2 id="特别声明"><a href="#特别声明" class="headerlink" title="特别声明"></a>特别声明</h2><ul><li>文章来自 <strong>七年就是一辈子-李笑来</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;
    
    </summary>
    
      <category term="03-技术-计算机" scheme="https://liangdahong.com/categories/03-%E6%8A%80%E6%9C%AF-%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="计算机" scheme="https://liangdahong.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 iOS 事件的传递和响应过程</title>
    <link href="https://liangdahong.com/2018/06/08/%E6%B5%85%E8%B0%88-iOS-%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E9%80%92%E5%92%8C%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B/"/>
    <id>https://liangdahong.com/2018/06/08/浅谈-iOS-事件的传递和响应过程/</id>
    <published>2018-06-08T03:16:11.000Z</published>
    <updated>2021-01-24T16:08:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote></blockquote><ul><li><code>iOS</code> 中 <code>View</code> 的事件到底是怎么<code>传递</code>和<code>响应</code>的？</li><li>为什么 <code>父View</code> 关闭了事件响应时，<code>子View</code> 就无法响应事件？ 底层原理？</li><li>如何扩大 <code>Button</code> 的点击范围 ？</li><li>如何让 <code>父View</code> 和 <code>子View</code> 同时响应同一事件？默认情况下只会响应 <code>子View</code> 的事件回调。</li><li>为什么 <code>子View</code> 关闭了事件，但其 <code>父View</code> 开启事件的情况下，点击 <code>子View</code> 时，<code>父View</code> 可以正常响应事件？</li><li>为什么 子View 是 UIView时，如果没有添加手势，点击子 View时，会由其父View来响应，而 子View 是 UIControl 时，子View 没有添加手势，一样不会由 父View 来响应</li><li>…</li></ul><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote><p><code>iOS</code> 的事件可以分为三种</p></blockquote><ul><li><code>Touch Events(触摸事件)</code></li><li><code>Motion Events(运动事件，比如重力感应和摇一摇等)</code></li><li><code>Remote Events(远程事件，比如用耳机上得按键来控制手机)</code></li></ul><blockquote><p>下面主要讲解 <code>Touch Events(触摸事件)</code> <code>Touch Events</code>事件的整个过程可以分为 <code>传递</code>和<code>响应</code> 2 个阶段，</p><ul><li>传递： 是当我们触摸屏幕时，为我们找出最适合的 <code>View</code>，</li><li>响应： 当我们找出最适合的 <code>View</code> 后，此时只是找到了最合适的 <code>View</code>，但未必 此 <code>View</code> 可以响应此事件，所以需要继续找出能响应此事件的 <code>View</code>。</li></ul></blockquote><h3 id="传递过程"><a href="#传递过程" class="headerlink" title="传递过程"></a>传递过程</h3><blockquote><p>每当手指接触屏幕，操作系统会把事件传递给当前的 <code>App</code>， 在 <code>UIApplication</code>接收到手指的事件之后，就会去调用`UIWindow的hitTest:withEvent:，看看当前点击的点是不是在window内，如果是则继续依次调用其 subView的hitTest:withEvent:方法，直到找到最后需要的view。调用结束并且hit-test view确定之后，便可以确定最合适的 View。</p></blockquote><ul><li>引用几张图来说明</li></ul><p><img src="https://zhoon.github.io/img/artical/ios_event/iosevent_3.png" alt=""></p><p><img src="https://zhoon.github.io/img/artical/ios_event/iosevent_4.png" alt=""></p><p><img src="https://zhoon.github.io/img/artical/ios_event/iosevent_5.png" alt=""></p><ul><li>图片表示的内容可用下面的话描述<a href="https://zhoon.github.io/ios/2015/04/12/ios-event.html" target="_blank" rel="noopener">来自这里</a></li></ul><blockquote><p>递归是向界面的根节点UIWindow发送hitTest:withEvent:消息开始的，从这个消息返回的是一个UIView，也就是手指当前位置最前面的那个 hittest view。 当向UIWindow发送hitTest:withEvent:消息时，hitTest:withEvent:里面所做的事，就是判断当前的点击位置是否在window里面，如果在则遍历window的subview然后依次对subview发送hitTest:withEvent:消息(注意这里给subview发送消息是根据当前subview的index顺序，index越大就越先被访问)。如果当前的point没有在view上面，那么这个view的subview也就不会被遍历了。当事件遍历到了view B.1，发现point在view B.1里面，并且view B.1没有subview，那么他就是我们要找的hittest view了，找到之后就会一路返回直到根节点，而view B之后的view A也不会被遍历了。</p></blockquote><ul><li>下面是 <code>- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</code> 方法的内部实现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    if (self.hidden || !self.userInteractionEnabled || self.alpha &lt; 0.01 || ![self pointInside:point withEvent:event] || ![self _isAnimatedUserInteractionEnabled]) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (UIView *subview in [self.subviews reverseObjectEnumerator]) &#123;</span><br><span class="line">            UIView *hitView = [subview hitTest:[subview convertPoint:point fromView:self] withEvent:event];</span><br><span class="line">            if (hitView) &#123;</span><br><span class="line">                return hitView;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return self;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/BigZaphod/Chameleon/blob/master/UIKit/Classes/UIView.m" target="_blank" rel="noopener">上面的代码来自这里</a></p></blockquote><h3 id="响应过程"><a href="#响应过程" class="headerlink" title="响应过程"></a>响应过程</h3><ul><li>个人对响应过程的理解如下： </li></ul><blockquote><p>当我们知道最合适的 View 后，事件会 由上向下【子view -&gt; 父view，控制器view -&gt; 控制器】来找出合适响应事件的 View，来响应相关的事件。如果当前的 View 有添加手势，那么直接响应相应的事件，不会继续向下寻找了，如果没有手势事件，那么会看其是否实现了如下的方法：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;</span><br></pre></td></tr></table></figure><hr><p>如果有实现那么就由此 View 响应，如果没有实现，那么就会传递给他的下一个响应者【子view -&gt; 父view，控制器view -&gt; 控制器】， 这里我们可以做一个简单的验证，在默认情况下 UIView 是不响应事件的，UIControl 就算没有添加手势一样的会由他来响应， 这里可以使用 runtime查看 UIView 和 UIControl 的方法列表， 或 查看 <a href="https://github.com/BigZaphod/Chameleon/blob/master/UIKit/Classes/UIView.m" target="_blank" rel="noopener">UIKit 源码</a> 可知， UIView 没有实现如上的 <code>touchesBegan</code>方法，而 <code>UIControl</code> 是实现了如上的相关方法，所以验证了刚才的 UIView 不响应，和 UIControl 的响应。一旦找到最合适响应的View就结束, 在执行响应的绑定的事件，如果没有就抛弃此事件。</p><p>我的验证</p><ul><li>首先处理添加了手势时，其便可以处理事件。</li><li>我们创建一个view A 在 A 中添加一个 view B, 如果我们给 A 加了手势，B没有加手势，</li><li>我们在点击 B 时，会响应 A 的事件，非常正常的情况，那么它是怎么判断 B 是否可以处理的呢？</li><li>我们现在给 B 加一个手势，那么同样的操作时会触发 B 的手势，现在我们 给 B 增加一个方法，</li></ul><pre><code class="c">@implementation BMSonView- (NSArray&lt;UIGestureRecognizer *&gt; *)gestureRecognizers {    NSLog(@<span class="string">"%@"</span>, self);    <span class="keyword">return</span> @[];}</code></pre><blockquote><p>手势返回 @[]，此时点击 B 只会触发 A 的事件，由此可以说明在判断 view 是否可以处理事件实现是判断  gestureRecognizers  即是否添加了手势，上面提到了还有判断如下的方法是否实现了,默认情况下 UIView 是没有实现如下的方法的，使用在没有添加手势时他不响应事件。</p></blockquote><pre><code class="c">- (<span class="keyword">void</span>)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;- (<span class="keyword">void</span>)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;- (<span class="keyword">void</span>)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;- (<span class="keyword">void</span>)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;</code></pre><p>如果我们手动实现了如上的方法时，就算没有给  B 添加手势，点击 B 时， 事件不会响应 A 的方法，会到上面的方法中。从 UIControl 的源码便可清除看到。</p><p>所以个人理解：</p><ul><li>事件在传递时和上面的 hit 方法有关，一层层向上传递，【窗口—&gt; view】由其相应的 view 中具体的实现来确定谁才是是最合适响应的view</li><li>在响应时，又上向下找出第一个能处理的view来处理事件，[view —&gt; 窗口]，在寻找刚过程中 会判断是否增加了手势 和是否实现了如上的 触摸方法。</li><li>至于 UIControl Button 的特殊事件相应，个人认为是在其m文件中实现了上面的4个方法，在这4个方法中做了相关的处理，这里可以从 UIControl 代码中在知道一些内容。</li><li>所以如果想自己实现 UIControl Button ，首先要想办法处理好上面的4个方法。</li></ul><ul><li>图如下<br><img src="https://zhoon.github.io/img/artical/ios_event/iosevent_2.png" alt=""></li></ul><h2 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h2><ul><li><p>iOS 中 View 的事件到底是怎么传递和响应的？</p><blockquote><p>如上所描。</p></blockquote></li><li><p>为什么 父View 关闭了事件响应时，子View 就无法响应事件？</p><blockquote><p>因为在事件传递的时，先到父view，当父view无法响应事，直接就跳过了遍历其子view，故只要父类关闭了事件，子 view 就已经没有机会响应事件了。</p></blockquote></li></ul><ul><li><p>如何扩大 Button 的点击范围？</p><blockquote><p>扩大点击范围，无非就是想本来没有点击 btn 但想让 btn 响应事件，那么可以在 hitTest 方法中做适当的操作，当满足xxx条件时，强行返回 btn 来达到最佳点击范围的效果，相关的实现可以自行 Google ，有一些较优雅而简洁的方式。</p></blockquote></li><li><p>如何让 父View 和 子View 同时响应同一事件？</p><blockquote><p>父View 和 子View同时响应同一事件，默认当点击子view时，如果ziview可以处理事件，那么其他父view 是不会响应的，但是在 父view 传到 子view 时我们在 hitTest 方法中是清楚知道的，使用可以在这里做相关的操作便实现了子view 和父view 同时响应事件的效果。</p></blockquote></li><li><p>为什么子View 关闭了事件，但其 父View 开启事件的情况下，点击 子View 时，父View 可以响应事件？</p><blockquote><p>子view关闭了事件，事件的传递是 父view 到子view，在 父view时，父view可以响应，那么会继续访问其 子view是否可以响应，如果此时子view不可以响应，那么他会直接返回 父view，所以 子View 关闭了事件 父View  正常执行事件是必然的。</p></blockquote></li></ul><ul><li><p>为什么 子View 是 UIView时，如果没有添加手势，点击子 View时，会由其父View来响应，而 子View 是 UIControl 时，子View 没有添加手势，一样不会由 父View 来响应</p><blockquote><p>这个问题可以见上面的寻找可以响应的 view 来解决，UIControl 实现了如上的 4 大方法，而 UIView 没有实现。</p></blockquote></li><li><p>这里其实还有许多内容待挖掘，比如：scrollview 的事件响应等。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://smnh.me/hit-testing-in-ios/" target="_blank" rel="noopener">http://smnh.me/hit-testing-in-ios/</a></li><li><a href="https://zhoon.github.io/ios/2015/04/12/ios-event.html" target="_blank" rel="noopener">https://zhoon.github.io/ios/2015/04/12/ios-event.html</a></li><li><a href="http://southpeak.github.io/blog/2015/03/07/uiresponder/" target="_blank" rel="noopener">http://southpeak.github.io/blog/2015/03/07/uiresponder/</a></li><li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIScrollView_Class/index.html#//apple_ref/doc/uid/TP40006922" target="_blank" rel="noopener">https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIScrollView_Class/index.html#//apple_ref/doc/uid/TP40006922</a></li><li><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html" target="_blank" rel="noopener">https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html</a></li><li><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW2" target="_blank" rel="noopener">https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW2</a></li><li><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW2" target="_blank" rel="noopener">https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW2</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;iOS&lt;/code&gt; 中 &lt;code&gt;View&lt;/code&gt; 的事件到底是怎么&lt;code&gt;传递&lt;/code&gt;和&lt;code&gt;响应&lt;/code&gt;的？&lt;/li&gt;
&lt;li&gt;为什么 &lt;code&gt;父View&lt;/code&gt; 关闭了事件响应时，&lt;code&gt;子View&lt;/code&gt; 就无法响应事件？ 底层原理？&lt;/li&gt;
&lt;li&gt;如何扩大 &lt;code&gt;Button&lt;/code&gt; 的点击范围 ？&lt;/li&gt;
&lt;li&gt;如何让 &lt;code&gt;父View&lt;/code&gt; 和 &lt;code&gt;子View&lt;/code&gt; 同时响应同一事件？默认情况下只会响应 &lt;code&gt;子View&lt;/code&gt; 的事件回调。&lt;/li&gt;
&lt;li&gt;为什么 &lt;code&gt;子View&lt;/code&gt; 关闭了事件，但其 &lt;code&gt;父View&lt;/code&gt; 开启事件的情况下，点击 &lt;code&gt;子View&lt;/code&gt; 时，&lt;code&gt;父View&lt;/code&gt; 可以正常响应事件？&lt;/li&gt;
&lt;li&gt;为什么 子View 是 UIView时，如果没有添加手势，点击子 View时，会由其父View来响应，而 子View 是 UIControl 时，子View 没有添加手势，一样不会由 父View 来响应&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="00-技术-iOS" scheme="https://liangdahong.com/categories/00-%E6%8A%80%E6%9C%AF-iOS/"/>
    
    
      <category term="iOS" scheme="https://liangdahong.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>简单说说 MJExtension 实现原理</title>
    <link href="https://liangdahong.com/2016/10/28/%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4-MJExtension-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://liangdahong.com/2016/10/28/简单说说-MJExtension-实现原理/</id>
    <published>2016-10-27T16:01:47.000Z</published>
    <updated>2022-01-04T16:16:01.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原始方法"><a href="#原始方法" class="headerlink" title="原始方法"></a>原始方法</h2><ul><li>首先我们的模型是这样的，只有2个属性</li></ul><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface BMUser : NSObject</span><br><span class="line">@property (nonatomic, copy) NSString *name; <span class="comment">///&lt; name</span></span><br><span class="line">@property (nonatomic, assign) <span class="keyword">int</span> age;      <span class="comment">///&lt; age</span></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>使用最原始的方法把<code>json-&gt;Models</code>时,代码如下</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.获取json数据</span></span><br><span class="line">NSString *json = @<span class="string">"&#123;\"name\" : \"idhong\", \"age\" : 15&#125;"</span>;</span><br><span class="line"><span class="comment">// 2.json-&gt;NSDictionary</span></span><br><span class="line">NSDictionary *jsonDict = [NSJSONSerialization JSONObjectWithData:[json dataUsingEncoding:NSUTF8StringEncoding] options:kNilOptions error:<span class="literal">NULL</span>];</span><br><span class="line"><span class="comment">// 3.创建user</span></span><br><span class="line">BMUser *user = [BMUser <span class="keyword">new</span>];</span><br><span class="line"><span class="comment">// 4.赋值</span></span><br><span class="line">user.name = jsonDict[@<span class="string">"name"</span>];</span><br><span class="line">user.age = [jsonDict[@<span class="string">"age"</span>] intValue];</span><br><span class="line"><span class="comment">// 其他属性设置</span></span><br><span class="line">NSLog(@<span class="string">""</span>);</span><br></pre></td></tr></table></figure><ul><li>稍微优化下，使用<code>setValuesForKeysWithDictionary</code>可以简化赋值代码如下。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.获取json数据</span></span><br><span class="line">NSString *json = @<span class="string">"&#123;\"name\" : \"idhong\", \"age\" : 15&#125;"</span>;</span><br><span class="line"><span class="comment">// 2.json-&gt;NSDictionary</span></span><br><span class="line">NSDictionary *jsonDict = [NSJSONSerialization JSONObjectWithData:[json dataUsingEncoding:NSUTF8StringEncoding] options:kNilOptions error:<span class="literal">NULL</span>];</span><br><span class="line"><span class="comment">// 3.创建user</span></span><br><span class="line">BMUser *user = [BMUser <span class="keyword">new</span>];</span><br><span class="line"><span class="comment">// 4.赋值</span></span><br><span class="line">[user setValuesForKeysWithDictionary:jsonDict];</span><br></pre></td></tr></table></figure><h3 id="如果属性特别多，而且模型嵌套模型时手写就特别麻烦而且容易出错，其中至少包括如下问题；"><a href="#如果属性特别多，而且模型嵌套模型时手写就特别麻烦而且容易出错，其中至少包括如下问题；" class="headerlink" title="如果属性特别多，而且模型嵌套模型时手写就特别麻烦而且容易出错，其中至少包括如下问题；"></a>如果属性特别多，而且模型嵌套模型时手写就特别麻烦而且容易出错，其中至少包括如下问题；</h3><ul><li>1.模型的属性是另一个模型</li><li>2.模型的属性是数组（数组中的对象又是模型）</li><li>3.以及相互嵌套等。</li><li>使用<code>setValuesForKeysWithDictionary</code>无法解决问题，同时手动编码无法想象。</li></ul><h3 id="归根结底-json-gt-Model-主要是以下3步"><a href="#归根结底-json-gt-Model-主要是以下3步" class="headerlink" title="归根结底 json -&gt; Model 主要是以下3步"></a>归根结底 json -&gt; Model 主要是以下3步</h3><ul><li>1.创建模型</li><li>2.为模型中的属性赋值</li><li><p>3.返回模型</p></li><li><p>其中最核心的就是第2步，怎么样动态的为模型赋值，当然是使用<code>Runtime</code>,<code>MJExtension</code> 算是使用率较多的一个库，下面就简单分析下其实现原理吧。</p></li><li>1.使用<code>Runtime</code>动态获取模型的属性（包括继承链的所有属性，<code>MJExtension</code>对模型的属性做了缓存，下次转换时自己使用，空间换时间）</li><li>2.又第1步获取到的属性可以解析出各属性的全部信息（包括属性类型，属性修饰符等参考<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html" target="_blank" rel="noopener">这里</a> )</li><li>3.第2步获取属性后，取到属性名在去<code>NSDictionary</code>)中获出相应的值 </li><li>4.在第3步取出的值使用KVC设置给Model即可(<code>MJExtension</code>使用<code>KVC</code>赋值，<code>YYModel</code>底层是直接使用<code>objc_msgSend</code>)</li><li>5.所以为什么如果模型中有属性是数组，数组中又是模型时，需要我们指定其类型，才可为我们主动将其转换。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/651640-449ad8ff10affa5f.png?imageMogr2/auto-orient/" alt=""></p><h3 id="怎样自己实现MJExtension"><a href="#怎样自己实现MJExtension" class="headerlink" title="怎样自己实现MJExtension"></a>怎样自己实现<code>MJExtension</code></h3><ul><li>动态获取模型属性</li><li>解析属性相关信息</li><li>如果是数组类型，因为不知道数组中应该存放具体的类型，所以需提供方法让使用者提供具体的类型</li><li>使用KVC赋值</li><li>其他扩展信息，包括黑名单，白名单，换属性名，转换结束等等扩展信息。</li></ul><h2 id="分析MJExtension"><a href="#分析MJExtension" class="headerlink" title="分析MJExtension"></a>分析<code>MJExtension</code></h2><ul><li>引用一张图</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/664334-14b80127b4e16a56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p><p><code>MJExtension 一共21个文件，主要用3个类，5个分类</code></p><ul><li><code>MJExtension.h</code>头文件</li><li><code>MJExtensionConst</code> 一些常量，宏，版本控制等</li><li><code>MJFoundation</code>主要是提供判断是否为<code>Foundation</code>框架的类</li><li><code>MJProperty</code>封装属性对象（<code>objc_property_t</code>内部包括属性名称，属性类型等相关信息）</li><li><code>MJPropertyKey</code> 属性的key</li><li><code>MJPropertyType</code> 属性类型（类型标识符<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html" target="_blank" rel="noopener">这里</a>，是否<code>id</code>，是否基本数据类型等）</li><li><code>NSString+MJExtension</code>字符串的一些扩展（包括下划线，大小写等处理）</li><li><code>NSObject+MJProperty</code>主要提供遍历一个类的属性列表</li><li><code>NSObject+MJCoding</code>提供归档功能</li><li><code>NSObject+MJClass</code>提供扩展功能，黑名单，白名单，数组中的类型自定义等。</li></ul><hr><h2 id="MJExtension源码解读"><a href="#MJExtension源码解读" class="headerlink" title="MJExtension源码解读"></a>MJExtension源码解读</h2><ul><li>我们使用最基本的<code>dict-&gt;Model</code>方法是:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)mj_objectWithKeyValues:(id)keyValues;</span><br></pre></td></tr></table></figure><p>其实现在<code>NSObject+MJKeyValue.m</code>的203行如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)mj_objectWithKeyValues:(id)keyValues</span><br><span class="line">&#123;</span><br><span class="line">    return [self mj_objectWithKeyValues:keyValues context:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用了下面的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)mj_objectWithKeyValues:(id)keyValues context:(NSManagedObjectContext *)context</span><br><span class="line">&#123;</span><br><span class="line">    // 获得JSON对象</span><br><span class="line">    keyValues = [keyValues mj_JSONObject];</span><br><span class="line">    MJExtensionAssertError([keyValues isKindOfClass:[NSDictionary class]], nil, [self class], @&quot;keyValues参数不是一个字典&quot;);</span><br><span class="line">    </span><br><span class="line">    if ([self isSubclassOfClass:[NSManagedObject class]] &amp;&amp; context) &#123;</span><br><span class="line">        NSString *entityName = [NSStringFromClass(self) componentsSeparatedByString:@&quot;.&quot;].lastObject;</span><br><span class="line">        return [[NSEntityDescription insertNewObjectForEntityForName:entityName inManagedObjectContext:context] mj_setKeyValues:keyValues context:context];</span><br><span class="line">    &#125;</span><br><span class="line">    return [[[self alloc] init] mj_setKeyValues:keyValues];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是<code>mj_JSONObject</code>方法，其作用是把NSData或者NSString为NSDictionary类型，因为上面的方法支持NSDictionary，NSString，NSData类型，其具体实现就不在赘述了。</p><p>这里先不考虑CoreData及NSManagedObject</p><p>然后是创建模型同时调用赋值属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[[self alloc] init] mj_setKeyValues:keyValues]</span><br></pre></td></tr></table></figure><p>最后调到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)mj_setKeyValues:(id)keyValues context:(NSManagedObjectContext *)context</span><br></pre></td></tr></table></figure><p>此方法是整个库的核心代码部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)mj_setKeyValues:(id)keyValues context:(NSManagedObjectContext *)context</span><br><span class="line">&#123;</span><br><span class="line">    // 获得JSON对象</span><br><span class="line">    keyValues = [keyValues mj_JSONObject];</span><br><span class="line">    </span><br><span class="line">    MJExtensionAssertError([keyValues isKindOfClass:[NSDictionary class]], self, [self class], @&quot;keyValues参数不是一个字典&quot;);</span><br><span class="line">    </span><br><span class="line">    Class clazz = [self class];</span><br><span class="line">    NSArray *allowedPropertyNames = [clazz mj_totalAllowedPropertyNames];</span><br><span class="line">    NSArray *ignoredPropertyNames = [clazz mj_totalIgnoredPropertyNames];</span><br><span class="line">    </span><br><span class="line">    //通过封装的方法回调一个通过运行时编写的，用于返回属性列表的方法。</span><br><span class="line">    [clazz mj_enumerateProperties:^(MJProperty *property, BOOL *stop) &#123;</span><br><span class="line">        @try</span><br><span class="line">        &#123;</span><br><span class="line">            // 0.检测是否被忽略</span><br><span class="line">            if (allowedPropertyNames.count &amp;&amp; ![allowedPropertyNames containsObject:property.name]) return;</span><br><span class="line">            if ([ignoredPropertyNames containsObject:property.name]) return;</span><br><span class="line">            </span><br><span class="line">            // 1.取出属性值</span><br><span class="line">            id value;</span><br><span class="line">            NSArray *propertyKeyses = [property propertyKeysForClass:clazz];</span><br><span class="line">            for (NSArray *propertyKeys in propertyKeyses) &#123;</span><br><span class="line">                value = keyValues;</span><br><span class="line">                for (MJPropertyKey *propertyKey in propertyKeys) &#123;</span><br><span class="line">                    value = [propertyKey valueInObject:value];</span><br><span class="line">                &#125;</span><br><span class="line">                if (value) break;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 值的过滤</span><br><span class="line">            id newValue = [clazz mj_getNewValueFromObject:self oldValue:value property:property];</span><br><span class="line">            if (newValue != value) &#123; // 有过滤后的新值</span><br><span class="line">                [property setValue:newValue forObject:self];</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 如果没有值，就直接返回</span><br><span class="line">            if (!value || value == [NSNull null]) return;</span><br><span class="line">            </span><br><span class="line">            // 2.复杂处理</span><br><span class="line">            MJPropertyType *type = property.type;</span><br><span class="line">            Class propertyClass = type.typeClass;</span><br><span class="line">            Class objectClass = [property objectClassInArrayForClass:[self class]];</span><br><span class="line">            </span><br><span class="line">            // 不可变 -&gt; 可变处理</span><br><span class="line">            if (propertyClass == [NSMutableArray class] &amp;&amp; [value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">                value = [NSMutableArray arrayWithArray:value];</span><br><span class="line">            &#125; else if (propertyClass == [NSMutableDictionary class] &amp;&amp; [value isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">                value = [NSMutableDictionary dictionaryWithDictionary:value];</span><br><span class="line">            &#125; else if (propertyClass == [NSMutableString class] &amp;&amp; [value isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">                value = [NSMutableString stringWithString:value];</span><br><span class="line">            &#125; else if (propertyClass == [NSMutableData class] &amp;&amp; [value isKindOfClass:[NSData class]]) &#123;</span><br><span class="line">                value = [NSMutableData dataWithData:value];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (!type.isFromFoundation &amp;&amp; propertyClass) &#123; // 模型属性</span><br><span class="line">                value = [propertyClass mj_objectWithKeyValues:value context:context];</span><br><span class="line">            &#125; else if (objectClass) &#123;</span><br><span class="line">                if (objectClass == [NSURL class] &amp;&amp; [value isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">                    // string array -&gt; url array</span><br><span class="line">                    NSMutableArray *urlArray = [NSMutableArray array];</span><br><span class="line">                    for (NSString *string in value) &#123;</span><br><span class="line">                        if (![string isKindOfClass:[NSString class]]) continue;</span><br><span class="line">                        [urlArray addObject:string.mj_url];</span><br><span class="line">                    &#125;</span><br><span class="line">                    value = urlArray;</span><br><span class="line">                &#125; else &#123; // 字典数组--&gt;模型数组</span><br><span class="line">                    value = [objectClass mj_objectArrayWithKeyValuesArray:value context:context];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (propertyClass == [NSString class]) &#123;</span><br><span class="line">                    if ([value isKindOfClass:[NSNumber class]]) &#123;</span><br><span class="line">                        // NSNumber -&gt; NSString</span><br><span class="line">                        value = [value description];</span><br><span class="line">                    &#125; else if ([value isKindOfClass:[NSURL class]]) &#123;</span><br><span class="line">                        // NSURL -&gt; NSString</span><br><span class="line">                        value = [value absoluteString];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if ([value isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">                    if (propertyClass == [NSURL class]) &#123;</span><br><span class="line">                        // NSString -&gt; NSURL</span><br><span class="line">                        // 字符串转码</span><br><span class="line">                        value = [value mj_url];</span><br><span class="line">                    &#125; else if (type.isNumberType) &#123;</span><br><span class="line">                        NSString *oldValue = value;</span><br><span class="line">                        </span><br><span class="line">                        // NSString -&gt; NSNumber</span><br><span class="line">                        if (type.typeClass == [NSDecimalNumber class]) &#123;</span><br><span class="line">                            value = [NSDecimalNumber decimalNumberWithString:oldValue];</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            value = [numberFormatter_ numberFromString:oldValue];</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        // 如果是BOOL</span><br><span class="line">                        if (type.isBoolType) &#123;</span><br><span class="line">                            // 字符串转BOOL（字符串没有charValue方法）</span><br><span class="line">                            // 系统会调用字符串的charValue转为BOOL类型</span><br><span class="line">                            NSString *lower = [oldValue lowercaseString];</span><br><span class="line">                            if ([lower isEqualToString:@&quot;yes&quot;] || [lower isEqualToString:@&quot;true&quot;]) &#123;</span><br><span class="line">                                value = @YES;</span><br><span class="line">                            &#125; else if ([lower isEqualToString:@&quot;no&quot;] || [lower isEqualToString:@&quot;false&quot;]) &#123;</span><br><span class="line">                                value = @NO;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                // value和property类型不匹配</span><br><span class="line">                if (propertyClass &amp;&amp; ![value isKindOfClass:propertyClass]) &#123;</span><br><span class="line">                    value = nil;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 3.赋值</span><br><span class="line">            [property setValue:value forObject:self];</span><br><span class="line">        &#125; @catch (NSException *exception) &#123;</span><br><span class="line">            MJExtensionBuildError([self class], exception.reason);</span><br><span class="line">            MJExtensionLog(@&quot;%@&quot;, exception);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    // 转换完毕</span><br><span class="line">    if ([self respondsToSelector:@selector(mj_keyValuesDidFinishConvertingToObject)]) &#123;</span><br><span class="line">        [self mj_keyValuesDidFinishConvertingToObject];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取模型可以转换和忽略的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *allowedPropertyNames = [clazz mj_totalAllowedPropertyNames];</span><br><span class="line">NSArray *ignoredPropertyNames = [clazz mj_totalIgnoredPropertyNames];</span><br></pre></td></tr></table></figure><p>此方法在调用时，这里做了缓存处理，只会访问一次，同时会调到外层的使用者实现的方法中</p><p>然后调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (void)mj_enumerateProperties:(MJPropertiesEnumeration)enumeration</span><br></pre></td></tr></table></figure><p>遍历所有的属性，此方法同样做了缓存处理，如果某<code>Class</code>遍历过，此库内部会把其数组缓存起来，下次直接遍历即可</p><p>在<code>Block</code>回调中可以获取到每一个<code>MJProperty</code>（封装的属性）</p><p>几步比较常规的操作，在库用用详细的注释</p><ul><li>检测是否被忽略</li><li>取出属性值</li><li>值的过滤（提供了尾部可以对特殊值做处理的功能）</li></ul><p>复杂类型处理</p><p>实现是对<code>NSArray-&gt;NSMutableArray，NSData-&gt;NSMutableData，NSDictionary-&gt;NSMutableDictionary</code>做可变处理。</p><p>因为对复杂类型需继续继续转换。</p><p>如果是模型<code>（ !type.isFromFoundation &amp;&amp; propertyClass ）</code>就重复最开始的方法</p><p>如果是<code>NSURL</code> 就把<code>NSString</code>转换为<code>NSURL</code></p><p>如果是 字典数组-由继续最开始的方法调用</p><p><code>NSNumber</code>类型</p><p><code>BOOL</code>等类型的转换</p><p>最后使用<code>KVC</code>赋值，当然在内部做了是否支持<code>KVC</code>的判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 3.赋值</span><br><span class="line">[property setValue:value forObject:self];</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>综上所述，<code>MJExtension</code>的底层实现还算常规，<code>动态获取属性</code> <code>属性的类型判断</code> <code>必要的缓存</code> <code>KVC赋值</code>  <code>其他性细节优化和扩展</code>。</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote><p>有时间分析下<code>YYModel</code>，其使用到了<code>CoreFoundation</code>和<code>objc_msgSend</code>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原始方法&quot;&gt;&lt;a href=&quot;#原始方法&quot; class=&quot;headerlink&quot; title=&quot;原始方法&quot;&gt;&lt;/a&gt;原始方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;首先我们的模型是这样的，只有2个属性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS单元测试入门</title>
    <link href="https://liangdahong.com/2016/05/27/iOS%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8/"/>
    <id>https://liangdahong.com/2016/05/27/iOS单元测试入门/</id>
    <published>2016-05-27T15:23:43.000Z</published>
    <updated>2021-01-24T16:08:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><blockquote><p>本文主要是讲 XCTest 的使用</p></blockquote><a id="more"></a><blockquote><p>我们知道在程序的开发中，单元测试是相当的重要，废话不多说，直接动手吧。</p></blockquote><ol><li>我们在创建 Xcode 项目的时候全部勾选的话默认会创建 <code>XCTestDemoTests</code> <code>XCTestDemoUITests</code> 这 2 个模块。现在主要讲解 <code>XCTestDemoTests</code>的使用。其中的模板代码如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 每次测试前调用，可以在测试之前创建在test case方法中需要用到的一些对象等</span><br><span class="line">// Put setup code here. This method is called before the invocation of each test method in the class.</span><br><span class="line">- (void)setUp &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 每次测试结束时调用tearDown方法</span><br><span class="line">// Put teardown code here. This method is called after the invocation of each test method in the class.</span><br><span class="line">- (void)tearDown &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 单元测试方法的例子</span><br><span class="line">// 我们可以自定义添加  - (void)testxxxx&#123;&#125; 方法，- (void)testxxx 类似的方法在启动测试的时候都会自动跑。</span><br><span class="line">// This is an example of a functional test case.</span><br><span class="line">// Use XCTAssert and related functions to verify your tests produce the correct results.</span><br><span class="line">- (void)testExample &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 性能测试方法，通过测试block中方法执行的时间，比对设定的标准值和偏差觉得是否可以通过测试</span><br><span class="line">- (void)testPerformanceExample &#123;</span><br><span class="line">    // This is an example of a performance test case.</span><br><span class="line">    [self measureBlock:^&#123;</span><br><span class="line">        // Put the code you want to measure the time of here.</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>XCTAssert 的使用，在单元测试中，我们通常使用 XCTAssert 相关的方法，方法有如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 通用断言，为 true 就通过测试</span><br><span class="line">XCTAssert(false);</span><br><span class="line"></span><br><span class="line">// 为 true 就通过测试</span><br><span class="line">XCTAssertTrue(false);</span><br><span class="line"></span><br><span class="line">// 为 false 就通过测试</span><br><span class="line">XCTAssertFalse(true);</span><br><span class="line"></span><br><span class="line">// 相等就通过测试</span><br><span class="line">XCTAssertEqual(1, 2);</span><br><span class="line">// 不相等就通过测试</span><br><span class="line">XCTAssertNotEqual(0, 0);</span><br><span class="line"></span><br><span class="line">// 相差的值在精确度范围内就通过测试</span><br><span class="line">XCTAssertEqualWithAccuracy(10, 12, 1);</span><br><span class="line">// 相差的值不在精确度范围内就通过测试</span><br><span class="line">XCTAssertNotEqualWithAccuracy(10, 12, 1);</span><br><span class="line"></span><br><span class="line">// 为 nil 就通过测试</span><br><span class="line">XCTAssertNil(nil);</span><br><span class="line">// 不为 nil 就通过测试</span><br><span class="line">XCTAssertNotNil(nil);</span><br><span class="line"></span><br><span class="line">// 直接不通过测试,可以自己判断是否加 XCTFail();</span><br><span class="line">XCTFail();</span><br></pre></td></tr></table></figure><ol><li>我们可以使用 <code>❀ + U 来启动全部单元测试</code>  <code>❀ + 6 切换到测试模块 这个和 Xcode 的版本有关</code> 或者使用下图的方法来启动测试:</li></ol><p><img src="https://user-images.githubusercontent.com/12118567/83040794-40142780-a072-11ea-817e-50817b2b5a1e.png" alt="16f2e3826d2f848e"><br><img src="https://user-images.githubusercontent.com/12118567/83040803-41ddeb00-a072-11ea-8be0-23645da2c0c8.png" alt="16f2e37b010ab95f"></p><ol><li>如何写测试用例呢？</li></ol><blockquote><p>比如我们在开发框架的时候，一般会写一些测试用例。下面我们就模拟写一个简单的框架，同时我们写一些测试用例。如：我们要写一个获取 URL 中的参数的方法。</p></blockquote><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@interface NSString (BMURLParams)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy, readonly) NSDictionary *bm_URLParams; ///&lt; URLParams</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NSString+BMURLParams.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation NSString (BMURLParams)</span><br><span class="line"></span><br><span class="line">- (NSDictionary *)bm_URLParams &#123;</span><br><span class="line">    NSRange range = [self rangeOfString:@&quot;?&quot;];</span><br><span class="line">    if (range.location == NSNotFound) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSString *propertys = [self substringFromIndex:(range.location+1)];</span><br><span class="line">    NSMutableDictionary *tempDic = @&#123;&#125;.mutableCopy;</span><br><span class="line">    [[propertys componentsSeparatedByString:@&quot;&amp;&quot;] enumerateObjectsUsingBlock:^(NSString * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        NSArray *dicArray = [obj componentsSeparatedByString:@&quot;=&quot;];</span><br><span class="line">        if (dicArray.count &gt; 1) &#123;</span><br><span class="line">            tempDic[dicArray[0]] = dicArray[1];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    return tempDic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ol><li>我们在 XCTestDemoTests 文件中，实现导入 <code>#import &quot;NSString+BMURLParams.h&quot;</code> 同时加上如下的方法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)test_URLParams &#123;</span><br><span class="line">    XCTAssert(@&quot;https://www.baidu.com/s&quot;.bm_URLParams == nil);</span><br><span class="line"></span><br><span class="line">     XCTAssert([(@&quot;https://www.baidu.com/s?name=jck&quot;.bm_URLParams)</span><br><span class="line">                isEqualToDictionary:(@&#123;@&quot;name&quot; : @&quot;jck&quot;&#125;)]);</span><br><span class="line"></span><br><span class="line">    XCTAssert([(@&quot;https://www.baidu.com/s?name=jack&amp;type=1&quot;.bm_URLParams)</span><br><span class="line">                isEqualToDictionary:(@&#123;@&quot;name&quot; : @&quot;jack&quot;,</span><br><span class="line">                                       @&quot;type&quot; : @&quot;1&quot;&#125;)]);</span><br><span class="line"></span><br><span class="line">    XCTAssert([(@&quot;https://www.baidu.com/s?name=jack&amp;type=1&amp;user=80222&quot;.bm_URLParams)</span><br><span class="line">                isEqualToDictionary:(@&#123;@&quot;name&quot; : @&quot;jack&quot;,</span><br><span class="line">                                       @&quot;type&quot; : @&quot;1&quot;,</span><br><span class="line">                                       @&quot;user&quot; : @&quot;80222&quot;&#125;)]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>跑一下测试用例，发现如下的效果</li></ul><p><img src="https://user-images.githubusercontent.com/12118567/83041020-94b7a280-a072-11ea-91b3-d44efd02cec4.png" alt="16f2e3f3e4bde6d3"></p><p>说明我们的用例全部通过了，当然这里的用例比较少，我们可以加上各种可能的情况。现在我们把获取参数的代码故意写错为如下的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;NSString+BMURLParams.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation NSString (BMURLParams)</span><br><span class="line"></span><br><span class="line">- (NSDictionary *)bm_URLParams &#123;</span><br><span class="line">    NSRange range = [self rangeOfString:@&quot;?&quot;];</span><br><span class="line">    if (range.location == NSNotFound) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSString *propertys = [self substringFromIndex:(range.location+1)];</span><br><span class="line">    NSMutableDictionary *tempDic = @&#123;&#125;.mutableCopy;</span><br><span class="line">    [[propertys componentsSeparatedByString:@&quot;&amp;&quot;] enumerateObjectsUsingBlock:^(NSString * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        NSArray *dicArray = [obj componentsSeparatedByString:@&quot;=&quot;];</span><br><span class="line">        if (dicArray.count &gt; 1) &#123;</span><br><span class="line">            tempDic[dicArray[1]] = dicArray[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    return tempDic;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>在跑一下单元测试就会有如下的效果：</p><p><img src="https://user-images.githubusercontent.com/12118567/83041072-a600af00-a072-11ea-9616-700e0cfcb745.png" alt="16f2e4371a72125b"></p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><blockquote><p>现在我们模拟测试网络接口的返回速度是否复合我们的预期，实现我们创建应该发送网络请求的类 <code>BMRequestManager</code>, 代码如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface BMRequestManager : NSObject</span><br><span class="line">+ (void)getDataWithSuccBlock:(dispatch_block_t)block;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@implementation BMRequestManager</span><br><span class="line">+ (void)getDataWithSuccBlock:(dispatch_block_t)block &#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(6.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        !block ? : block();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><ul><li>我们编写测试用例代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)testExampleRequest &#123;</span><br><span class="line">    </span><br><span class="line">    // 1、创建 XCTestExpectation</span><br><span class="line">    XCTestExpectation *exp = [self expectationWithDescription:@&quot;这个请求太慢了&quot;];</span><br><span class="line"></span><br><span class="line">    // 2、具体的网络请求</span><br><span class="line">    [BMRequestManager getDataWithSuccBlock:^&#123;</span><br><span class="line">        // 收到数据了</span><br><span class="line">        // 发送 fulfill 消息</span><br><span class="line">        [exp fulfill];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 3、定义预期需要在 xxx 时间内获取到数据</span><br><span class="line">    NSTimeInterval time = 15;</span><br><span class="line"></span><br><span class="line">    //4、如果超过 xxx 时间就报错</span><br><span class="line">    [self waitForExpectationsWithTimeout:time handler:^(NSError * _Nullable error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            NSLog(@&quot;Timeout Error: %@&quot;, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于我们上面设置的预期时间是 15 秒，但我们实际我们 6 秒就获取到了数据，使用我们在跑用例的时候用如下效果：</p></blockquote><p><img src="https://user-images.githubusercontent.com/12118567/83041190-ca5c8b80-a072-11ea-88bf-971bd802c49f.png" alt="16f31f2475a39adb"></p><blockquote><p>如果我们设置的预期时间是 5 秒，代码如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)testExampleRequest &#123;</span><br><span class="line">    </span><br><span class="line">    // 1、创建 XCTestExpectation</span><br><span class="line">    XCTestExpectation *exp = [self expectationWithDescription:@&quot;这个请求太慢了&quot;];</span><br><span class="line"></span><br><span class="line">    // 2、具体的网络请求</span><br><span class="line">    [BMRequestManager getDataWithSuccBlock:^&#123;</span><br><span class="line">        // 收到数据了</span><br><span class="line">        // 发送 fulfill 消息</span><br><span class="line">        [exp fulfill];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 3、定义预期需要在 xxx 时间内获取到数据</span><br><span class="line">    NSTimeInterval time = 5.0;</span><br><span class="line"></span><br><span class="line">    //4、如果超过 xxx 时间就报错</span><br><span class="line">    [self waitForExpectationsWithTimeout:time handler:^(NSError * _Nullable error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            NSLog(@&quot;Timeout Error: %@&quot;, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>跑用例的时候有如下效果：</li></ul><p><img src="https://user-images.githubusercontent.com/12118567/83041226-d6484d80-a072-11ea-9510-cfa4a2ea4d78.png" alt="16f31f35a791a329"></p><blockquote><p>说明用例不通过。</p></blockquote><ul><li>当然我们也可以测试其他的一些代码的执行时间和预期时间来比较，看代码是否通过预期时间。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://liuyanwei.jumppo.com/2016/03/10/iOS-unit-test.html" target="_blank" rel="noopener">http://liuyanwei.jumppo.com/2016/03/10/iOS-unit-test.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;简单介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本文主要是讲 XCTest 的使用&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="00-技术-iOS" scheme="https://liangdahong.com/categories/00-%E6%8A%80%E6%9C%AF-iOS/"/>
    
    
      <category term="iOS" scheme="https://liangdahong.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>使用 Hexo 搭建个人博客</title>
    <link href="https://liangdahong.com/2016/04/08/%E4%BD%BF%E7%94%A8-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://liangdahong.com/2016/04/08/使用-Hexo-搭建个人博客/</id>
    <published>2016-04-07T22:47:38.000Z</published>
    <updated>2021-01-24T16:08:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><a id="more"></a><blockquote><p><a href="https://hexo.io/" target="_blank" rel="noopener">hexo.io</a></p></blockquote><ul><li>什么是 <code>Hexo</code> ？</li></ul><blockquote><p><code>Hexo</code> 是一个快速、简洁且高效的博客框架, <code>Hexo</code> 使用 <code>Markdown</code>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页 <a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">来自这里</a>。</p></blockquote><hr><blockquote><p><code>Hexo</code> 由一个台湾同胞开发的 <code>Blog</code> 框架 <a href="https://github.com/tommy351" target="_blank" rel="noopener">https://github.com/tommy351</a>, 和 <code>Github</code> 或 <code>Coding</code> 配合可以非常简单而免费的搭建一个漂亮的个人 <code>Blog</code>，而且可以自定义域名，下面就简单介绍其使用吧。</p></blockquote><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><blockquote><p>域名购买可到 <a href="https://www.aliyun.com/" target="_blank" rel="noopener">阿里云</a> 或者 <a href="https://sg.godaddy.com/" target="_blank" rel="noopener">godaddy</a> 购买即可，大概 <code>60RMB/年</code>，而且可以自定义域名邮箱，看起来高端大气上档次😄。<br>如：<code>ios@liangdahong.com</code><br>其实没什么 <code>X</code> 用 具体就不介绍了。</p></blockquote><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><blockquote><p><code>Hexo</code> 支持 <code>Windows</code> 和 <code>masOS</code>，需安装好</p></blockquote><ul><li><p>Node.js</p></li><li><p>Git</p></li></ul><blockquote><p>具体的安装可自行 <code>Google</code> </p></blockquote><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><ul><li>在安装好环境后，使用如下的命令安装 <code>Hexo</code> </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><ul><li>在安装好 <code>Hexo</code> 后，我们初始化自己的 <code>Blog</code> ，首先创建 <code>Blog</code> 需要保存的文件夹，在进入文件夹下。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cd blog/</span><br></pre></td></tr></table></figure><ul><li>初始化 <code>Blog</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><ul><li>初始化完成后我们可以看到有如下的文件夹结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">_config.yml</span><br><span class="line"></span><br><span class="line">node_modules</span><br><span class="line"></span><br><span class="line">package-lock.json</span><br><span class="line"></span><br><span class="line">package.json</span><br><span class="line"></span><br><span class="line">scaffolds</span><br><span class="line"></span><br><span class="line">source</span><br><span class="line"></span><br><span class="line">themes</span><br></pre></td></tr></table></figure><ul><li><p><code>_config.yml</code> 文件是 <code>Blog</code> 的一些基本配置, 具体可以参考官网的说明。</p></li><li><p>预览, 可使用如下命令预览 <code>Blog</code>，然后在浏览器输入 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 即可看到 <code>Blog</code> 的效果了</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><ul><li>创建一篇文章</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;你的文章名称&quot;</span><br></pre></td></tr></table></figure><ul><li>现在我们在本地已经可以看到 <code>Blog</code> 了，那么我们怎么部署到服务器上呢？ 让别人也可以看到我们的 <code>Blog</code></li></ul><ul><li><p>我们需要去 <code>Github</code> 创建一个项目，命名为：<code>name.github.io</code>  如：<code>iangdahong.github.io</code></p></li><li><p>然后去开启 <code>GitHub Pages</code></p></li><li><p>然后在刚才我们初始化的 <code>Blog</code> 的 <code>_config.yml</code> 中做具体的修改。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line">title: Hexo</span><br><span class="line">subtitle:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">author: John Doe</span><br><span class="line">language:</span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: http://yoursite.com</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"># Directory</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"></span><br><span class="line"># Writing</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace:</span><br><span class="line">  </span><br><span class="line"># Home page setting</span><br><span class="line"># path: Root path for your blogs index page. (default = &apos;&apos;)</span><br><span class="line"># per_page: Posts displayed per page. (0 = disable pagination)</span><br><span class="line"># order_by: Posts order. (Order by date descending by default)</span><br><span class="line">index_generator:</span><br><span class="line">  path: &apos;&apos;</span><br><span class="line">  per_page: 10</span><br><span class="line">  order_by: -date</span><br><span class="line">  </span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"># Date / Time format</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"></span><br><span class="line"># Pagination</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: landscape</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type:</span><br></pre></td></tr></table></figure><ul><li>如上，现在我们需要把 <code>Blog</code> 部署到 <code>Github</code> 上，</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 生成静态 html 文件</span><br><span class="line">hexo g</span><br><span class="line">// 部署到 github</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><ul><li><p>现在你可以使用 <a href="xxxxx.github.io">xxxxx.github.io</a> 访问你的 <code>Blog</code> 了。</p></li><li><p>现在我们使用的是 <code>Hexo</code> 提供的默认主题，其实 <code>github</code> 上已经有大量的开源的漂亮的主题如：<code>next</code></p></li><li><p>我们使用自定义的主题，</p></li><li><p>我们把我们知道的主题 <code>clone</code> 到 <code>themes</code> 下，</p></li><li><p>然后在 <code>_config.yml</code> 中修改主题为你使用的主题，</p></li><li><p>在使用如上的方法部署到 <code>github</code> 即可使用自定义的主题了。</p></li></ul><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><blockquote><p>一些简单的配置开源参考 <code>hexo</code> 和 相应的主题做自定义修改</p></blockquote><h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2><blockquote><p><code>github</code> 支持自定义域名，在刚才我们创建的项目中可以设置自定义的域名，但需要先做好域名解析，具体的操作可以 <code>Google</code> 下</p></blockquote><h2 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h2><blockquote><p>在之前  <code>github</code> 是不支持 <code>https</code> 的，但在不久前已经支持了 <code>https</code>。</p></blockquote><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><blockquote><p>其他扩展的较多：评价系统，统计系统，分享，打赏等，可以自行探索。下面的 Blog 提供了许多的扩展设置，可以参考下。</p></blockquote><ul><li><a href="https://segmentfault.com/a/1190000009544924" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009544924</a></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote><p>我们可以会思考一个问题 ？现在我们可以写 <code>Blog</code> 了，那么如果我们换电脑了怎么破？其实 我们在使用 <code>hexo g</code> 命令时，是把我们写好的 <code>Markdown</code> <code>编译</code> 为 <code>html css</code> 文件。在 <code>public</code> 中，我们使用 <code>hexo d</code> 的时候 其实是吧 <code>public</code> 文件的内容全部同步到 <code>github</code> 上去了，你可以去验证下，所以如果你自己写的 <code>html</code> 可以直接放到 <code>public</code> 中 然后部署上去也一样可以使用。</p></blockquote><hr><blockquote><p>所以我们刚才创建的的项目存储的是生成的 <code>html</code> 文件，那么我们的源文件呢？ 如果换电脑了就没办法获取了，所以我们可以使用 <code>github</code> 在同步我们的源文件，我们在 <code>github</code> 上在创建一个项目来专门存放 我们的 <code>blog</code> 源文件，同时把 <code>public</code> 忽略调，那么我们在换电脑后只需要配置好环境便随时随地可以愉快的写 <code>blog</code> 了。</p></blockquote><hr><blockquote><p> <code>Blog</code> 加速，国内时访问 <code>Coding</code>,  国外访问 <code>Github</code> ，需把 <code>Blog</code> 同时部署在 <code>2</code> 个平台，同时域名解析为：国外访问 <code>Github</code>，国内访问 <code>Coding</code> 。</p></blockquote><h2 id="以下博客给于了帮助"><a href="#以下博客给于了帮助" class="headerlink" title="以下博客给于了帮助"></a>以下博客给于了帮助</h2><ul><li><a href="http://jinxiansen.com/" target="_blank" rel="noopener">1、晋先森从购买域名到域名邮箱，搭建博客等</a></li><li><a href="http://devlu.me/2016/01/23/Hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE%E4%B9%8B-%E4%B8%BA%E8%87%AA%E5%B7%B1%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/" target="_blank" rel="noopener">2、Hexo博客优化配置之–为自己博客添加站内搜索</a></li><li><a href="http://devlu.me/2016/01/16/Hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE%E4%B9%8B-%E4%B8%BA%E8%87%AA%E5%B7%B1%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%BD%91%E9%A1%B5%E6%94%B6%E5%BD%95/" target="_blank" rel="noopener">3、Hexo博客优化配置之–为自己博客添加搜索引擎网页收录</a></li><li><a href="http://xingbofeng.com/2016/09/05/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">4、hexo+github搭建个人博客</a> </li><li><a href="http://www.voidking.com/tags/hexo/" target="_blank" rel="noopener">5、http://www.voidking.com/tags/hexo/</a></li><li><a href="https://segmentfault.com/a/1190000009544924" target="_blank" rel="noopener">6、 https://segmentfault.com/a/1190000009544924/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;说在前面&quot;&gt;&lt;a href=&quot;#说在前面&quot; class=&quot;headerlink&quot; title=&quot;说在前面&quot;&gt;&lt;/a&gt;说在前面&lt;/h2&gt;
    
    </summary>
    
      <category term="04-技术-Hexo" scheme="https://liangdahong.com/categories/04-%E6%8A%80%E6%9C%AF-Hexo/"/>
    
    
      <category term="Hexo" scheme="https://liangdahong.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
