<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS中如何自动监控控制器内存泄漏]]></title>
    <url>%2F2020%2F06%2F08%2FiOS%E4%B8%AD%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E7%9B%91%E6%8E%A7%E6%8E%A7%E5%88%B6%E5%99%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[原理介绍所谓内存泄露，通俗讲就是 该释放 的时候一直 得不到释放。 控制器通常从 创建 到 显示 到 释放 要经过一系列的 生命周期 方法，大概如下： 1234567891011121314- (instancetype)initWithNibName:(nullable NSString *)nibNameOrNil bundle:(nullable NSBundle *)nibBundleOrNil;- (nullable instancetype)initWithCoder:(NSCoder *)coder;- (void)loadView;- (void)loadViewIfNeeded- (void)viewWillUnload- (void)viewDidUnload- (void)viewDidLoad;- (void)viewWillAppear:(BOOL)animated;- (void)viewDidAppear:(BOOL)animated;- (void)viewWillDisappear:(BOOL)animated;- (void)viewDidDisappear:(BOOL)animated;- (void)viewWillLayoutSubviews- (void)viewDidLayoutSubviews- (void)dealloc&#123;&#125; 一般情况，如果控制器没有内存泄漏，一般会经过 viewDidLoad 和 dealloc 方法。 我们可以从上面的 2 个方法入手，如果一个控制器经过了 viewDidLoad, 同时在 应该释放 的时候一直没有 dealloc，那么基本可以确定控制器泄漏了【当然有特殊情况，如：在一些特殊场景下开发者特意不让其释放】，问题来了，什么时候是控制器应该释放的时候呢 ？ 触发了如下方法的时候可以基本确定相关控制器需要释放【欢迎补充】： UIViewController 触发了 dismissViewControllerAnimated:completion: UINavigationController 触发了 popViewControllerAnimated: UINavigationController 触发了 popToViewController:animated: UINavigationController 触发了 popToRootViewControllerAnimated: UINavigationController 触发了 popViewControllerAnimated: UINavigationController 触发了 setViewControllers: UINavigationController 触发了 setViewControllers:animated: UITabBarController 触发了 setViewControllers: UITabBarController 触发了 setViewControllers:animated: UIPageViewController 触发了 setViewControllers:direction:animated:completion: UISplitViewController 触发了 setViewControllers: UIWindow 触发了 rootViewController …等。 我们可以从上面的分析出发，在 viewDidLoad 的时候记录控制器，然后在控制器 dealloc 的时候清除记录，在需要释放的时候把相关控制器标记为将要释放，然后把相关的统计数据呈现出来即可。 AMLeaksFinder 的处理逻辑 hook 控制器的 viewDidLoad 方法，同时做相关的逻辑操作，注意不要强引用。 hook UINavigationController 的 setViewControllers: 和相关 pop 方法，把相关的控制器设置为将要释放【 控制器A需要释放，那么控制器 A 包括它的子子孙孙控制器全部需要释放 】。 在自定义专门监控控制器释放的 class 的 dealloc 里处理相关逻辑，代码如下： UI 实时统计出当前统计的控制器数据即可。 其中用到了 2 个自定义类，其中 AMMemoryLeakDeallocModel 主要是为了监控控制器的释放，AMMemoryLeakModel 是为了统计数据。 AMLeaksFinder 原理图 效果 效果图 更多 更多详细内容请查询源码 https://github.com/liangdahong/AMLeaksFinder 参考 https://github.com/Tencent/MLeaksFinder]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正确高效使用 Google]]></title>
    <url>%2F2018%2F07%2F11%2F%E6%AD%A3%E7%A1%AE%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8-Google%2F</url>
    <content type="text"><![CDATA[写在前面 文章来自 七年就是一辈子-李笑来 研究这个词，在英文中是research，我把它理解为 re-search，实际上各种语言是相通的，所谓re-search其实就是“反复搜索”，就是“上下求索”（路漫漫其修远兮，吾将上下而求索）。所以，如果你想学点什么，就要善于搜索。而在这个时代里，最好的搜索工具就是 Google。 搜索引擎之所以迷人，就是因为它就好像望远镜一样： 能让你看到你原本完全看不到的东西…… 互联网就好像那浩瀚的宇宙，里面几乎什么都有，只要你肯用“望远镜”去看、用搜索引擎去搜…… 搜索引擎是公开的，人人都可以用的，可偏偏大多数人不用、不会用，甚至错误地用…… 于是人与人之间的差异多了另外一个不断延展的维度。在这个维度上你不如人家你能怪谁？ 最烂的提问是：“我连不上 Google 怎么办呀？” 答案是“自己想办法” —— 如果你在乎，你就肯花时间自己解决这个问题，如果你不在乎，就不用在乎了。 使用“本尊”最好使用 http://www.google.com/ncr NCR: No Country Redirection，而不是http://www.google.com.hk；有时，直接输入http://www.google.com也会被自动转到“本地Google”，比如，我用日本的 VPN，浏览器就会把我转到http://www.google.co.jp…… 优先使用英文关键字搜索这是个好习惯。别说不会英文，不会就学，没那么难。 基本技巧Google 搜索引擎也许是世界上最简单的应用界面，只有一个输入框和一个按钮。然而，用好它还是需要花点时间去学习的。Google 有帮助文档，还专门设计了个学习网站 A Google A Day 加号在 Google 的输入框里，所有的空格都被 Google 理解为加号+。如果你输入的是 purpose of education那么 Google 返回的文章里既有“purpose”存在，也有“education”存在，但不一定有“purpose of education”存在。另外，过分常用的、单独存在没有意义的词汇往往被忽略掉，比如冠词“a”、“the”；介词“of”、“in”、“on”、“at”、“to”；连词“and”、“or”、“but”；从属连词“that”、“which”、“when”；代词“my”、“his”、“them”等等。 引号如果你想要找含有“purpose of education”这个词组的文章，那么你必须输入”purpose of education”。现在的 Google 已经可以处理 utf-8 大字符集了，所以，即便你在输入的时候使用的是全角字符（不是半角字符的”而是“或者”）Google也照样能够正确处理。比较一下两种输入返回的结果：purpose of education vs.“purpose of education”。再试试 the most important benefit of education 和 “the most important benefit of education”。这就是引号（“……”）的作用——返回“完整匹配”的结果。 减号为了进一步筛选搜索结果，还需要学会另外一个符号——减号-。比如，“the most important benefit of education” – “united states”要求Google返回含有“the most important benefit of education”但不存在“united states”的文章。 星号另外一个威力无穷的符号是星号。Google 支持通配符搜索，即搜索字符串中可以包含星号，用来替代任意字符串。比如，“the most * examples of censorship”将会返回含有类似“the most outrageous examples of censorship”、“the most brazen examples of censorship”、“the most heinous examples of censorship”、“the most stupidest examples of censorship”、“the most dangerous examples of censorship”、“the most egregious examples of censorship”、“the most prolific examples of censorship”、“the most absurd examples of censorship”…… 波浪号还有一个运用相当灵活、经常带来意外收获的符号是波浪号~。把波浪号~加在某个单词前面，是在告诉 Google：除了给出的关键字之外，还要搜索与波浪号~后面的那个单词相关的词汇。比如，搜索the importance of ~censorship的结果中包含着“the importance of censorship”，也包含着与censorship相关的另外一个词汇“propaganda”——“the importance of propaganda”。 高级技巧站内搜索再学一个在指定网站中搜索的语法“site:”。比如，“the purpose of education” site:http://www.time.com/就是要求 Google 只返回 http://www.time.com 这个网站里的含有“the purpose of education”的文章。 定制搜索2006年，Google 推出了“co-op”服务（自定义搜索引擎）。其中最常用的功能之一就是可以指定 Google 搜索一个或者若干个指定的网站——相当于前面提到的 Google 语法“site:”的扩展。比如，我就曾经为我的学生定制了一个 Google cse（Custom Search Engine）——Search News Media。不妨看看在这个自定义搜索引擎上搜索censorship返回的结果（GRE/SAT 的作文考试中，都有很多关于“censorship”的作文题）。这个 cse 只搜索以下10个网站： http://www.economist.com/ http://www.cnn.com/ http://www.time.com/ http://nytimes.com/ http://www.washingtonpost.com/ http://www.usnews.com/ http://usatoday.com/ http://www.reuters.com/ http://www.bbc.co.uk/ http://en.wikinews.org/ 特别声明 文章来自 七年就是一辈子-李笑来]]></content>
      <categories>
        <category>03-技术-计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈 iOS 事件的传递和响应过程]]></title>
    <url>%2F2018%2F06%2F08%2F%E6%B5%85%E8%B0%88-iOS-%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E9%80%92%E5%92%8C%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[问题 iOS 中 View 的事件到底是怎么传递和响应的？ 为什么 父View 关闭了事件响应时，子View 就无法响应事件？ 底层原理？ 如何扩大 Button 的点击范围 ？ 如何让 父View 和 子View 同时响应同一事件？默认情况下只会响应 子View 的事件回调。 为什么 子View 关闭了事件，但其 父View 开启事件的情况下，点击 子View 时，父View 可以正常响应事件？ 为什么 子View 是 UIView时，如果没有添加手势，点击子 View时，会由其父View来响应，而 子View 是 UIControl 时，子View 没有添加手势，一样不会由 父View 来响应 … 分析 iOS 的事件可以分为三种 Touch Events(触摸事件) Motion Events(运动事件，比如重力感应和摇一摇等) Remote Events(远程事件，比如用耳机上得按键来控制手机) 下面主要讲解 Touch Events(触摸事件) Touch Events事件的整个过程可以分为 传递和响应 2 个阶段， 传递： 是当我们触摸屏幕时，为我们找出最适合的 View， 响应： 当我们找出最适合的 View 后，此时只是找到了最合适的 View，但未必 此 View 可以响应此事件，所以需要继续找出能响应此事件的 View。 传递过程 每当手指接触屏幕，操作系统会把事件传递给当前的 App， 在 UIApplication接收到手指的事件之后，就会去调用`UIWindow的hitTest:withEvent:，看看当前点击的点是不是在window内，如果是则继续依次调用其 subView的hitTest:withEvent:方法，直到找到最后需要的view。调用结束并且hit-test view确定之后，便可以确定最合适的 View。 引用几张图来说明 图片表示的内容可用下面的话描述来自这里 递归是向界面的根节点UIWindow发送hitTest:withEvent:消息开始的，从这个消息返回的是一个UIView，也就是手指当前位置最前面的那个 hittest view。 当向UIWindow发送hitTest:withEvent:消息时，hitTest:withEvent:里面所做的事，就是判断当前的点击位置是否在window里面，如果在则遍历window的subview然后依次对subview发送hitTest:withEvent:消息(注意这里给subview发送消息是根据当前subview的index顺序，index越大就越先被访问)。如果当前的point没有在view上面，那么这个view的subview也就不会被遍历了。当事件遍历到了view B.1，发现point在view B.1里面，并且view B.1没有subview，那么他就是我们要找的hittest view了，找到之后就会一路返回直到根节点，而view B之后的view A也不会被遍历了。 下面是 - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event 方法的内部实现 1234567891011121314 - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; if (self.hidden || !self.userInteractionEnabled || self.alpha &lt; 0.01 || ![self pointInside:point withEvent:event] || ![self _isAnimatedUserInteractionEnabled]) &#123; return nil; &#125; else &#123; for (UIView *subview in [self.subviews reverseObjectEnumerator]) &#123; UIView *hitView = [subview hitTest:[subview convertPoint:point fromView:self] withEvent:event]; if (hitView) &#123; return hitView; &#125; &#125; return self; &#125;&#125; 上面的代码来自这里 响应过程 个人对响应过程的理解如下： 当我们知道最合适的 View 后，事件会 由上向下【子view -&gt; 父view，控制器view -&gt; 控制器】来找出合适响应事件的 View，来响应相关的事件。如果当前的 View 有添加手势，那么直接响应相应的事件，不会继续向下寻找了，如果没有手势事件，那么会看其是否实现了如下的方法： 1234- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; 如果有实现那么就由此 View 响应，如果没有实现，那么就会传递给他的下一个响应者【子view -&gt; 父view，控制器view -&gt; 控制器】， 这里我们可以做一个简单的验证，在默认情况下 UIView 是不响应事件的，UIControl 就算没有添加手势一样的会由他来响应， 这里可以使用 runtime查看 UIView 和 UIControl 的方法列表， 或 查看 UIKit 源码 可知， UIView 没有实现如上的 touchesBegan方法，而 UIControl 是实现了如上的相关方法，所以验证了刚才的 UIView 不响应，和 UIControl 的响应。一旦找到最合适响应的View就结束, 在执行响应的绑定的事件，如果没有就抛弃此事件。 我的验证 首先处理添加了手势时，其便可以处理事件。 我们创建一个view A 在 A 中添加一个 view B, 如果我们给 A 加了手势，B没有加手势， 我们在点击 B 时，会响应 A 的事件，非常正常的情况，那么它是怎么判断 B 是否可以处理的呢？ 我们现在给 B 加一个手势，那么同样的操作时会触发 B 的手势，现在我们 给 B 增加一个方法， @implementation BMSonView - (NSArray&lt;UIGestureRecognizer *&gt; *)gestureRecognizers { NSLog(@"%@", self); return @[]; } 手势返回 @[]，此时点击 B 只会触发 A 的事件，由此可以说明在判断 view 是否可以处理事件实现是判断 gestureRecognizers 即是否添加了手势，上面提到了还有判断如下的方法是否实现了,默认情况下 UIView 是没有实现如下的方法的，使用在没有添加手势时他不响应事件。 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event; - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event; - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event; - (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; 如果我们手动实现了如上的方法时，就算没有给 B 添加手势，点击 B 时， 事件不会响应 A 的方法，会到上面的方法中。从 UIControl 的源码便可清除看到。 所以个人理解： 事件在传递时和上面的 hit 方法有关，一层层向上传递，【窗口—&gt; view】由其相应的 view 中具体的实现来确定谁才是是最合适响应的view 在响应时，又上向下找出第一个能处理的view来处理事件，[view —&gt; 窗口]，在寻找刚过程中 会判断是否增加了手势 和是否实现了如上的 触摸方法。 至于 UIControl Button 的特殊事件相应，个人认为是在其m文件中实现了上面的4个方法，在这4个方法中做了相关的处理，这里可以从 UIControl 代码中在知道一些内容。 所以如果想自己实现 UIControl Button ，首先要想办法处理好上面的4个方法。 图如下 问题解答 iOS 中 View 的事件到底是怎么传递和响应的？ 如上所描。 为什么 父View 关闭了事件响应时，子View 就无法响应事件？ 因为在事件传递的时，先到父view，当父view无法响应事，直接就跳过了遍历其子view，故只要父类关闭了事件，子 view 就已经没有机会响应事件了。 如何扩大 Button 的点击范围？ 扩大点击范围，无非就是想本来没有点击 btn 但想让 btn 响应事件，那么可以在 hitTest 方法中做适当的操作，当满足xxx条件时，强行返回 btn 来达到最佳点击范围的效果，相关的实现可以自行 Google ，有一些较优雅而简洁的方式。 如何让 父View 和 子View 同时响应同一事件？ 父View 和 子View同时响应同一事件，默认当点击子view时，如果ziview可以处理事件，那么其他父view 是不会响应的，但是在 父view 传到 子view 时我们在 hitTest 方法中是清楚知道的，使用可以在这里做相关的操作便实现了子view 和父view 同时响应事件的效果。 为什么子View 关闭了事件，但其 父View 开启事件的情况下，点击 子View 时，父View 可以响应事件？ 子view关闭了事件，事件的传递是 父view 到子view，在 父view时，父view可以响应，那么会继续访问其 子view是否可以响应，如果此时子view不可以响应，那么他会直接返回 父view，所以 子View 关闭了事件 父View 正常执行事件是必然的。 为什么 子View 是 UIView时，如果没有添加手势，点击子 View时，会由其父View来响应，而 子View 是 UIControl 时，子View 没有添加手势，一样不会由 父View 来响应 这个问题可以见上面的寻找可以响应的 view 来解决，UIControl 实现了如上的 4 大方法，而 UIView 没有实现。 这里其实还有许多内容待挖掘，比如：scrollview 的事件响应等。 参考资料 http://smnh.me/hit-testing-in-ios/ https://zhoon.github.io/ios/2015/04/12/ios-event.html http://southpeak.github.io/blog/2015/03/07/uiresponder/ https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIScrollView_Class/index.html#//apple_ref/doc/uid/TP40006922 https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW2 https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW2]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单说说 MJExtension 实现原理]]></title>
    <url>%2F2016%2F10%2F28%2F1111%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4-MJExtension-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[原始方法 首先我们的模型是这样的，只有2个属性 1234@interface BMUser : NSObject@property (nonatomic, copy) NSString *name; ///&lt; name@property (nonatomic, assign) int age; ///&lt; age@end 使用最原始的方法把json-&gt;Models时,代码如下 1234567891011// 1.获取json数据NSString *json = @"&#123;\"name\" : \"idhong\", \"age\" : 15&#125;";// 2.json-&gt;NSDictionaryNSDictionary *jsonDict = [NSJSONSerialization JSONObjectWithData:[json dataUsingEncoding:NSUTF8StringEncoding] options:kNilOptions error:NULL];// 3.创建userBMUser *user = [BMUser new];// 4.赋值user.name = jsonDict[@"name"];user.age = [jsonDict[@"age"] intValue];// 其他属性设置NSLog(@""); 稍微优化下，使用setValuesForKeysWithDictionary可以简化赋值代码如下。 12345678// 1.获取json数据NSString *json = @"&#123;\"name\" : \"idhong\", \"age\" : 15&#125;";// 2.json-&gt;NSDictionaryNSDictionary *jsonDict = [NSJSONSerialization JSONObjectWithData:[json dataUsingEncoding:NSUTF8StringEncoding] options:kNilOptions error:NULL];// 3.创建userBMUser *user = [BMUser new];// 4.赋值[user setValuesForKeysWithDictionary:jsonDict]; 如果属性特别多，而且模型嵌套模型时手写就特别麻烦而且容易出错，其中至少包括如下问题； 1.模型的属性是另一个模型 2.模型的属性是数组（数组中的对象又是模型） 3.以及相互嵌套等。 使用setValuesForKeysWithDictionary无法解决问题，同时手动编码无法想象。 归根结底 json -&gt; Model 主要是以下3步 1.创建模型 2.为模型中的属性赋值 3.返回模型 其中最核心的就是第2步，怎么样动态的为模型赋值，当然是使用Runtime,MJExtension 算是使用率较多的一个库，下面就简单分析下其实现原理吧。 1.使用Runtime动态获取模型的属性（包括继承链的所有属性，MJExtension对模型的属性做了缓存，下次转换时自己使用，空间换时间） 2.又第1步获取到的属性可以解析出各属性的全部信息（包括属性类型，属性修饰符等参考这里 ) 3.第2步获取属性后，取到属性名在去NSDictionary)中获出相应的值 4.在第3步取出的值使用KVC设置给Model即可(MJExtension使用KVC赋值，YYModel底层是直接使用objc_msgSend) 5.所以为什么如果模型中有属性是数组，数组中又是模型时，需要我们指定其类型，才可为我们主动将其转换。 怎样自己实现MJExtension 动态获取模型属性 解析属性相关信息 如果是数组类型，因为不知道数组中应该存放具体的类型，所以需提供方法让使用者提供具体的类型 使用KVC赋值 其他扩展信息，包括黑名单，白名单，换属性名，转换结束等等扩展信息。 分析MJExtension 引用一张图 MJExtension 一共21个文件，主要用3个类，5个分类 MJExtension.h头文件 MJExtensionConst 一些常量，宏，版本控制等 MJFoundation主要是提供判断是否为Foundation框架的类 MJProperty封装属性对象（objc_property_t内部包括属性名称，属性类型等相关信息） MJPropertyKey 属性的key MJPropertyType 属性类型（类型标识符这里，是否id，是否基本数据类型等） NSString+MJExtension字符串的一些扩展（包括下划线，大小写等处理） NSObject+MJProperty主要提供遍历一个类的属性列表 NSObject+MJCoding提供归档功能 NSObject+MJClass提供扩展功能，黑名单，白名单，数组中的类型自定义等。 MJExtension源码解读 我们使用最基本的dict-&gt;Model方法是: 1+ (instancetype)mj_objectWithKeyValues:(id)keyValues; 其实现在NSObject+MJKeyValue.m的203行如下 1234+ (instancetype)mj_objectWithKeyValues:(id)keyValues&#123; return [self mj_objectWithKeyValues:keyValues context:nil];&#125; 内部调用了下面的方法 123456789101112+ (instancetype)mj_objectWithKeyValues:(id)keyValues context:(NSManagedObjectContext *)context&#123; // 获得JSON对象 keyValues = [keyValues mj_JSONObject]; MJExtensionAssertError([keyValues isKindOfClass:[NSDictionary class]], nil, [self class], @&quot;keyValues参数不是一个字典&quot;); if ([self isSubclassOfClass:[NSManagedObject class]] &amp;&amp; context) &#123; NSString *entityName = [NSStringFromClass(self) componentsSeparatedByString:@&quot;.&quot;].lastObject; return [[NSEntityDescription insertNewObjectForEntityForName:entityName inManagedObjectContext:context] mj_setKeyValues:keyValues context:context]; &#125; return [[[self alloc] init] mj_setKeyValues:keyValues];&#125; 首先是mj_JSONObject方法，其作用是把NSData或者NSString为NSDictionary类型，因为上面的方法支持NSDictionary，NSString，NSData类型，其具体实现就不在赘述了。 这里先不考虑CoreData及NSManagedObject 然后是创建模型同时调用赋值属性 1[[[self alloc] init] mj_setKeyValues:keyValues] 最后调到 1- (instancetype)mj_setKeyValues:(id)keyValues context:(NSManagedObjectContext *)context 此方法是整个库的核心代码部分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128- (instancetype)mj_setKeyValues:(id)keyValues context:(NSManagedObjectContext *)context&#123; // 获得JSON对象 keyValues = [keyValues mj_JSONObject]; MJExtensionAssertError([keyValues isKindOfClass:[NSDictionary class]], self, [self class], @&quot;keyValues参数不是一个字典&quot;); Class clazz = [self class]; NSArray *allowedPropertyNames = [clazz mj_totalAllowedPropertyNames]; NSArray *ignoredPropertyNames = [clazz mj_totalIgnoredPropertyNames]; //通过封装的方法回调一个通过运行时编写的，用于返回属性列表的方法。 [clazz mj_enumerateProperties:^(MJProperty *property, BOOL *stop) &#123; @try &#123; // 0.检测是否被忽略 if (allowedPropertyNames.count &amp;&amp; ![allowedPropertyNames containsObject:property.name]) return; if ([ignoredPropertyNames containsObject:property.name]) return; // 1.取出属性值 id value; NSArray *propertyKeyses = [property propertyKeysForClass:clazz]; for (NSArray *propertyKeys in propertyKeyses) &#123; value = keyValues; for (MJPropertyKey *propertyKey in propertyKeys) &#123; value = [propertyKey valueInObject:value]; &#125; if (value) break; &#125; // 值的过滤 id newValue = [clazz mj_getNewValueFromObject:self oldValue:value property:property]; if (newValue != value) &#123; // 有过滤后的新值 [property setValue:newValue forObject:self]; return; &#125; // 如果没有值，就直接返回 if (!value || value == [NSNull null]) return; // 2.复杂处理 MJPropertyType *type = property.type; Class propertyClass = type.typeClass; Class objectClass = [property objectClassInArrayForClass:[self class]]; // 不可变 -&gt; 可变处理 if (propertyClass == [NSMutableArray class] &amp;&amp; [value isKindOfClass:[NSArray class]]) &#123; value = [NSMutableArray arrayWithArray:value]; &#125; else if (propertyClass == [NSMutableDictionary class] &amp;&amp; [value isKindOfClass:[NSDictionary class]]) &#123; value = [NSMutableDictionary dictionaryWithDictionary:value]; &#125; else if (propertyClass == [NSMutableString class] &amp;&amp; [value isKindOfClass:[NSString class]]) &#123; value = [NSMutableString stringWithString:value]; &#125; else if (propertyClass == [NSMutableData class] &amp;&amp; [value isKindOfClass:[NSData class]]) &#123; value = [NSMutableData dataWithData:value]; &#125; if (!type.isFromFoundation &amp;&amp; propertyClass) &#123; // 模型属性 value = [propertyClass mj_objectWithKeyValues:value context:context]; &#125; else if (objectClass) &#123; if (objectClass == [NSURL class] &amp;&amp; [value isKindOfClass:[NSArray class]]) &#123; // string array -&gt; url array NSMutableArray *urlArray = [NSMutableArray array]; for (NSString *string in value) &#123; if (![string isKindOfClass:[NSString class]]) continue; [urlArray addObject:string.mj_url]; &#125; value = urlArray; &#125; else &#123; // 字典数组--&gt;模型数组 value = [objectClass mj_objectArrayWithKeyValuesArray:value context:context]; &#125; &#125; else &#123; if (propertyClass == [NSString class]) &#123; if ([value isKindOfClass:[NSNumber class]]) &#123; // NSNumber -&gt; NSString value = [value description]; &#125; else if ([value isKindOfClass:[NSURL class]]) &#123; // NSURL -&gt; NSString value = [value absoluteString]; &#125; &#125; else if ([value isKindOfClass:[NSString class]]) &#123; if (propertyClass == [NSURL class]) &#123; // NSString -&gt; NSURL // 字符串转码 value = [value mj_url]; &#125; else if (type.isNumberType) &#123; NSString *oldValue = value; // NSString -&gt; NSNumber if (type.typeClass == [NSDecimalNumber class]) &#123; value = [NSDecimalNumber decimalNumberWithString:oldValue]; &#125; else &#123; value = [numberFormatter_ numberFromString:oldValue]; &#125; // 如果是BOOL if (type.isBoolType) &#123; // 字符串转BOOL（字符串没有charValue方法） // 系统会调用字符串的charValue转为BOOL类型 NSString *lower = [oldValue lowercaseString]; if ([lower isEqualToString:@&quot;yes&quot;] || [lower isEqualToString:@&quot;true&quot;]) &#123; value = @YES; &#125; else if ([lower isEqualToString:@&quot;no&quot;] || [lower isEqualToString:@&quot;false&quot;]) &#123; value = @NO; &#125; &#125; &#125; &#125; // value和property类型不匹配 if (propertyClass &amp;&amp; ![value isKindOfClass:propertyClass]) &#123; value = nil; &#125; &#125; // 3.赋值 [property setValue:value forObject:self]; &#125; @catch (NSException *exception) &#123; MJExtensionBuildError([self class], exception.reason); MJExtensionLog(@&quot;%@&quot;, exception); &#125; &#125;]; // 转换完毕 if ([self respondsToSelector:@selector(mj_keyValuesDidFinishConvertingToObject)]) &#123; [self mj_keyValuesDidFinishConvertingToObject]; &#125; return self;&#125; 获取模型可以转换和忽略的属性 12NSArray *allowedPropertyNames = [clazz mj_totalAllowedPropertyNames];NSArray *ignoredPropertyNames = [clazz mj_totalIgnoredPropertyNames]; 此方法在调用时，这里做了缓存处理，只会访问一次，同时会调到外层的使用者实现的方法中 然后调用 1+ (void)mj_enumerateProperties:(MJPropertiesEnumeration)enumeration 遍历所有的属性，此方法同样做了缓存处理，如果某Class遍历过，此库内部会把其数组缓存起来，下次直接遍历即可 在Block回调中可以获取到每一个MJProperty（封装的属性） 几步比较常规的操作，在库用用详细的注释 检测是否被忽略 取出属性值 值的过滤（提供了尾部可以对特殊值做处理的功能） 复杂类型处理 实现是对NSArray-&gt;NSMutableArray，NSData-&gt;NSMutableData，NSDictionary-&gt;NSMutableDictionary做可变处理。 因为对复杂类型需继续继续转换。 如果是模型（ !type.isFromFoundation &amp;&amp; propertyClass ）就重复最开始的方法 如果是NSURL 就把NSString转换为NSURL 如果是 字典数组-由继续最开始的方法调用 NSNumber类型 BOOL等类型的转换 最后使用KVC赋值，当然在内部做了是否支持KVC的判断。 12// 3.赋值[property setValue:value forObject:self]; 总结 综上所述，MJExtension的底层实现还算常规，动态获取属性 属性的类型判断 必要的缓存 KVC赋值 其他性细节优化和扩展。 其他 有时间分析下YYModel，其使用到了CoreFoundation和objc_msgSend。]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS单元测试入门]]></title>
    <url>%2F2016%2F05%2F27%2FiOS%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[简单介绍 本文主要是讲 XCTest 的使用 我们知道在程序的开发中，单元测试是相当的重要，废话不多说，直接动手吧。 我们在创建 Xcode 项目的时候全部勾选的话默认会创建 XCTestDemoTests XCTestDemoUITests 这 2 个模块。现在主要讲解 XCTestDemoTests的使用。其中的模板代码如下： 12345678910111213141516171819202122232425// 每次测试前调用，可以在测试之前创建在test case方法中需要用到的一些对象等// Put setup code here. This method is called before the invocation of each test method in the class.- (void)setUp &#123;&#125;// 每次测试结束时调用tearDown方法// Put teardown code here. This method is called after the invocation of each test method in the class.- (void)tearDown &#123;&#125;// 单元测试方法的例子// 我们可以自定义添加 - (void)testxxxx&#123;&#125; 方法，- (void)testxxx 类似的方法在启动测试的时候都会自动跑。// This is an example of a functional test case.// Use XCTAssert and related functions to verify your tests produce the correct results.- (void)testExample &#123;&#125;// 性能测试方法，通过测试block中方法执行的时间，比对设定的标准值和偏差觉得是否可以通过测试- (void)testPerformanceExample &#123; // This is an example of a performance test case. [self measureBlock:^&#123; // Put the code you want to measure the time of here. &#125;];&#125; XCTAssert 的使用，在单元测试中，我们通常使用 XCTAssert 相关的方法，方法有如下： 1234567891011121314151617181920212223242526// 通用断言，为 true 就通过测试XCTAssert(false);// 为 true 就通过测试XCTAssertTrue(false);// 为 false 就通过测试XCTAssertFalse(true);// 相等就通过测试XCTAssertEqual(1, 2);// 不相等就通过测试XCTAssertNotEqual(0, 0);// 相差的值在精确度范围内就通过测试XCTAssertEqualWithAccuracy(10, 12, 1);// 相差的值不在精确度范围内就通过测试XCTAssertNotEqualWithAccuracy(10, 12, 1);// 为 nil 就通过测试XCTAssertNil(nil);// 不为 nil 就通过测试XCTAssertNotNil(nil);// 直接不通过测试,可以自己判断是否加 XCTFail();XCTFail(); 我们可以使用 ❀ + U 来启动全部单元测试 ❀ + 6 切换到测试模块 这个和 Xcode 的版本有关 或者使用下图的方法来启动测试: 如何写测试用例呢？ 比如我们在开发框架的时候，一般会写一些测试用例。下面我们就模拟写一个简单的框架，同时我们写一些测试用例。如：我们要写一个获取 URL 中的参数的方法。 代码如下： 1234567891011#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface NSString (BMURLParams)@property (nonatomic, copy, readonly) NSDictionary *bm_URLParams; ///&lt; URLParams@endNS_ASSUME_NONNULL_END 12345678910111213141516171819202122#import &quot;NSString+BMURLParams.h&quot;@implementation NSString (BMURLParams)- (NSDictionary *)bm_URLParams &#123; NSRange range = [self rangeOfString:@&quot;?&quot;]; if (range.location == NSNotFound) &#123; return nil; &#125; NSString *propertys = [self substringFromIndex:(range.location+1)]; NSMutableDictionary *tempDic = @&#123;&#125;.mutableCopy; [[propertys componentsSeparatedByString:@&quot;&amp;&quot;] enumerateObjectsUsingBlock:^(NSString * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; NSArray *dicArray = [obj componentsSeparatedByString:@&quot;=&quot;]; if (dicArray.count &gt; 1) &#123; tempDic[dicArray[0]] = dicArray[1]; &#125; &#125;]; return tempDic;&#125;@end 我们在 XCTestDemoTests 文件中，实现导入 #import &quot;NSString+BMURLParams.h&quot; 同时加上如下的方法： 12345678910111213141516- (void)test_URLParams &#123; XCTAssert(@&quot;https://www.baidu.com/s&quot;.bm_URLParams == nil); XCTAssert([(@&quot;https://www.baidu.com/s?name=jck&quot;.bm_URLParams) isEqualToDictionary:(@&#123;@&quot;name&quot; : @&quot;jck&quot;&#125;)]); XCTAssert([(@&quot;https://www.baidu.com/s?name=jack&amp;type=1&quot;.bm_URLParams) isEqualToDictionary:(@&#123;@&quot;name&quot; : @&quot;jack&quot;, @&quot;type&quot; : @&quot;1&quot;&#125;)]); XCTAssert([(@&quot;https://www.baidu.com/s?name=jack&amp;type=1&amp;user=80222&quot;.bm_URLParams) isEqualToDictionary:(@&#123;@&quot;name&quot; : @&quot;jack&quot;, @&quot;type&quot; : @&quot;1&quot;, @&quot;user&quot; : @&quot;80222&quot;&#125;)]);&#125; 跑一下测试用例，发现如下的效果 说明我们的用例全部通过了，当然这里的用例比较少，我们可以加上各种可能的情况。现在我们把获取参数的代码故意写错为如下的代码： 123456789101112131415161718192021#import &quot;NSString+BMURLParams.h&quot;@implementation NSString (BMURLParams)- (NSDictionary *)bm_URLParams &#123; NSRange range = [self rangeOfString:@&quot;?&quot;]; if (range.location == NSNotFound) &#123; return nil; &#125; NSString *propertys = [self substringFromIndex:(range.location+1)]; NSMutableDictionary *tempDic = @&#123;&#125;.mutableCopy; [[propertys componentsSeparatedByString:@&quot;&amp;&quot;] enumerateObjectsUsingBlock:^(NSString * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; NSArray *dicArray = [obj componentsSeparatedByString:@&quot;=&quot;]; if (dicArray.count &gt; 1) &#123; tempDic[dicArray[1]] = dicArray[0]; &#125; &#125;]; return tempDic;&#125;@end 在跑一下单元测试就会有如下的效果： 性能测试 现在我们模拟测试网络接口的返回速度是否复合我们的预期，实现我们创建应该发送网络请求的类 BMRequestManager, 代码如下： 123@interface BMRequestManager : NSObject+ (void)getDataWithSuccBlock:(dispatch_block_t)block;@end 1234567@implementation BMRequestManager+ (void)getDataWithSuccBlock:(dispatch_block_t)block &#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(6.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; !block ? : block(); &#125;);&#125;@end 我们编写测试用例代码： 12345678910111213141516171819202122- (void)testExampleRequest &#123; // 1、创建 XCTestExpectation XCTestExpectation *exp = [self expectationWithDescription:@&quot;这个请求太慢了&quot;]; // 2、具体的网络请求 [BMRequestManager getDataWithSuccBlock:^&#123; // 收到数据了 // 发送 fulfill 消息 [exp fulfill]; &#125;]; // 3、定义预期需要在 xxx 时间内获取到数据 NSTimeInterval time = 15; //4、如果超过 xxx 时间就报错 [self waitForExpectationsWithTimeout:time handler:^(NSError * _Nullable error) &#123; if (error) &#123; NSLog(@&quot;Timeout Error: %@&quot;, error); &#125; &#125;];&#125; 由于我们上面设置的预期时间是 15 秒，但我们实际我们 6 秒就获取到了数据，使用我们在跑用例的时候用如下效果： 如果我们设置的预期时间是 5 秒，代码如下： 12345678910111213141516171819202122- (void)testExampleRequest &#123; // 1、创建 XCTestExpectation XCTestExpectation *exp = [self expectationWithDescription:@&quot;这个请求太慢了&quot;]; // 2、具体的网络请求 [BMRequestManager getDataWithSuccBlock:^&#123; // 收到数据了 // 发送 fulfill 消息 [exp fulfill]; &#125;]; // 3、定义预期需要在 xxx 时间内获取到数据 NSTimeInterval time = 5.0; //4、如果超过 xxx 时间就报错 [self waitForExpectationsWithTimeout:time handler:^(NSError * _Nullable error) &#123; if (error) &#123; NSLog(@&quot;Timeout Error: %@&quot;, error); &#125; &#125;];&#125; 跑用例的时候有如下效果： 说明用例不通过。 当然我们也可以测试其他的一些代码的执行时间和预期时间来比较，看代码是否通过预期时间。 参考 http://liuyanwei.jumppo.com/2016/03/10/iOS-unit-test.html]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Hexo 搭建个人博客]]></title>
    <url>%2F2016%2F04%2F08%2F%E4%BD%BF%E7%94%A8-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[说在前面 hexo.io 什么是 Hexo ？ Hexo 是一个快速、简洁且高效的博客框架, Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页 来自这里。 Hexo 由一个台湾同胞开发的 Blog 框架 https://github.com/tommy351, 和 Github 或 Coding 配合可以非常简单而免费的搭建一个漂亮的个人 Blog，而且可以自定义域名，下面就简单介绍其使用吧。 购买域名 域名购买可到 阿里云 或者 godaddy 购买即可，大概 60RMB/年，而且可以自定义域名邮箱，看起来高端大气上档次😄。如：ios@liangdahong.com其实没什么 X 用 具体就不介绍了。 环境 Hexo 支持 Windows 和 masOS，需安装好 Node.js Git 具体的安装可自行 Google 安装 Hexo 在安装好环境后，使用如下的命令安装 Hexo 1npm install -g hexo-cli 在安装好 Hexo 后，我们初始化自己的 Blog ，首先创建 Blog 需要保存的文件夹，在进入文件夹下。 12cd blog/ 初始化 Blog 12hexo init 初始化完成后我们可以看到有如下的文件夹结构 1234567891011121314_config.ymlnode_modulespackage-lock.jsonpackage.jsonscaffoldssourcethemes _config.yml 文件是 Blog 的一些基本配置, 具体可以参考官网的说明。 预览, 可使用如下命令预览 Blog，然后在浏览器输入 http://localhost:4000 即可看到 Blog 的效果了 1hexo s 创建一篇文章 1hexo new &quot;你的文章名称&quot; 现在我们在本地已经可以看到 Blog 了，那么我们怎么部署到服务器上呢？ 让别人也可以看到我们的 Blog 我们需要去 Github 创建一个项目，命名为：name.github.io 如：iangdahong.github.io 然后去开启 GitHub Pages 然后在刚才我们初始化的 Blog 的 _config.yml 中做具体的修改。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Hexosubtitle:description:keywords:author: John Doelanguage:timezone:# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = &apos;&apos;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &apos;&apos; per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 如上，现在我们需要把 Blog 部署到 Github 上， 1234// 生成静态 html 文件hexo g// 部署到 githubhexo d 现在你可以使用 xxxxx.github.io 访问你的 Blog 了。 现在我们使用的是 Hexo 提供的默认主题，其实 github 上已经有大量的开源的漂亮的主题如：next 我们使用自定义的主题， 我们把我们知道的主题 clone 到 themes 下， 然后在 _config.yml 中修改主题为你使用的主题， 在使用如上的方法部署到 github 即可使用自定义的主题了。 基本配置 一些简单的配置开源参考 hexo 和 相应的主题做自定义修改 自定义域名 github 支持自定义域名，在刚才我们创建的项目中可以设置自定义的域名，但需要先做好域名解析，具体的操作可以 Google 下 Https 在之前 github 是不支持 https 的，但在不久前已经支持了 https。 其他配置 其他扩展的较多：评价系统，统计系统，分享，打赏等，可以自行探索。下面的 Blog 提供了许多的扩展设置，可以参考下。 https://segmentfault.com/a/1190000009544924 其他 我们可以会思考一个问题 ？现在我们可以写 Blog 了，那么如果我们换电脑了怎么破？其实 我们在使用 hexo g 命令时，是把我们写好的 Markdown 编译 为 html css 文件。在 public 中，我们使用 hexo d 的时候 其实是吧 public 文件的内容全部同步到 github 上去了，你可以去验证下，所以如果你自己写的 html 可以直接放到 public 中 然后部署上去也一样可以使用。 所以我们刚才创建的的项目存储的是生成的 html 文件，那么我们的源文件呢？ 如果换电脑了就没办法获取了，所以我们可以使用 github 在同步我们的源文件，我们在 github 上在创建一个项目来专门存放 我们的 blog 源文件，同时把 public 忽略调，那么我们在换电脑后只需要配置好环境便随时随地可以愉快的写 blog 了。 Blog 加速，国内时访问 Coding, 国外访问 Github ，需把 Blog 同时部署在 2 个平台，同时域名解析为：国外访问 Github，国内访问 Coding 。 以下博客给于了帮助 1、晋先森从购买域名到域名邮箱，搭建博客等 2、Hexo博客优化配置之–为自己博客添加站内搜索 3、Hexo博客优化配置之–为自己博客添加搜索引擎网页收录 4、hexo+github搭建个人博客 5、http://www.voidking.com/tags/hexo/ 6、 https://segmentfault.com/a/1190000009544924/]]></content>
      <categories>
        <category>04-技术-Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
