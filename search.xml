<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2019%2F12%2F06%2FGit%2F</url>
    <content type="text"><![CDATA[Git 官网 https://git-scm.com/ 查看git版本git version 创建git仓库已经有源代码的情况cd your_projectgit initgit init your_project 配置用户名对当前用户所有的仓库有效git config –global user.name ‘your_name’git config –global user.email ‘your_email’ // 对指定仓库有效git config –local user.name ‘your_name’git config –local user.email ‘your_email’ // 对系统所有登录的用户有效git config –system user.name ‘your_name’git config –system user.email ‘your_email’ 查看当前的设置git config –list –localgit config –list –globalgit config –list –system git config –local user.name ‘梁大红’git config –local user.email &#39;ios@liangdahong.com‘ // 全部文件添加到暂存区git add .// 指定名字添加git add file_name file_name1 file_nam2// 已经管理的文件全部提交到暂存区git add -u // 查看状态git status 放弃全部修改【已经是 git 管理的文件】git checkout . // 差提交日志git log// 简化为一个列表git log –oneline// 查看最近的几次提交git log -n2git log -n2 –oneline // 全部分支的历史git log –all graph 图形化oneline 一行all: all branchn2: xxx条提交 git log –oneline –all -n4 –graphgit log -n2 –oneline –graph git branch -v 查看本地分支git branch -r 查看远程分支git branch -a 查看本地+远程分支 gitk 就可以启动 git 自带的图形化界面 git branch 命令行命令 重命名 拷贝文件到指定目录cp xxx/xxxx.png xxx/xxx/xx/aaa.pngcp xxx/xxxx.png xxx/xxx/xx/ 拷贝文件夹到指定路径cp -r xxx/xxxx xxx/xxx/xx/ 输出文件的内容到控制台cat ssss.h rm -rf xx/xxx/xxx/xxx/xx/rm -f 删除文件rm -rf 可删除文件夹创建文件夹mkdir xxx vimviq!wqq]]></content>
  </entry>
  <entry>
    <title><![CDATA[vapor]]></title>
    <url>%2F2019%2F12%2F02%2Fvapor%2F</url>
    <content type="text"><![CDATA[https://www.yuque.com/fcwys/linux/exgglu 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146supervisorctl status //查看所有进程的状态supervisorctl stop es //停止essupervisorctl start es //启动essupervisorctl restart //重启essupervisorctl update //配置文件修改后使用该命令加载新的配置supervisorctl reload //重新启动配置中的所有程序注：把es换成all可以管理配置中的所有进程。直接输入supervisorctl进入supervisorctl的shell交互界面，此时上面的命令不带supervisorctl可直接使用。kill 进程sudo lsof -i :8080 sudo lsof -i :8080======// 修改代码1、修改代码2、打包 vapor build --release3、 重新启动sudo supervisorctl restart Hello======Nginx配置：替换以下“你的域名” 为你的域名地址， api 根据你的需要换成 www 或者其他字符。第一步sudo vi /etc/nginx/sites-available/api.你的域名.com第二步，填入以下内容，然后按 esc 输入 :wq 按回车server &#123; server_name api.你的域名.com; listen 80; try_files $uri @proxy; client_max_body_size 20m; location @proxy &#123; proxy_pass http://127.0.0.1:8080; proxy_pass_header Server; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass_header Server; proxy_connect_timeout 3s; proxy_read_timeout 10s; &#125;&#125;[program:hexo]command=sudo /home/hexo/.build/release/Run serve --env=productiondirectory=/home/ubuntu/Helloautorestart=falseuser=rootstdout_logfile=/var/log/supervisor/%(program_name)-stdout.logstderr_logfile=/var/log/supervisor/%(program_name)-stderr.log第三步 执行sudo ln -s /etc/nginx/sites-available/api.你的域名.com /etc/nginx/sites-enabled/api.你的域名.comsudo ln -s /etc/nginx/sites-available/hexo.com /etc/nginx/sites-enabled/hexo.com第四步，执行以下2个命令sudo service nginx startsudo service nginx reloadsudo service nginx restartapiserver &#123; server_name api.liangdahong.com; listen 80; try_files $uri @proxy; client_max_body_size 20m; location @proxy &#123; proxy_pass http://127.0.0.1:8080; proxy_pass_header Server; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass_header Server; proxy_connect_timeout 3s; proxy_read_timeout 10s; proxy_redirect off; &#125;&#125;blog server&#123; listen 8081 default_server; listen [::]:8081 default_server; server_name blog.liangdahong.com; root /home/hexoBlog;&#125;server &#123; server_name blog.liangdahong.com; listen 80; try_files $uri @proxy; client_max_body_size 20m; root /home/hexoBlog; location @proxy &#123; proxy_pass http://127.0.0.1:8081; proxy_pass_header Server; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass_header Server; proxy_connect_timeout 3s; proxy_read_timeout 10s; proxy_redirect off; &#125;&#125;server &#123;listen 8081 default_server;listen [::]:8081 default_server;server_name blog.liangdahong.com;root /home/hexoBlog;&#125;server &#123;listen 8081 default_server;listen [::]:8081 default_server;server_name blog.liangdahong.com;root /home/hexoBlog;&#125;sudo ln -s /etc/nginx/sites-available/api.liangdahong.com /etc/nginx/sites-enabled/api.liangdahong.comsudo ln -s /etc/nginx/sites-available/hexo.com /etc/nginx/sites-enabled/hexo.com第四步，执行以下2个命令vim sudo service nginx reloadsudo ln -s /etc/nginx/sites-available/blog.liangdahong.com /etc/nginx/sites-enabled/blog.liangdahong.comsudo ln -s /etc/nginx/sites-available/api.liangdahong.com /etc/nginx/sites-enabled/api.liangdahong.com mac -&gt; linux https://blog.csdn.net/m82_a1/article/details/97624965 使用 id_rsa.pub /home/ubuntu/.ssh/authorized_keys scp /Users/Mac/Desktop/1/He.java ubuntu@123.207.253.160:/home/ubuntu/ scp /Users/bluemoon/Desktop/未命名文件夹/操作.jpeg ubuntu@123.207.253.160:/home/ubuntu/ 注意腾讯的是 ubuntu 不是 root scp /home/hexoBlog/index.html /home/root/ scp -r /Users/Mac/Desktop/root ubuntu@123.207.253.160:/home/ sudo scp -r /Users/Mac/Desktop/root ubuntu@123.207.253.160:/home/ sudo chmod -R 777 myResources -R 是指级联应用到文件夹里的全部子文件夹和文件 777 是全部用户都拥有最高权限 myResources 具体的文件夹或者资源 ssh 登录到ubuntu ssh ubuntu@123.207.253.160 进入 rootsu root退出 rootexit // 看系统版本cat /etc/issue apt install nginx-coreapt install nginx-extrasapt install nginx-fullapt install nginx-light]]></content>
  </entry>
  <entry>
    <title><![CDATA[vapor]]></title>
    <url>%2F2019%2F12%2F02%2Fvapor11%2F</url>
    <content type="text"><![CDATA[https://www.yuque.com/fcwys/linux/exgglu 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182supervisorctl status //查看所有进程的状态supervisorctl stop es //停止essupervisorctl start es //启动essupervisorctl restart //重启essupervisorctl update //配置文件修改后使用该命令加载新的配置supervisorctl reload //重新启动配置中的所有程序注：把es换成all可以管理配置中的所有进程。直接输入supervisorctl进入supervisorctl的shell交互界面，此时上面的命令不带supervisorctl可直接使用。kill 进程sudo lsof -i :8080 sudo lsof -i :8080======// 修改代码1、修改代码2、打包 vapor build --release3、 重新启动sudo supervisorctl restart Hello======Nginx配置：替换以下“你的域名” 为你的域名地址， api 根据你的需要换成 www 或者其他字符。第一步sudo vi /etc/nginx/sites-available/api.你的域名.com第二步，填入以下内容，然后按 esc 输入 :wq 按回车server &#123; server_name api.你的域名.com; listen 80; try_files $uri @proxy; client_max_body_size 20m; location @proxy &#123; proxy_pass http://127.0.0.1:8080; proxy_pass_header Server; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass_header Server; proxy_connect_timeout 3s; proxy_read_timeout 10s; &#125;&#125;[program:hexo]command=sudo /home/hexo/.build/release/Run serve --env=productiondirectory=/home/ubuntu/Helloautorestart=falseuser=rootstdout_logfile=/var/log/supervisor/%(program_name)-stdout.logstderr_logfile=/var/log/supervisor/%(program_name)-stderr.log第三步 执行sudo ln -s /etc/nginx/sites-available/api.你的域名.com /etc/nginx/sites-enabled/api.你的域名.comsudo ln -s /etc/nginx/sites-available/hexo.com /etc/nginx/sites-enabled/hexo.com第四步，执行以下2个命令sudo service nginx startsudo service nginx reloadsudo ln -s /etc/nginx/sites-available/api.liangdahong.com /etc/nginx/sites-enabled/api.liangdahong.comsudo ln -s /etc/nginx/sites-available/hexo.com /etc/nginx/sites-enabled/hexo.com第四步，执行以下2个命令sudo service nginx startsudo service nginx reloadsudo ln -s /etc/nginx/sites-available/blog.liangdahong.com /etc/nginx/sites-enabled/blog.liangdahong.com mac -&gt; linux https://blog.csdn.net/m82_a1/article/details/97624965 使用 id_rsa.pub /home/ubuntu/.ssh/authorized_keys scp /Users/Mac/Desktop/1/He.java ubuntu@123.207.253.160:/home/ubuntu/ scp /Users/bluemoon/Desktop/未命名文件夹/操作.jpeg ubuntu@123.207.253.160:/home/ubuntu/ 注意腾讯的是 ubuntu 不是 root ssh 登录到ubuntu ssh ubuntu@123.207.253.160]]></content>
  </entry>
  <entry>
    <title><![CDATA[Swift Codable]]></title>
    <url>%2F2019%2F11%2F08%2F00-%E6%8A%80%E6%9C%AF-iOS%2FSwift-Codable%2F</url>
    <content type="text"><![CDATA[基本使用 12345678910111213141516171819202122232425// 基本使用func a1() &#123; // 我们有模型如下 // 要使用 Codable 需要模型遵守 Codable 协议 struct User: Codable &#123; var userId: Int? var name: String? var height: CGFloat? &#125; let jsonString = """ &#123; "userId": 1, "name": "Jack", "height": 1.7, &#125; """ let decoder = JSONDecoder() if let data = jsonString.data(using: String.Encoding.utf8) &#123; if let user = try? decoder.decode(User.self, from: data) &#123; print(user) &#125; &#125;&#125; jsonString -&gt; data12// jsonString -&gt; data_ = "&#123;&#125;".data(using: String.Encoding.utf8) Dictionary -&gt; data12345678910// dict -&gt; data let jsonDic = [ "userId": 1, "name": "Jack", "height": 1.7, ] as [String : Any] guard JSONSerialization.isValidJSONObject(jsonDic) else &#123; return &#125; _ = try? JSONSerialization.data(withJSONObject: jsonDic, options:[]) data -&gt; Dictionary123456789101112131415let jsonDic = [ "userId": 1, "name": "Jack", "height": 1.7, ] as [String : Any]// dict -&gt; dataif let data = try? JSONSerialization.data(withJSONObject: jsonDic, options:[]) &#123; // data -&gt; dict // json 解析 if let dic = try? JSONSerialization.jsonObject(with: data, options: []) &#123; print(dic) &#125;&#125; Key替换12345678910111213141516171819202122232425262728func a2() &#123; struct User: Codable &#123; var userId: Int? var desc: String? // 模型的 Key : 服务器返回 Key enum CodingKeys: String, CodingKey &#123; case userId case desc = "description" &#125; &#125; let jsonString = """ &#123; "userId": 1, "description": "Jack", &#125; """ let decoder = JSONDecoder() if let data = jsonString.data(using: String.Encoding.utf8) &#123; if let user = try? decoder.decode(User.self, from: data) &#123; print(user) &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Swift学习笔记]]></title>
    <url>%2F2019%2F10%2F22%2F00-%E6%8A%80%E6%9C%AF-iOS%2FSwift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Array 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258// repeating 重复var threeDoubles = Array(repeating: 0.0, count: 3)// +=threeDoubles+=threeDoubles;threeDoubles.append(10.0)threeDoubles.append(contentsOf: [1,1,1,1])threeDoubles.insert(1.0, at: 0)threeDoubles.insert(contentsOf: [10.0], at: 0)var chars: [Character] = ["a"]chars.insert(contentsOf: "heii", at: 0)var cc = ""cc.insert(contentsOf: "cc", at: "".startIndex)cc.insert("c", at: "".startIndex)let c11: Character = "a"var arr = Array(1...100)arr.remove(at: 0)arr.removeFirst()// 从头开始删除xxx个objarr.removeFirst(1)// 从尾开始删除xxx个objarr.removeLast(1)arr.removeSubrange(1...2)// 删除最后一个objarr.popLast()// 删除obj 是否保留容量arr.removeAll(keepingCapacity: false)// 特殊初始化var numbers = Array(1..&lt;7)var numbers1 = [Int](1..&lt;7)[Int]([2222:"",222:""].keys)[Int]([2222:"",222:""].keys)Array([2222:"",222:""].keys)let a = [Character]("abccc")let a1 = Array&lt;Character&gt;("abccc")let a2 = Array("abccc")// 块替换// 把 4 5 6 这部分换为 [100, 200] 会操作数组的个数// [100,200,4,5,6,7,8]var arr1 = [1,2,3,4,5,6,7,8]arr1[0...2] = [100, 200]// for-infor _ in ["1", "2"] &#123;&#125;for (_, _) in ["1", "2"].enumerated() &#123;&#125;for _ in 1...2 &#123;&#125;for _ in 1..&lt;2 &#123;&#125;// 倒序for item in [1,2,10].reversed() &#123; print(item)&#125;// 跳动循环// 2 4 6 8 10 12for _ in stride(from: 2, through: 12, by: 2) &#123;&#125;// forEach 和 oc enum差不多 不可以使用 break 和 comm来控制循环// 原理和oc的enum遍历类似 return 只可以退出此次循环[""].forEach &#123; (item) in&#125;// enumerated// reversed 倒序for (_, _) in ["1"].enumerated().reversed() &#123;&#125;// 迭代器var makeIterator = [Int](2...20).makeIterator()while let num = makeIterator.next() &#123; print(num)&#125;[1].startIndex[1].endIndex[1].count// indices 来遍历 arr 的索引区间进行遍历for i in ([Character]("abc")).indices &#123; print(i)&#125;let rang1 = ([Character]("abc")).indiceslet rang2 = (1...2)// arr 是否包含 obj// [1].contains(&lt;#T##element: Int##Int#&gt;)// 遍历数组中是否包含指定obj 但具体是否包含是自己实现的let c = [1,100,200].contains &#123; (num) -&gt; Bool in print("==\(num)") if num == 111 &#123; return true &#125; return false&#125;[1,100,200].contains &#123; (num) -&gt; Bool in return false&#125;// 是否全部obj 满足xx条件[1].allSatisfy &#123; (num) -&gt; Bool in return false&#125;// 简写 $0[1].allSatisfy(&#123;$0 &gt; 10&#125;)// 获取第一个obj[1].first// 获取第一个满足xxx条件的obj[1].first &#123; (num) -&gt; Bool in return false&#125;// 在数组中第一个为aa 的元素的位置[""].firstIndex(of: "aa")// 获取第一个满足xxx条件的obj的index[1].firstIndex &#123; (num) -&gt; Bool in return false&#125;// 同理[1].last// min max[1].min()[1].min &#123; (num, num2) -&gt; Bool in return false&#125;[1].min &#123;$0 &gt; $1&#125;[1].max()[1].max &#123; (n1, n2) -&gt; Bool in return false&#125;// ArraySlice arr切片 和 Substring 类似，共享内存// drop 踢出xxx 返回一个 new 的 ArraySlicelet arrs = [1,2,3,4,4,5][1...2]// 踢出第一个 得到第1个到最后一个的 ArraySlice（切片Arr）[1].dropFirst()// 踢最后一个 得到的arr[1].dropLast()// 从后面开始踢几个 得到的arr[1].dropLast(1)// 从前面开始踢几个 得到的arr[1].dropFirst(1)// 踢出满足条件的obj 得到的arr[1].drop &#123; (num) -&gt; Bool in return false&#125;// 获取数组前面的obj xxx个[1].prefix(1)// 获取数组前面的obj 到xxx位置 不包括xxx位置，1=表示到索引0 和prefix(1)结果一样[1].prefix(upTo: 0)// 获取数组前面的obj 到xxx位置 包括xxx位置，1=表示到索引1[1].prefix(through: 0)// 从前面开始获取满足条件的 obj 到y第一个不满足就停止[1].prefix &#123; (num) -&gt; Bool in return false&#125;// 取最后的固定长度[1].suffix(1)// 从指定索引xxx到结束 （包含指定索引）[1].suffix(from: 0)// rang[11,1,1,1,1][1...2][1,1,1,1,1][...][11,1,1,1,1][1..&lt;2]let a111 = Array([1][...])let a112 = [1][...]// 重排操作// 随机打乱 arr 顺序var shuffleArr = [1]shuffleArr.shuffle()// 随机打乱数组顺序 同时返回 原arr不改变[1,1,1,1,1,1].shuffled()// 逆序// 把 arr 逆序 修改原arrshuffleArr.reverse()// 把 arr 逆序 不改原arr[1].reversed()// 分组 partition// 把 arr 由xxx条件分组，系统会自动把满足条件的 放在前面，不满足的放在后面// 返回分割点的 index// 系统不保障obj之间的顺序 顺序快一点打乱 主要是把满足条件在z前面就行shuffleArr.partition &#123; (num) -&gt; Bool in return false&#125;// 排序shuffleArr.sort()shuffleArr.sorted()shuffleArr.sort &#123; (n1, n2) -&gt; Bool in return false&#125;shuffleArr.sorted &#123; (n1, n2) -&gt; Bool in return false&#125;// 交换shuffleArr.swapAt(0, 0)// 字符串数组拼接// 把字符串数组直接拼接起来["zzz","a"].joined()// 把字符串数组用 xxx 拼接起来["zzz","a"].joined(separator: ",")// Sequence 序列性质的数组也可以拼接for item in [1...2, 10...20].joined(separator: 2...3) &#123; // 1 2 10 ... 20 print(item)&#125;for item in [[1,2],[222,222222]].joined(separator: [1,2]) &#123; print(item)&#125;// arr 的底层实现//Sequence;//Collection;//RangeReplaceableCollection;//Array;// 使用 arr 实现 Stackstruct Stack&lt;T&gt;&#123; private var es = [T]() var count: Int &#123; return es.count &#125; var isEmpty: Bool &#123; return es.isEmpty &#125; func pop() -&gt; T? &#123; return es.last &#125;&#125; Set 123456789101112131415161718192021222324252627282930313233343536373839404142// set 中的 obj 必须是可哈希的就和 dict的key一样必须可以哈希// 可哈希才可以判断是否已经存在// 默认系统值类型都是可以哈希的// 自定义类型可以实现哈希即可let set1 = Set&lt;String&gt;()var set2: Set&lt;String&gt; = ["a"]set2.insert("cc")for _ in set2 &#123;&#125;for _ in set2.sorted() &#123;&#125;// 由set-&gt;arr//set2.sorted(by: &lt;#T##(String, String) throws -&gt; Bool#&gt;)//set2.sorted()//set2.isEmpty//set2.count// 插入//set2.insert(&lt;#T##newMember: Hashable##Hashable#&gt;)// 更新obj 哈希一样时就更新 没有时就增加//set2.update(with: "bb")print(set2)set2.update(with: "aaaaaa")print(set2)// 过滤// 得到一个新的 set 是满足条件的 objset2.filter &#123; (num) -&gt; Bool in return false&#125;// 得到一个新的 arr 是满足条件的 objset2.filter &#123; (num) -&gt; Bool in return false&#125;// 暂未理解这个//set2.remove(at: &lt;#T##Set&lt;String&gt;.Index#&gt;)// 算法 获取 set 的所有子集// 底层实现 Dictionary12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273Dictionary&lt;String, Int&gt;()[String: Int]()let dic: Dictionary&lt;String, Int&gt; = [:]var dic1: [String: Any] = ["aaaaa": 100, "a": ""]["": 1].count["": 1].isEmptyfor (k, v) in ["": 1] &#123;&#125;for k in ["": 1].keys &#123;&#125;for k in ["": 1].values &#123;&#125;for k in ["": 1].values.sorted() &#123;&#125;// 其他和arr的操作类似var dict1 = [String: Int?]()// add objdict1["a"] = 100// 移除objdict1["a"] = nil// 更新或者添加objdict1.updateValue(100, forKey: "a")dic1.remove(at: dic1.startIndex)do &#123; // merge 把一个dic合并到另一个dic中去 var dict1 = ["a": 10] // dic 把后面的 dic合并到前一个dict中，同key时使用条件来控制 // b1 是前一个dic // b1 是后一个dic dict1.merge(["a": 1]) &#123; (b1, b2) -&gt; Int in return b1 &#125; print(dict1) // merging 把2个dic合并 得到一个新 dic do&#123; let dict1 = ["a": 10] let dic = dict1.merging(["a": 1]) &#123; (b1, b2) -&gt; Int in return b1 &#125; print(dic) &#125; do &#123; // 字典位置暂时无考虑 // firstIndex &#125; // KeyValuePairs // 一种特殊的dic，拥有顺序，理解为是有顺序的 dict do&#123; let dic = KeyValuePairs&lt;String, Int&gt;() print(dic) let dic1: KeyValuePairs = ["a": 100,"b": 100] print("KeyValuePairs") print(dic1) do &#123; let dic1: Dictionary = ["a": 100,"b": 100] print("Dictionary") print(dic1) &#125; &#125;&#125; String Substring String.Index123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111let str = "a"var str1 = "a"var str2 = """ abcd abcd """var str3 = """ abcd\ abcd """var str4 = "a*a\(77*2)"str1+=""str1 = "1"+"1"str1 == str2// String.Index// 取下标不可以用 endIndex"abc".startIndex"abc".endIndex"abc"["abc".startIndex]"abc"["abc".index(before: "abc".endIndex)]"abc"["abc".index(after: "abc".startIndex)]"abc".index("abc".startIndex, offsetBy: 1)// Substring"abc".startIndex..&lt;"abc".endIndex"abc"["abc".startIndex..&lt;"abc".startIndex]"abc"["abc".startIndex..&lt;"abc".endIndex]// 从前面开始取2个长度"abc".prefix(2)// 从前面开始取到指定位置"abc".prefix(upTo: "abc".index(after: "abc".startIndex))// 是否为这个前缀"abc".hasPrefix("abc")// 取后面的x位"abc".suffix(2)// 从x位置开始取"abc".suffix(from: "abc".startIndex)"abc".hasSuffix("abc")// 字符串分割for item in "a b c".split(separator: " ") &#123; let str = String(item) print(str)&#125;// 为 String 增加功能import Foundationextension String &#123; // 获取从开头开始到指定xxx位置的字符串 func subString(to index: Int) -&gt; String &#123; return self[0..&lt;index] &#125; // 获取从xxx位置开始到结束的字符串 func subString(from index: Int) -&gt; String &#123; return self[index..&lt;self.count] &#125; // 获取指定范围的字符串 subscript (r: Range&lt;Int&gt;) -&gt; String &#123; let start = self.index(self.startIndex, offsetBy: r.lowerBound, limitedBy: self.endIndex) ?? self.endIndex let end = self.index(self.startIndex, offsetBy: r.upperBound, limitedBy: self.endIndex) ?? self.endIndex return String(self[start..&lt;end]) &#125; // 获取指定位置的字符串 subscript (n: Int) -&gt; String &#123; return self[n..&lt;n+1] &#125; // 获取指字符串在字符串中的范围 subscript (str: String) -&gt; Range&lt;Index&gt;? &#123; return self.range(of: str) &#125;&#125;// String 的一个扩展extension String &#123; func subString(to index: Int) -&gt; String &#123; return String(self[..&lt;self.index(self.startIndex, offsetBy: index)]) &#125; func subString(from index: Int) -&gt; String &#123; return String(self[self.index(self.startIndex, offsetBy: index)...]) &#125; subscript (r: Range&lt;Int&gt;) -&gt; String &#123; let start = self.index(self.startIndex, offsetBy: r.lowerBound, limitedBy: self.endIndex) ?? self.endIndex let end = self.index(self.startIndex, offsetBy: r.upperBound, limitedBy: self.endIndex) ?? self.endIndex return String(self[start..&lt;end]) &#125; subscript (n:Int) -&gt; String &#123; return self[n..&lt;n+1] &#125; subscript (str:String) -&gt; Range&lt;Index&gt;? &#123; return self.range(of: str) &#125;&#125; 运算符123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188// 运算符let a = false!avar num = 10-num+numnum+=1num-=1num*=1num/=1num &gt; 1 ? "num&gt;1" : "num&lt;=1"// 可以溢出运算，循环运算// &amp;+// &amp;-// &amp;*// 0UInt8.max&amp;+1// 1UInt8.max&amp;+2// 255UInt8.min&amp;-1// 254UInt8.min&amp;-2UInt8.min&amp;*1UInt8.min&amp;*2// 合并空值运算符// ?? 如果有值就使用它的值，不然就使用默认值var num1: String? = String()num1 = nilnum1 ?? "abc"(num1 != nil) ? num1 : "abc"func addTwoNum(num1: Int?, num2: Int?) -&gt; Int &#123; return (num1 ?? 0) + (num2 ?? 0)&#125;// 区间运算符0...100..&lt;10for _ in [1,2,3,4][..&lt;2] &#123;&#125;for _ in [1,2,3,4][...2] &#123;&#125;for _ in [1,2,3,4][0...] &#123;&#125;let rang = ...10// 是否包含指定数字rang.contains(10)rang.contains(11)rang.contains(-1)rang.contains(-1000)for item in [1,2,10].reversed() &#123; print(item)&#125;for item in (1..&lt;6).reversed() &#123; print(item)&#125;// true("a"..."z").contains("a")// false("a"..."z").contains("-")// 位运算// ~ 取反运算符// 把数据的二进制位全部取反 1-&gt;0 0-&gt;1let num5 = 10~num5// 与运算符 对二进制操作 一假即假// 1&amp;1 = 1// 0&amp;1 = 0// 1&amp;0 = 0// 0&amp;0 = 01&amp;1// 或运算符 对二进制操作 一真即真// 1&amp;1 = 1// 0&amp;1 = 1// 1&amp;0 = 1// 0&amp;0 = 01|1// 位异或 互斥或 （对二进制操作 同假异真）//1^1// 无符号的左移 右移// 左移 右移 运算符 &lt;&lt; &gt;&gt;// 全部二进制向左或者右移x位，超出的丢掉，空出来的补0// 减半和加倍算法// 有符号的左移 右移操作暂时未展开// 寻找成对的无符号数丢失的数可以使用 ^ 来处理// 这里可以对一些特殊的算法使用 ^ 来快捷处理。// 运算符重载// 类和结构体可以为现在的运算符提供其他的实现方式// 如：向量的加法，我们可以使用自定义的结构体同时配合 + （加法）来处理// 如：class d也可以定义一些特殊的类型来，做类似的 + （加法）运算struct Vector2D &#123; var x = 0.0 var y = 0.0&#125;extension Vector2D &#123; // 双目运算符 // 给结构体处理了 + 运算 （双目运算符） static func +(right: Vector2D, left: Vector2D) -&gt; Vector2D &#123; return Vector2D.init(x: 1, y: 1) &#125; // += 需要 inout 来处理可以修改 static func +=(right: inout Vector2D, left: Vector2D) -&gt; Vector2D &#123; return Vector2D.init(x: 1, y: 1) &#125; // 单目运算符 // 单目运算符 prefix 或者 postfix 前缀来修饰 static prefix func !(right: Vector2D) -&gt; Vector2D &#123; return Vector2D.init(x: 1, y: 1) &#125; static postfix func -(right: Vector2D) -&gt; Vector2D &#123; return Vector2D.init(x: 1, y: 1) &#125;&#125;var v = Vector2D.init(x: 1, y: 1)let c = v + v!vv+=v// 等价运算符 在类和结构体默认是不支持系统的等价运算符的 ==// 所以必须要自己重载才可以使用// 要配合 Equatable 来使用才可以extension Vector2D: Equatable &#123; static func ==(right: Vector2D, left: Vector2D) -&gt; Vector2D &#123; return false &#125;&#125;v==v// Swift 为自定义的如下类型实现了 == 等价运算符// 1.遵循了 Equatable 协议，而且只有存储属性结构体// 1.1 自定义处理的方式struct Vector2D &#123; var x = 0.0, y = 0.0&#125;extension Vector2D : Equatable &#123; static func == (left: Vector2D, right: Vector2D) -&gt; Bool &#123; return false &#125;&#125;Vector2D() == Vector2D()// 1.2 系统自动实现了 等价运算符struct Vector3D : Equatable &#123; var x = 0.0, y = 0.0, z = 0.0&#125;Vector3D() == Vector3D()// 2.遵循了 Equatable 协议，关联类型的enum// 3.没有关联类型的enum// 自定义运算符// 暂时未展开 循环控制 for-in repeat-while123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138// 循环控制 for-in repeat-while// 遍历序列for _ in 0...10 &#123;&#125;// 遍历数组for _ in [1,2,3,4,5] &#123;&#125;// 遍历字符串for _ in "abc" &#123;&#125;// 遍历字典for item in [1:1] &#123; print(item.key) print(item.value)&#125;for (key, v) in ["a" : 1] &#123;&#125;for (idx, obj) in [1,2,10].enumerated() &#123;&#125;for _ in stride(from: 2, through: 12, by: 2) &#123;&#125;for _ in stride(from: 2, to: 12, by: 2) &#123;&#125;repeat &#123;&#125;while falsewhile false &#123;&#125;// switch swift中switchs默认有 break 功能 而且必须写满全部条件let c = "a"switch c &#123;case "a": print("a")case "b": print("b") breakdefault: print("other")&#125;// 复合匹配switch "a" &#123;case "a", "A": print("a A")default: print("other")&#125;// 区间switch 1 &#123;case 0...2: print("0...3")default: print("other")&#125;// 元祖处理 (_ 表示此项不比较)var point = (10,20)switch point &#123;case (0,0): print("(0,0)")case:(_,0) print("(_,0)")case:(0,_) print("(_,0)")case:(0...2,0..&lt;100) print("(_,0)")default: print("other")&#125;// 还可以临时变量var point1 = (10,20)switch point1 &#123;case (0,0): print("(0,0)")case:(let x,0) print("(_,0)")case:(0,let y) print("(_,0)")case:(0...2,0..&lt;100) print("(_,0)")default: print("other")&#125;// 配合 where 来处理 特殊条件var point3 = (10,20)switch point3 &#123;case (x,y) where x == y: print("x == y")case:(let x,0) print("(_,0)")case:(0,let y) print("(_,0)")case:(0...2,0..&lt;100) print("(_,0)")default: print("other")&#125;// continue 停止这次循环// break 结束 for-in while switch 等// break 在 Swift中是为了理解结束switch 在oc中是为了防止贯穿// fallthrough 强制到下一个 case，同时下面是否继续贯穿要看下一个 case 是否有 fallthroughswitch 2 &#123;case 1: print("1") fallthroughcase 2: print("2") fallthroughdefault: print("other")&#125;// 标签let num = 10wile : while num &gt; 9 &#123; switch 1 &#123; case 1: print("===1") // break 强制处理指定标签 强制退出了 少使用为妙。 break wile fallthrough default: print("other1") &#125;&#125; #if if-let guard-else guard-let-else 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 1.if// 2.if-let 在 if 的基础上优化了// 3.guard-else 不成立就进去，黄金大道。// 4.guard-let-else 任何一个不成立就进去，黄金大道。func cc(_ flag: Bool, count: Int?) -&gt; Bool &#123; do &#123; let name: String? = "老王" let age: Int? = 10 if name != nil &amp;&amp; age != nil &#123; print(name! + String(age!)) // 输出:老王10 &#125; &#125; do &#123; let name: String? = "老王" let age: Int? = 10 // nameNew ageNew 一定是非 nil 的 if let nameNew = name, let ageNew = age &#123; // 进入分支后,nameNew 和 ageNew 一定有值 print(nameNew + String(ageNew)) // 输出:老王10 &#125; &#125; // 强制类型转换do&#123; var name: String? = "" name = nil var name1: String? = "" name1 = nil if let n = name, let n2 = name1, false == true &#123; print(n.count + n2.count) &#125; if let n = name1 as? Array&lt;Any&gt; &#123; print(n) &#125; guard flag else &#123; print("fa") return false &#125;&#125; do &#123; let name: String? = "老王" let age: Int? = 10 // guard let nameNew = name, let ageNew = age else &#123; print("姓名 或 年龄 为nil") return false &#125; print(nameNew + String(ageNew)) // 输出:老王10 &#125; guard let _ = count, count ?? 10&gt;10, flag == false else &#123; return false &#125; return true&#125;func cc1(_ flag: Bool, count: Int?) -&gt; Bool &#123; // 如果不成立就进去。 // 任何一个不成立都进去，如果有nilj也是不成立。 guard let a = count, a &gt; 10, flag == false else &#123; print("不成立") return false &#125; return true&#125;cc1(false, count: nil)// 在代码上来控制我们尽量使用黄金大道，不满足条件就尽快返回// Apple 让我们的真正的代码尽量不要写在 if else 中 模式和模式匹配 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 模式和模式匹配// 模式: 是一个值和复合值的结构// 通配符模式// _for _ in 1...100 &#123;&#125;// 标识符模式let A = 100// 值绑定模式let po = (10,10)switch po &#123;case let (x,y): print("x - y")default: print("default")&#125;// 元组模式let pos = [(1,2),(1,0)]// 匹配到 y = 0 的元组for (x,y) in pos where y == 0 &#123; print("aaa")&#125;// enum 模式 参考enum的内容// 可选值模式 31-xxx//let someNum: Int = 10//if case let x? = someNum &#123;// print("ssss")//&#125;// 类型转换模式 31-xxx// is Dog 遍历多中类型的数组 使用 swiftch 来匹配出具体的类型// 表达式模式let po1 = (1,2)switch po1 &#123;case (0,0): print("")case (1...2,0...2): print("")default: print("")&#125;// 可以配合运算符重载来做一些特殊的匹配struct Employee &#123; var salaey: Float&#125;// 运算符重载extension Employee &#123; static func ~=(lhs: Range&lt;Float&gt;, rhs: Employee) -&gt; Bool &#123; return lhs.contains(rhs.salaey) &#125;&#125;let e = Employee.init(salaey: 100000)switch e &#123;case 0..&lt;1000: print("收入在 0.0...1000")default: print("其他")&#125; 函数 func12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758do &#123; func greet(_ personName: String) -&gt; String &#123; return "hi \(personName)" &#125; greet("li")&#125;do &#123; func greet(personName: String) -&gt; String &#123; return "hi \(personName)" &#125; greet(personName: "li") // 隐试返回值 do &#123;// func fun1(name: String) -&gt; String &#123;// "a" + name// &#125; &#125; // 默认值 do &#123; func greet11(personName: String? = "") -&gt; String &#123; return "" &#125; &#125; // 可变参数个数 do &#123; // func greet2222(n: Int?...) -&gt; String &#123; return "" &#125; &#125;&#125;// 函数类型func addTwoNum(_ n1: Int, _ n2: Int) -&gt; Int &#123; return n1+n2&#125;let mathFunc: ((Int, Int)-&gt;Int) = addTwoNum// 函数做为参数来处理func printMath(_ funccc: (Int,Int)-&gt;Int ) &#123; funccc(1,2)&#125;printMath(addTwoNum)//内嵌函数do&#123; func printMath1(_ funccc: (Int,Int)-&gt;Int ) -&gt; ((Int,Int)-&gt;Int) &#123; func addTwoNum1111(_ n1: Int, _ n2: Int) -&gt; Int &#123; return n1+n2 &#125; return addTwoNum1111 &#125;&#125; 闭包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156func paix(n1: Int, n2: Int) -&gt;Bool &#123; return n1&gt;n2&#125;[1,222,3].sorted(by: paix)// 闭包表达式// &#123; (n1: Int, n2: Int) -&gt; Bool in// return false// &#125;[1,222,3].sorted (by: &#123; (n1: Int, n2: Int) -&gt; Bool in return n1&gt;n2&#125;)[1,222,3].sorted &#123; (n1, n2) -&gt; Bool in n1&gt;n2&#125;[1,222,3].sorted &#123; n1, n2 in return n1&gt;n2&#125;// 单一个表达式 可以直接不加[1,222,3].sorted &#123; n1, n2 in n1&gt;n2&#125;// $0 第一个参数[1,222,3].sorted &#123; $0 &gt; $1&#125;// 直接符号[1,222,3].sorted(by: &lt;)// 尾随闭包: 如果最后阳光城参数是闭包时，我们可以直接把// 尾随闭包 把 （） 已放弃掉叫尾随闭包[1,222,3].sorted&#123;$0&gt;$1&#125;func sorted111(n: Int, by areInIncreasingOrder: (Int, Int) -&gt; Bool) -&gt; [Int] &#123; return [1]&#125;sorted111(n: 10) &#123; (n, n1) -&gt; Bool in return false&#125;sorted111(n: 10, by: &#123; (n, n1) -&gt; Bool in return false&#125;)[1].sorted(by: &#123;(n1,n2) -&gt; Bool in return false&#125;)// 如何捕获值// 逃逸闭包: 传给函数的闭包 可能没有在函数中调用，而且其他地方调用，表示这个闭包逃逸了。// 当func传入的闭包会在func返回后调用时// 或者传进的闭包会存储到外面的arr中// 网络请求：函数立即返回 但是 闭包等一下才会真正的调用do &#123; func paix(n1: Int, n2: Int) -&gt; Int &#123; return 1 &#125; // @escaping func test(bl: @escaping ((Int, Int)-&gt;Int)) -&gt; (Int, Int)-&gt;Int &#123; return bl &#125; test(bl: paix); test(bl: paix)&#125;// 逃逸闭包在获取属性的时候需使用 selfclass BMPerson &#123; var x = 10 func testclosure1(closure: @escaping (()-&gt;())) -&gt; (()-&gt;()) &#123; return closure &#125; func testclosure2(closure: (()-&gt;())) &#123; &#125; func test1() &#123; // 逃逸 testclosure1 &#123; self.x = 10 &#125; // 非逃逸 testclosure2 &#123; x = 10 &#125; &#125;&#125;// 自动闭包: 是一种不接受任何参数的闭包，同时他会自动打包表达式，同时返回表达式的值// 自动闭包可以延时处理var arr = [1,2]// 闭包表达式let c = &#123; arr.removeAll()&#125;print("==")c()print("--")do &#123; // 闭包表达式 // 定义一个闭包为 c1111 let c1111 = &#123; (a: Int) -&gt; Int in print("\(a) + aaaaa") return a &#125; print(c1111(2222)) do &#123; // 闭包表达式 &#123; (a: Int) -&gt; Int in print("\(a) + aaaaa") return a &#125;(9999) &#125;&#125;do&#123; func test1(closure1: @autoclosure ()-&gt;Bool) &#123; &#125; test1(closure1: 1&gt;1)&#125;// 这样的函数的 closure1 满足自动闭包的条件我们尝试使用自动闭包来处理func test1(closure1: ()-&gt;Bool) &#123;&#125;test1 &#123; () -&gt; Bool in return false&#125;// 更加简洁// 自动+逃逸func test2(closure1: @escaping @autoclosure ()-&gt;Bool) -&gt; ()-&gt;Bool &#123; return closure1&#125;test2(closure1: arr.count &gt; 10)() Swift 高阶函数map filter reduce flatMap compactMap1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// map// 对于原始集合里的每一个元素，以一个变换后的元素替换之形成- -个新的集合print([3].map &#123; (num) -&gt; Int in return num*num&#125;)let ccc = [2].map &#123; (num) -&gt; String in return "\(num)"&#125;// filter 条件处理// 对于原始集合里的每一-个元素，通过判定来将其丢弃或者放进新集合print(Array(1...20).filter &#123; $0 &lt; 10 // 满足条件的放到新的set中&#125;)// reduce// 对于原始集合里的每一个元素，作用于当前累积的结果上// 累积 累加// 原始值 count加得到的值 n取到的值// Result 结果print(Array(19...20).reduce(10) &#123; (count, n) -&gt; Int in return count+n&#125;)// flatMap// 对于元素是集合的集合，可以得到单级的集合do &#123; let arr = [[1,2],[3,4]] print(arr.flatMap &#123; (nums) -&gt; [Int] in return nums.map(&#123; (num) -&gt; Int in return num*10 &#125;) &#125;) // 进一步简化 print(arr.flatMap &#123;$0.map&#123;$0*10&#125;&#125;)&#125;// compactMap// 过滤空值do &#123; // 如果是非空就加进去 // 这里返回的是 String？ 所以是一个 String 数组 print(["a",nil,"aaa"].compactMap &#123; (str) -&gt; String? in str &#125;) // 如果是非空就加进去 // 这里返回的是 str?.count 所以是一个Int print(["a",nil,"aaa"].compactMap &#123; (str) -&gt; Int? in str?.count &#125;) print(["a",nil,"aaa"].compactMap &#123; $0?.count&#125;)&#125; 函数式编程1234具有普遍意义的基本构造单元●筛选(filter)●映射(map)●折叠/化约(foldL eft/reduce等) enum12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182enum ABC : CaseIterable&#123; case A,B,C&#125;let c = ABC.Aswitch c &#123;case .A: print("a")case .B: print("a")case .C: print("a")&#125;for item in ABC.allCases &#123; print(item)&#125;// 关联值enum Barcode &#123; case upc(Int,Int,Int,Int) case qrCode(String)&#125;let code = Barcode.qrCode("ldh")switch code &#123;case let .upc(n1, _, _, _): print(n1)case .qrCode(let str): print(str)&#125;// 默认值do &#123; enum ASci : Character &#123; case tab1 = "a" case tab2 = "b" &#125; let as1 = ASci.init(rawValue: "a") print(as1 ?? "aaa") _ = ASci.tab1&#125;// 如果是 Int 或者字符串的时候系统自动设置enum Planet: Int &#123; case a = 1,b&#125;// a = 1;// b = 2;// 默认取名字为它的名字enum ConPassPoint : String &#123; case a&#125;// 使用 “aaaaaaa” 是无法初始化成功的 所以是 nilif let aaa = ConPassPoint.init(rawValue: "aaaaaaa") &#123; print(aaa)&#125; else &#123; print("nilll")&#125;// 递归enum// 递归枚举是拥有另一个枚举作为枚举成员关联值的枚举。当编译器操作递归枚举时必须插入间// 接寻址层。你可以在声明枚举成员之前使用indirect关键字来明确它是递归的。// 如说表达式(5+4)* 2在乘法右侧有一个数但有其他表达式在乘法的左侧。//indirect enum Ari thmeticExpression [//case//number(Int)//case//addition ( ArithmeticExpression, Ari thmeticExpression)//case multiplication (Ari thme ticExpression,//Arithmeti cExpression)//]//let five = ArithmeticExpression. number(5)//let four = Arithmetic Expres sion. number(4)//let sum = Ari thmeticExpression. addition(five, four)//let product = ArithmeticExpression. multiplication(sum,//Ari thmeticExpression. number(2)) class 结构体 enum 属性OOP 面向对象编程 继承 多态 封装 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 属性// 存储属性 lazy// 计算属性struct Rect &#123; // var &lt;#variable name#&gt;: &lt;#type#&gt; &#123; // get &#123; // &lt;#statements#&gt; // &#125; // set &#123; // &lt;#variable name#&gt; = newValue // &#125; // &#125; // var &lt;#variable name#&gt;: &lt;#type#&gt; &#123; // &lt;#statements#&gt; // &#125; // var &lt;#name#&gt; = &lt;#value#&gt; // lazy var &lt;#property name#&gt;: &lt;#type name#&gt; = &#123; // &lt;#statements#&gt; // return &lt;#value#&gt; // &#125;() // lazy var &lt;#variable name#&gt; = &lt;#expression#&gt;&#125;// 类型属性// ●使用static关键字来定义类型属性。// 对于类类型的计算类型属性，你可以使用class关键字来允许子类重写父类的实现。struct BMPerson &#123; var age = 10 static var cla = "" static var cla1: Int &#123; get &#123; return 1 &#125; set &#123; &#125; &#125;&#125;class BMPerson1 &#123; var age = 10 static var cla = "" class var cla1: Int &#123; get &#123; return 1 &#125; set &#123; &#125; &#125;&#125; 为 class 结构体 enum 添加方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//// 实例方法//// 1//// 在实例方法中、默认可以不写 self//// 在形参的名字和属性的名字相同的时候需要使用 self 来访问属性////// 2//// 在实例方法中想修改属性//// 在值类型【enum 结构体】 属性不可以被自己的实例方法修改//// 需在方法前面加 mutating mutating func mm()&#123;&#125;//// mutating 里面可以强制修改 self 属性 self是一个属性 指自己//// enum 中的 self 可以设置为其他的成员////enum BMType &#123;// case off,low,height//// mutating func next() &#123;// switch self &#123;// case .height:// self = .off// case .low:// self = .height// case .off:// self = .low// &#125;// &#125;//// // 如果是 class 的话 而且想在子类中重写这个方法可以把 static 换为 class。// static func aaa() &#123;// &#125;//&#125;////let type1 = BMType.off//type1.next()//type1.next()//BMType.aaa()//// // 3 为 class 结构体 enum 提供下标访问 arr[0]//////type1["a"]do&#123; struct BMTYpe1 &#123;// subscript(idnex: Int) -&gt; Int &#123;// return 11122// &#125; subscript(index: Int, col: Int) -&gt; Int &#123; get &#123; print(111) return 1 &#125; set &#123; print(newValue) &#125; &#125; // Xcode 11// static subscript(index: Int) -&gt; (Void) &#123;// get &#123;// return// &#125;// set&#123;//// &#125;// &#125; &#125;// var type = BMTYpe1.init()// print(type[1])// type[1] = 1&#125; 类 enum 结构体 的初始化和反初始化initdeinitclass 继承1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 便捷初始化器convenience// 必须要子类覆盖required// 不可以子类覆盖final// 此方法是由父类覆盖过来的overrideclass Vehicle &#123; var currentSpeed = 0 final var nnn = 10 var desc: String &#123; return "run at speed \(currentSpeed)" &#125; init(currentSpeed: Int) &#123; self.currentSpeed = currentSpeed &#125;&#125;class Car: Vehicle &#123; var gear: Int = 0// override var nnn: Int &#123;// get &#123;// return 1// &#125;// set &#123;// &#125;// &#125; override var desc: String &#123; return super.desc + "\(gear)" &#125; init(gear: Int) &#123; self.gear = gear super.init(currentSpeed: 10) &#125; init(currentSpeed: Int, gear: Int) &#123; self.gear = gear super.init(currentSpeed: currentSpeed) &#125; convenience init() &#123; self.init(currentSpeed: 10, gear: 10) &#125;&#125;let c = Car() 协议12345678910111213141516171819202122232425262728293031323334353637383940414243444546protocol VehicleProtocol &#123;// 属性 可读或者写 var age: Int &#123; get set &#125;&#125;// 协议组合，既然遵守协议1 已遵守协议2VehicleProtocol1 &amp; VehicleProtoco2// where// 给 Array 扩展，但前提条件是 Array 中的元素满足给定条件extension Array: VehicleProtocol where Element: VehicleProtocol &#123; var age: Int &#123; get &#123; return 1 &#125; set &#123; &#125; &#125;&#125;//可以给 Collection extension 方法 让所有遵守协议的类型都有了此方法，就可以直接调用了，默认 protocol 是没有方法实现的。extension Collection &#123; var age: Int &#123; get &#123; return 1 &#125; set &#123; &#125; &#125;&#125;// 给 遵守Collection协议的类型一个扩展，但必须满足指定条件，里面的 Element 遵守 VehicleProtocol 协议添加方法extension Collection where Iterator.Element: VehicleProtocol &#123; var age111: Int &#123; get &#123; return 1 &#125; set &#123; &#125; &#125;&#125;let arr = [Vehicle()]arr.age111 try throw catch https://www.jianshu.com/p/a227f97e6c2c 异常处理，比如你封装的一个函数，可能会有异常情况，需要通知外面的使用者，但又不想加参数等，就可以使用 错误处理来实现，当有异常时执行相关的操作。 外面定义一个函数 123456789101112131415161718192021222324252627282930313233// 定义函数的时候使用 throws 告诉编译器说这个函数可能会抛出异常func foo(a: Int) throws -&gt; Int &#123; if a &lt; -10 &#123; // 这里需要处理错误 // 需要使用 throw 把错误抛出 // 同时排除的必须是遵守 Error 协议的可以是 enum 结构体 class，通常是 enum 类型 // 我们定义 enum 如下 throw BMError.init() &#125; return a&#125;/// 定义一个枚举类型的错误类型enum BMError: Error &#123;&#125;// 调用可能抛出异常的函数// 强制认为不会抛出异常，如果抛出了会崩溃let ccc = try! foo(a: 10)// 可以抛出异常，但不处理它let ccc = try？ foo(a: 10)// 处理异常// 实现执行 do 中的代码，如果 try (注意没有加？或！) 抛出了异常就跳转到 catch 中// err 就是抛出的异常信息// do 中的 try? 和 try！ 和外面的 do-catch 没关系 do &#123; let ccc = try? foo(a: -100) let ccc = try? foo(a: -100) let ccc1 = try foo(a: -100) &#125; catch let err &#123; &#125; .Type 、self 、Self、type(of:)1234567891011121314151617181920212223242526272829303132333435// .Type 是类型的方法 [Int, NSObject], 返回的是此类型属于的类型，不是值。// Int.Type: 表示 Int 所属的类型。// NSObject.Type: 表示 NSObject 所属的类型，元类。// .self可以用在类型后面取得类型本身，也可以用在实例后面取得这个实例本身,返回的是值。// 1.self 表示 1// Int.self 表示 Int所属类型的值// NSObject.self 表示 NSObject的元类的值// ❌ types.append(Int.Type)// ✅ types.append(Int.self)// Self 用在协议中protocol MProtocolTest01 &#123; // 协议定一个方法，接受实现该协议的自身类型并返回一个同样的类型 func testMethod(c: Self) -&gt; Self //不能在协议中定义 范型 进行限制 //Self 不仅指代的是 实现该协议的类型本身，也包括了这个类型的子类&#125;class BMPerson: MProtocolTest01 &#123; func testMethod(c: BMPerson) -&gt; Self &#123; return self &#125;&#125;// type(of:) vs .self// 如果我们想获取一个实例的类型类似于 oc 的 class// self 是返回他自己// Type 又是类型的方法// 可以使用 type(of: num) 来获取实例的具体类型let num: Int = 1let type1 = type(of: num)// Intprint(type1) Any AnyObject AnyClass123// Any 任意类型 enum 结构体 class 元类型都可以// AnyObject 任意class对象实例 不包括元类型的实例// AnyClass 任意class类型 不包括元类型 as as? as!123456789101112131415161718192021222324// as// 子类 -&gt; 父类// let c2 = BMPPP1() as NSObject// switch 匹配// switch animal &#123;// case let cat as Cat:// print("如果是Cat类型对象，则做相应处理")// case let dog as Dog:// print("如果是Dog类型对象，则做相应处理")// default: break// &#125;// 常量转换let c = 1 as CGFloat// as? as!// 不同的类型转换// 如果失败的话为 nil ( as! 强制转换，失败就崩溃)// isprint(1 is Int)print(NSObject() is NSObject) 关联类型 更多内容未记录 1234567891011121314151617181920212223242526272829303132333435363738import Foundation// 关联类型protocol BMProtocol &#123;// associatedtype ItemTYpe where ItemTYpe : NSObject associatedtype ItemTYpe mutating func append(_ item: ItemTYpe) var count: Int &#123;get&#125; subscript(i: Int) -&gt; ItemTYpe &#123;get set&#125;&#125;struct BBB: BMProtocol &#123; func append(_ item: Int) &#123; &#125; var count: Int subscript(i: Int) -&gt; Int &#123; get &#123; return 1 &#125; set &#123; &#125; &#125; typealias ItemTYpe = Int&#125;protocol BMProtocol1 : BMProtocol &#123; // 特殊约束 associatedtype suffItem: BMProtocol1 where suffItem.ItemTYpe == ItemTYpe&#125;//struct BBB1: BMProtocol1 &#123;//////&#125; 泛型编程 更多内容待研究 多线程编程Thread1234567891011121314151617181920class ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() &#125; override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; for i in 0...20 &#123; Thread.detachNewThread &#123; print(i) &#125; &#125; let thread = Thread.init(target: self, selector: #selector(ss), object: nil) thread.start() &#125; @objc func ss() &#123; print("aa") &#125;&#125; Operation12345678910111213141516171819202122232425262728293031323334353637383940// BlockOperationclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() &#125; override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; let op = BlockOperation.init &#123; [weak self] in self?.ss() &#125; let qu = OperationQueue.init() qu.addOperation(op) &#125; func ss() &#123; print("aa") &#125;&#125; // 自定义Operationclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() &#125; override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; let op = BMOperation.init() let qu = OperationQueue.init() qu.addOperation(op) &#125;&#125;class BMOperation: Operation &#123; override func main() &#123; print("aa") &#125;&#125; GCD 和 oc 的 gcd 基本一致，只是改动了 api 的名字]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pthread、NSThread、GCD、NSOperation、NSOperationQueue]]></title>
    <url>%2F2019%2F10%2F12%2F00-%E6%8A%80%E6%9C%AF-iOS%2Fpthread%E3%80%81NSThread%E3%80%81GCD%E3%80%81NSOperation%E3%80%81NSOperationQueue%2F</url>
    <content type="text"><![CDATA[各种 队列&amp;同步&amp;同步 组合 https://naotu.baidu.com/file/fcc0f114a0116d1e4679d9327b3b5714 GCD https://www.jianshu.com/p/2d57c72016c6 NSOperation NSOperationQueue https://www.jianshu.com/p/4b1d77054b35 pthread、NSThread https://www.jianshu.com/p/cbaeea5368b1 pthread、NSThread https://www.jianshu.com/p/cbaeea5368b1 GCD基本介绍12345678910111213// 并发队列dispatch_queue_t queue_t = dispatch_queue_create(&quot;ccc&quot;, DISPATCH_QUEUE_CONCURRENT);// 串行队列dispatch_queue_t queue_t1 = dispatch_queue_create(&quot;ccc&quot;, DISPATCH_QUEUE_SERIAL);// 串行队列 (主队列)dispatch_get_main_queue();// 全局并发队列dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);// 同步dispatch_sync// 异步dispatch_async 线程通讯1234// gcd 线程通讯一般只有 子线程通讯到主线程，// 因为我们在处理gcd的时候没有操作具体的线程，// 全部是由系统来处理的dispatch_async(mainQueue, ^&#123; 延时操作12// 延时操作 这里只是延时把任务加到队列中,具体什么时候执行是未知的。// dispatch_after 只执行一次12// 只执行一次dispatch_once(&amp;onceToken, ^&#123; 快速迭代方法123// 快速迭代方法,普通遍历数组的时候是一个一个取，// 如果用快速迭代的话就可以在多个线程中同时（异步）遍历。dispatch_apply(6, queue, ^(size_t index) &#123; 栅栏1234567// 栅栏 可以把任务栅起来特殊处理，指定哪些任务完成后在执行哪些任务// 1 2 完成了再继续这些 3 4 5任务dispatch_async(queue, ^&#123;dispatch_async(queue, ^&#123;dispatch_barrier_async(queue, ^&#123;dispatch_async(queue, ^&#123;dispatch_async(queue, ^&#123; 队列组###通知方式 1234// 1 2 完成才通知 3dispatch_group_async(groudispatch_group_async(groudispatch_group_notify(grou 堵塞12345// 暂停方式 // 到3就暂停堵塞当前线程，当 1 2 完成后才解除暂停dispatch_group_async(groudispatch_group_async(groudispatch_group_wait(group, DISPATCH_TIME_FOREVER); 1234567891011121314151617### 标记的方式// 使用标记的方式// 标记开始一个，标记结束一个dispatch_group_enter(group);dispatch_async(queue, ^&#123;dispatch_group_leave(group);&#125;);dispatch_group_enter(group);dispatch_async(queue, ^&#123;dispatch_group_leave(group);&#125;);dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;&#125;); 信号量12345678910111213141516171819// 信号量 Dispatch Semaphore 线程同步，将异步执行任务转换为同步执行任务。Dispatch Semaphore 提供了三个方法：dispatch_semaphore_create：创建一个 Semaphore 并初始化信号的总量dispatch_semaphore_signal：发送一个信号，让信号总量加 1dispatch_semaphore_wait：可以使总信号量减 1，信号总量小于 0 时就会一直等待（阻塞所在线程），否则就可以正常执行。// 全局并发队列dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);// maphore 初始创建时计数为 0。dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);dispatch_async(queue, ^&#123;// 发送一个信号，让信号总量加 1dispatch_semaphore_signal(semaphore);&#125;);// 到这里让信号量减 1 、是-1 小于0 就开始等待，当信号量是0 或者大于1 时就继续执行dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);NSLog(@&quot;任务完成了&quot;); NSOperation、NSOperationQueue NSOperation、NSOperationQueue 是苹果提供给我们的一套多线程解决方案。实际上 NSOperation、NSOperationQueue 是基于 GCD 更高一层的封装，完全面向对象。但是比 GCD 更简单易用、代码可读性也更高。 为什么要使用 NSOperation、NSOperationQueue？ 可添加完成的代码块，在操作完成后执行。 设定操作执行的优先级。 可以很方便的取消一个操作的执行。 使用 KVO 观察对操作执行状态的更改：isExecuteing、isFinished、isCancelled。 创建操作NSOperation 的创建NSInvocationOperation12345// 在当前线程上执行// 1.创建 NSInvocationOperation 对象NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil];// 2.调用 start 方法开始执行操作[op start]; NSBlockOperation12345678910// 各种 Block 可以在多个线程上执行// 1.创建 NSBlockOperation 对象NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:// 2.添加额外的操作[op addExecutionBlock:[op addExecutionBlock:[op addExecutionBlock:[op addExecutionBlock:// 3.调用 start 方法开始执行操作[op start]; NSOperation 自定义12自定义 NSOperation 的方式暂时不考虑@interface YSCOperation : NSOperation NSOperationQueue 操作队列创建 Queue123456// 获取主队列[NSOperationQueue mainQueue];// 获取当前队列[NSOperationQueue currentQueue];// 创建自定义队列 （可以通过其他属性来确定是串行或者并发 maxConcurrentOperationCount）[[NSOperationQueue alloc] init]; 向 NSOperationQueue 中添加操作12345678910111213141516// 在 Queue 直接添加操作 不需要调用 NSOperation 的 start 方法 // 1.创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 2.创建操作// 使用 NSInvocationOperation 创建操作1NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123;[op3 addExecutionBlock: // 3.使用 addOperation: 添加所有操作到队列中[queue addOperation:op1];[queue addOperation:op2];[queue addOperation:op3]; 向 Queue 中直接加 Block 的方式123456// 1.创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 2.使用 addOperationWithBlock: 添加操作到队列中[queue addOperationWithBlock:[queue addOperationWithBlock:[queue addOperationWithBlock: 控制并发和串行 maxConcurrentOperationCount1234// 默认 -1 不控制// 1 串行// n 并发，但不会超过系统限制@property NSInteger maxConcurrentOperationCount; NSOperation 的依耐和优先级依耐 NSOperation 的一个特点就是可以添加各种操作依赖，同时还可以设置一下参数，取消，暂停，恢复等。 1234// 依赖确定了谁在前执行和谁在后执行。(a的执行需要b执行完毕，a依耐b)- (void)addDependency:(NSOperation *)op;- (void)removeDependency:(NSOperation *)op;@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 优先级12// 都处于就绪的状态的任务（操作），谁先开始执行，谁先取到。@property NSOperationQueuePriority queuePriority; 线程间的通信12345678910// 1.创建队列NSOperationQueue *queue = [[NSOperationQueue alloc]init];// 2.添加操作[queue addOperationWithBlock:^&#123; // 异步进行耗时操作 // 回到主线程 [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; &#125;]; &#125;]; 常用属性和方法归纳NSOperation1234567891011121314// 取消操作方法- (void)cancel; 可取消操作，实质是标记 isCancelled 状态。// 判断操作状态方法- (BOOL)isFinished; 判断操作是否已经结束。- (BOOL)isCancelled; 判断操作是否已经标记为取消。- (BOOL)isExecuting; 判断操作是否正在在运行。- (BOOL)isReady; 判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关。操作同步- (void)waitUntilFinished; 阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步。- (void)setCompletionBlock:(void (^)(void))block; completionBlock 会在当前操作执行完毕时执行 completionBlock。- (void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。- (void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。 NSOperationQueue1234567891011121314取消/暂停/恢复操作- (void)cancelAllOperations; 可以取消队列的所有操作。- (BOOL)isSuspended; 判断队列是否处于暂停状态。 YES 为暂停状态，NO 为恢复状态。- (void)setSuspended:(BOOL)b; 可设置操作的暂停和恢复，YES 代表暂停队列，NO 代表恢复队列。操作同步- (void)waitUntilAllOperationsAreFinished; 阻塞当前线程，直到队列中的操作全部执行完毕。添加/获取操作`- (void)addOperationWithBlock:(void (^)(void))block; 向队列中添加一个 NSBlockOperation 类型操作对象。- (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait; 向队列中添加操作数组，wait 标志是否阻塞当前线程直到所有操作结束- (NSArray *)operations; 当前在队列中的操作数组（某个操作执行结束后会自动从这个数组清除）。- (NSUInteger)operationCount; 当前队列中的操作数。获取队列+ (id)currentQueue; 获取当前队列，如果当前线程不是在 NSOperationQueue 上运行则返回 nil。+ (id)mainQueue; 获取主队列。]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins 相关]]></title>
    <url>%2F2019%2F10%2F11%2F00-%E6%8A%80%E6%9C%AF-iOS%2FJenkins-%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[Java jdk安装可以去下面的地址去下载 Java jdk 来手动安装 https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 卸载12345678sudo rm -fr /Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin sudo rm -fr /Library/PreferencesPanes/JavaControlPanel.prefpane查找当前版本 输入：ls /Library/Java/JavaVirtualMachines/ 输出：jdk-9.0.1.jdksudo rm -rf /Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk Jenkins可以去下面的地区的下载安装包来安装 https://jenkins.io/zh/doc/book/installing/ 或者去看下面的链接来处理 https://jenkins.io/zh/doc/book/installing/ 用 brew 来安装 1234567安装最新版本brew install jenkins安装 LTS 版本brew install jenkins-lts--- 12安装完成后安装的地址是 /Applications/Jenkins/jenkins.war 安装 java jdk 注意不要高版本 可以是jdk8 安装jenkins 安装好 jenkins 后面就可以使用浏览器打开 &lt;http://localhost:8080/ 了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950解锁 Jenkins为了确保管理员安全地安装 Jenkins，密码已写入到日志中（不知道在哪里？）该文件在服务器上：/Users/Shared/Jenkins/Home/secrets/initialAdminPassword请从本地复制密码并粘贴到下面。读取下面的这个文件中的密码 注意强制修改他的权限就可以打开了/Users/Shared/Jenkins/Home/secrets/initialAdminPassword 我这里打开是 ：ebed5b8f51f84d50a9a04eb580cc1292然后可以选择安装插件1、自动安装推荐的插件2、自定义安装插件默认安装会有下面的这些插件Folders OWASP Markup FormatterBuild Timeout Credentials BindingTimestamperWorkspace CleanupAntGradle PipelineGitHub Branch Source Pipeline: GitHub Groovy LibrariesPipeline: Stage View Git Subversion SSH SlavesMatrix Authorization Strategy PAM Authentication LDAP Email ExtensionMailer Localization: Chinese (Simplified)如果您不确定需要哪些插件，请选择 安装建议的插件 。 您可以通过Jenkins中的Manage Jenkins &gt; Manage Plugins 页面在稍后的时间点安装（或删除）其他Jenkins插件 。安装好了以后就你要设置用户名和密码了user: liangdahongpass: liangdahong jenkins 重新启动 - http://localhost:8080/reload 参考 - https://www.cnblogs.com/dzblog/p/6962810.html 修改一些配置 http://localhost:8080/pluginManager/advanced jenkins 插件下载 http://updates.jenkins-ci.org/download/plugins/ssh/ 可以在这里下载好了然后在 http://localhost:8080/pluginManager/advanced 上传 就可以自己安装了]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Native 相关]]></title>
    <url>%2F2019%2F10%2F09%2F02-%E6%8A%80%E6%9C%AF-%E5%89%8D%E7%AB%AF%2FReact-Native-%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[https://facebook.github.io/react-native/ https://github.com/facebook/react-native https://reactnative.cn/docs/getting-started/ https://www.imooc.com/ http://www.devio.org/ https://github.com/crazycodeboy/RNStudyNotes https://github.com/crazycodeboy/react-native-awesome 环境搭建 环境搭建 https://reactnative.cn/docs/getting-started/ 12345678910111213141516171819// 初始化项目 xxx（项目名） react-native init xxxcd 到项目 root 目录// 运行 iOSreact-native run-ios// 运行 Androidreact-native run-android// 安装库 cd 到项目 root 目录yarn add react-native-gesture-handler// 或者npm install —save react-native-gesture-handler// 把指定库和react-native链接起来// 一般不用react-native link react-native-gesture-handler 调试模拟器上 Command + D 调出调试工具 123456Reload 重新加载jsDebug JS Remotely Debug模式 会打开一个浏览器来调试Enable Live Reload 是否修改了实时加载（重新run 到首页去了）Start Systrace Enable Hot Reloading 热加载当前的页面（只更新当前显示的页面，不会到 首页去）... 其他 vscode 的一些快捷键123Windows Shift + Alt + FUbuntu Ctrl + Shift + IMac Shift + Option + F 真机调试1234567使用 Xcode 打开项目，修改 RCTWebSocketExecutor.m 文件下的 @&quot;localhost&quot; 为IP地址，手机和电脑在同一个路由器下。- (void)setUp&#123; if (!_url) &#123; NSInteger port = [[[_bridge bundleURL] port] integerValue] ?: RCT_METRO_PORT; NSString *host = [[_bridge bundleURL] host] ?: @&quot;10.1.160.82&quot;; Chrome 调试工具 https://www.imooc.com/video/18591 项目结构 应用启动是到 index.js 文件 在参考使用下面的代码到指定的界面 启动过程123456789101112// 导入 React React 当然是必须的 import React, &#123;Component&#125; from &apos;react&apos;; // 导入 AppRegistry AppRegistry 里有 registerComponent 函数 import &#123;AppRegistry&#125; from &apos;react-native&apos;; // 这个是自己写的内容 setup 来自 ./js/main 路径 和小程序差不多 import setup from &apos;./js/main&apos; // 使用 AppRegistry 调用 registerComponent 函数 ，传的参数是 &apos;AwesomeProject1&apos; 和 setup AppRegistry.registerComponent(&apos;AwesomeProject1&apos;, () =&gt; setup) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 导入 Reactimport React, &#123;Fragment&#125; from &apos;react&apos;;// 导入 SafeAreaView ...import &#123; SafeAreaView, StyleSheet, ScrollView, View, Text, StatusBar,&#125; from &apos;react-native&apos;;import &#123; Header, LearnMoreLinks, Colors, DebugInstructions, ReloadInstructions,&#125; from &apos;react-native/Libraries/NewAppScreen&apos;;// 这里是导入一个组件// import HelloComponent from &apos;./HelloComponent&apos;import &#123; Function &#125; from &apos;core-js&apos;;// 定义一个常量 这里是组件 htmlconst App = () =&gt; &#123; return ( &lt;Fragment&gt; &lt;StatusBar barStyle=&quot;dark-content&quot; /&gt; &lt;SafeAreaView&gt; &lt;View&gt; &lt;Text style=&#123;styles.HelloComponent1&#125; onPress=&#123;this.onPressButton&#125;&gt;aaaaaa&lt;/Text&gt; &lt;/View&gt; &lt;/SafeAreaView&gt; &lt;/Fragment&gt; );&#125;;// 函数function onPressButton() &#123; console.log(&quot;sssssss&quot;);&#125;// 定义一个常量 是 css 样式const styles = StyleSheet.create(&#123; HelloComponent1: &#123; fontSize:60, backgroundColor: &apos;red&apos;, marginTop:100 &#125;,&#125;);// 导出的内容export default App; 绑定事件123456789101112131415161718192021222324252627const App = () =&gt; &#123;// 这里定义一个函数 this.onPressButton0 = &#123; onStartShouldSetResponder: () =&gt; true, onMoveShouldSetResponder: () =&gt; true, // 这里是响应结束时 触发 onResponderEnd:() =&gt; &#123; console.log(&apos;main.js Text tap&apos;) &#125;, &#125;; return ( &lt;Fragment&gt; &lt;StatusBar barStyle=&quot;dark-content&quot; /&gt; &lt;SafeAreaView&gt; &lt;View&gt; &lt;HelloComponent&gt;&lt;/HelloComponent&gt; // 绑定一个事件 &lt;Text &#123;...this.onPressButton0&#125;&gt;text&lt;/Text&gt; &lt;/View&gt; &lt;/SafeAreaView&gt; &lt;/Fragment&gt; );&#125;;export default App; 组件内绑定事件1234567891011121314151617export default class HelloComponent extends Component &#123;// 定义一个函数 onPressButton0 = &#123; onStartShouldSetResponder: () =&gt; true, onMoveShouldSetResponder: () =&gt; true, // 响应结束 onResponderEnd:() =&gt; &#123; console.log(&apos;HelloComponent1 组件内响应 onPressButton0&apos;) &#125;, &#125;; render()&#123; return &lt;View&gt; &lt;Text style=&#123;styles.HelloComponent1&#125; &#123;...this.onPressButton0&#125; &gt;HelloComponent1 组件内响应 onPressButton0&lt;/Text&gt; &lt;/View&gt; &#125;&#125; 组件数据绑定12345678910111213141516171819202122232425262728293031323334// 全局的变量var cc = &apos;sss&apos;export default class OneComponent extends Component &#123;组件的属性变量 state = &#123; name: &apos;梁大红&apos;, &#125;;组件的属性变量 onPressButton0 = &#123; onStartShouldSetResponder: () =&gt; true, onMoveShouldSetResponder: () =&gt; true, onResponderEnd:() =&gt; &#123; console.log(&apos;OneComponent 组件内响应 onPressButton0&apos;) // 刷新界面 this.setState(&#123; name: this.state.name + &apos;1&apos; &#125;) // 修改全局值 来刷新界面 cc = cc + &apos;1&apos; &#125;, &#125;; render()&#123; return &lt;View&gt; // 取出值 &lt;Text style=&#123;styles.HelloComponent1&#125; &#123;...this.onPressButton0&#125; &gt;&#123;this.state.name&#125;&lt;/Text&gt; &lt;Text&gt;&#123;cc&#125;&lt;/Text&gt; &lt;/View&gt; &#125;&#125;&#125;); 组件的生命周期 React Native之React速学教程(中) - 组件的生命周期/) 12345export default class OneComponent extends Component &#123; componentDidMount()&#123; console.log(&apos;在初始化渲染执行之后立刻调用一次，仅客户端有效（服务器端不会调用）。&apos;) &#125;&#125;); 网络请求 https://reactnative.cn/docs/network/ 123456789101112131415161718192021222324252627282930313233export default class OneComponent extends Component &#123; componentDidMount() &#123; fetch(&apos;https://facebook.github.io/react-native/movies.json&apos;, &#123; method: &apos;GET&apos;, headers: &#123; Accept: &apos;application/json&apos;, &apos;Content-Type&apos;: &apos;application/json&apos;, &#125;, // body: JSON.stringify(&#123; // // firstParam: &apos;yourValue&apos;, // // secondParam: &apos;yourOtherValue&apos;, // &#125;), &#125;,) // json 处理 .then((response) =&gt; response.json()) // 成功了 .then((responseJson) =&gt; &#123; console.log(&apos;成功了&apos; + responseJson); &#125;) // 异常处理 .catch((error) =&gt; &#123; console.log(&apos;失败了&apos; + error); &#125;); &#125;&#125;); 界面中写各种判断和执行方法12345678910111213141516171819202122232425262728293031323334&lt;View&gt; &#123; ["1111"].map((item, index) =&gt; &#123; return null return ( &lt;Text&gt;&#123;item&#125;&lt;/Text&gt; ) &#125;) &#125;&lt;/View&gt;&lt;View&gt; &#123; (() =&gt; &#123; return ( &lt;Text style=&#123; (() =&gt; &#123; return ( &#123; color: "#333", fontSize: 10, &#125; ) &#125;)() &#125; &gt;aaaa&lt;/Text&gt; ) &#125;)() &#125;&lt;/View&gt; RN 组件1234567891011121314151617181920212223242526272829&lt;FlatList style=&#123;&#123; marginBottom: 80 &#125;&#125; data=&#123;this.state.workplaceList&#125; renderItem=&#123;(&#123; item &#125;) =&gt; ( &lt;TouchableOpacity onPress=&#123;() =&gt; &#123; const &#123; navigation &#125; = this.props navigation.goBack() const callback = this.props.navigation.state.params.callback if (callback != null) &#123; callback(item) &#125; &#125;&#125;&gt; &lt;View style=&#123;&#123; ...styles.searchView &#125;&#125;&gt; &lt;Text style=&#123;&#123; fontSize: 20, color: "#333" &#125;&#125;&gt;&#123;item.workplaceCode&#125;&lt;/Text&gt; &lt;Text style=&#123;&#123; fontSize: 14, color: "#999", marginTop: 10 &#125;&#125;&gt;&#123;item.workplaceName&#125;&lt;/Text&gt; &lt;Text style=&#123;&#123; fontSize: 14, color: "#999", marginTop: 10 &#125;&#125;&gt; &#123;item.provinceName + item.cityName + item.countyName + item.address&#125; &lt;/Text&gt; &lt;View style=&#123;&#123; height: 0.5, backgroundColor: "#e5e5e5", width: this.state.screenWidth, marginTop: 10 &#125;&#125;&gt;&lt;/View&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ) &#125;/&gt; Lib https://github.com/react-native-community/react-native-navbar]]></content>
      <categories>
        <category>02-技术-前端</category>
      </categories>
      <tags>
        <tag>React Native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)UIStackView的简单使用与理解]]></title>
    <url>%2F2019%2F06%2F04%2F00-%E6%8A%80%E6%9C%AF-iOS%2F%E8%BD%AC-UIStackView%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[转载自 https://lockxmonk.github.io/15391408783293.html 之前一直在吐槽iOS的布局方式（frame和autolayout）相比前端的flex布局方式很落后，也在想有没有其它的方式来改善。最近偶然发现UIStackView的存在（苹果爸爸原谅我😂），了解后发现其中的使用与布局方式类似于flex布局，感觉这就是苹果爸爸借鉴flex布局特点所构造的一种布局实现方式吧。 实现方式 这里我们看一下如何简单的使用stackview来创造一个拥有众多子item的水平视图。代码如下： 123456789101112131415161718192021222324252627- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. containerView = [[UIStackView alloc]initWithFrame:CGRectMake(0, 100, CGRectGetWidth(self.view.bounds), 200)]; //子视图布局方向：水平或垂直 containerView.axis = UILayoutConstraintAxisHorizontal;//水平布局 //子控件依据何种规矩布局 containerView.distribution = UIStackViewDistributionFillEqually;//子控件均分 //子控件之间的最小间距 containerView.spacing = 10; //子控件的对齐方式 containerView.alignment = UIStackViewAlignmentFill; NSArray *tempArray = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;]; for (NSInteger i = 0; i &lt; 4; i++) &#123;// UIView *view = [[UIView alloc]init]; UILabel *label = [[UILabel alloc] init]; label.textAlignment = NSTextAlignmentCenter; label.backgroundColor = [UIColor colorWithRed:random()%256/255.0 green:random()%256/255.0 blue:random()%256/255.0 alpha:1]; label.numberOfLines = 0; label.text = tempArray[i]; [containerView addArrangedSubview:label]; &#125; [self.view addSubview:containerView];&#125; 可以看到 stackView 的使用和view没有大的区别，使用时根绝需要来设置 stackView 的 axis（布局方向）, distribution（子控件依据何种规矩布局）, spacing（子控件之间的最小间距）, alignment（子控件的对齐方式）等属性。 属性及方法 这里详细说明一下个属性的主要参数： axis： 子控件的布局方向，水平（ UILayoutConstraintAxisHorizontal）或垂直（UILayoutConstraintAxisVertical）， 这个不用过多解释了 UIStackViewDistribution UIStackViewDistributionFill ：它就是将 arrangedSubviews 填充满整个 StackView ，如果设置了spacing，那么这些 arrangedSubviews 之间的间距就是spacing。如果减去所有的spacing，所有的 arrangedSubview 的固有尺寸( intrinsicContentSize )不能填满或者超出 StackView 的尺寸，那就会按照 Hugging 或者 CompressionResistance 的优先级来拉伸或压缩一些 arrangedSubview 。如果出现优先级相同的情况，就按排列顺序来拉伸或压缩。 UIStackViewDistributionFillEqually ：这种就是 StackView 的尺寸减去所有的spacing之后均分给 arrangedSubviews ，每个 arrangedSubview 的尺寸是相同的。 UIStackViewDistributionFillProportionally ：这种跟FillEqually差不多，只不过这个不是讲尺寸均分给 arrangedSubviews ，而是根据 arrangedSubviews 的 intrinsicContentSize 按比例分配。 UIStackViewDistributionEqualSpacing ：这种是使 arrangedSubview 之间的spacing相等，但是这个spacing是有可能大于 StackView 所设置的spacing，但是绝对不会小于。这个类型的布局可以这样理解，先按所有的 arrangedSubview 的 intrinsicContentSize 布局，然后余下的空间均分为spacing，如果大约 StackView 设置的spacing那这样就OK了，如果小于就按照 StackView 设置的spacing，然后按照 CompressionResistance 的优先级来压缩一个 arrangedSubview 。 UIStackViewDistributionEqualCentering ：这种是使 arrangedSubview 的中心点之间的距离相等，这样没两个 arrangedSubview 之间的spacing就有可能不是相等的，但是这个spacing仍然是大于等于 StackView 设置的spacing的，不会是小于。这个类型布局仍然是如果 StackView 有多余的空间会均分给 arrangedSubviews 之间的spacing，如果空间不够那就按照 CompressionResistance 的优先级压缩 arrangedSubview 。 alignment UIStackViewAlignmentFill = 默认方式， 如果子控件水平布局, 则指子控件的垂直方向填充满stackView. 反之亦然 UIStackViewAlignmentLeading = 如果子控件竖直布局, 则指子控件左边对齐stackView左边. 反之亦然, 即 UIStackViewAlignmentTop = UIStackViewAlignmentLeading。 UIStackViewAlignmentTop = UIStackViewAlignmentLeading, UIStackViewAlignmentFirstBaseline = 根据上方基线布局所有子视图的 y 值(适用于 Horizontal 模式) UIStackViewAlignmentLastBaseline = 根据下方基线布局所有子视图的 y 值(适用于 Horizontal 模式) UIStackViewAlignmentCenter = 中心对齐 UIStackViewAlignmentTrailing = 如果子控件竖直布局, 则指子控件左边对齐stackView右边. 反之亦然, 即UIStackViewAlignmentBottom = UIStackViewAlignmentTrailing UIStackViewAlignmentBottom = UIStackViewAlignmentTrailing 方法 这里还要说明几个方法：addArrangedSubview、removeArrangedSubview和insertArrangedSubview，日常view的添加和子视图从复视图删除使用的是addSubview和removeFromSuperview。 其中完整方法如下： 12345678初始化数组:- (instancetype)initWithArrangedSubviews:(NSArray *)views;添加子视图: - (void)addArrangedSubview:(UIView *)view;移除子视图:- (void)removeArrangedSubview:(UIView *)view;根据下标插入视图:- (void)insertArrangedSubview:(UIView *)viewatIndex:(NSUInteger)stackIndex; 注意 注意： addArrangedSubview 和 insertArrangedSubview， 会把子控件加到arrangedSubviews数组的同时添加到StackView的subView数组中，但是removeArrangedSubview， 只会把子控件从arrangedSubviews数组中移除，不会从subviews中移除，如果需要调用removeFromSuperview 若我们需要删除stackView中subView数组的最后一个视图，可以用如下方式： 12345//removeArrangedSubview， 只会把子控件从arrangedSubviews数组中移除，//不会从subviews中移除，如果需要可调用removeFromSuperviewUIView *view = [_containerView.subviews lastObject];[_containerView removeArrangedSubview:view];[view removeFromSuperview]; 到此stackView的一个简单使用方式就知道了。 转载自 https://lockxmonk.github.io/15391408783293.html]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 运行时之消息转发机制]]></title>
    <url>%2F2018%2F12%2F28%2F00-%E6%8A%80%E6%9C%AF-iOS%2FiOS-%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B9%8B%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Objective-C 下所有的方法调用都可以理解为，消息。一个对象接收到消息后，处理流程如下： 通过 NSObject 的 isa 指针找到对应的 Class 在方法缓存中查找 SEL 在 Class 的方法列表中找到对应的 SEL 如果没有继续往父类中找 在常规的操作中，如果我们调用一个没有实现的方法时，一直找到 root class 时都没找到方法实现时，崩溃。 那么在没有查到实现的方法时系统是否做了其他的操作呢？或者我们有什么办法来防止程序崩溃吗 ？这就是本文的主题 消息转发机制. 如下的流程图清晰的描述了具体过程。 总结为 3 个阶段可以补救。 第 1 个阶段 - 动态方法解析 在动态方法解析阶段，在该阶段中，我们可以动态的为类添加一个方法，从而让动态添加的方法来处理之前未能处理的消息，具体是在下面的方法中动态添加方法同上返回 YES，那么系统就会重给对象发送刚才的消息来执行执行。 1234+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; // 动态添加方法&#125; 代码如下 123456789101112131415161718192021222324#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;void test1test1(id self, SEL _cmd) &#123; NSLog(@&quot;test1test1 %@ %@&quot;, NSStringFromSelector(_cmd) ,self);&#125;@interface BMPerson : NSObject- (void)test1;@end@implementation BMPerson+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; NSLog(@&quot;%@&quot;, NSStringFromSelector(sel)); class_addMethod(BMPerson.class, NSSelectorFromString(@&quot;test1&quot;), (IMP) test1test1, NULL); return YES;&#125;@endint main(int argc, const char * argv[]) &#123; BMPerson *peron = BMPerson.new; [peron test1]; return 0;&#125; 第 2 个阶段 - 转发 在这个阶段系统是要求我们给他返回一个可以正常响应次消息的对象，系统就会把刚才的消息转发给开发者返回的对象，让新的对象去消息响应的消息。 123- (id)forwardingTargetForSelector:(SEL)aSelector &#123; // 然后可以响应消息的对象&#125; 代码如下 123456789101112131415161718192021222324252627#import &lt;Foundation/Foundation.h&gt;@interface BMGood : NSObject@end@implementation BMGood- (void)test1 &#123; NSLog(@&quot;BMGood test1&quot;);&#125;@end@interface BMPerson : NSObject- (void)test1;@end@implementation BMPerson- (id)forwardingTargetForSelector:(SEL)aSelector &#123; return BMGood.new;&#125;@endint main(int argc, const char * argv[]) &#123; BMPerson *peron = BMPerson.new; [peron test1]; return 0;&#125; 第 3 个阶段 - 自由派发 在这个阶段是最后一次机会，也是最强大的一步，因为在这里我们可以任意的转发给其他对象，而且可以转发给多个其他对象，从而我们可以为 Objective-C 实现 多重继承 功能，如某一种动物继承了🐱和🐶，在这里就可以转发给🐱和🐶，同时拥有抓老鼠和看家的功能。 1234- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; // 返回 NSMethodSignature 对象&#125; 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445#import &lt;Foundation/Foundation.h&gt;@interface BMGood : NSObject@end@implementation BMGood- (void)test1BMGood &#123; NSLog(@&quot;BMGood test1BMGood&quot;);&#125;@end@interface BMPerson : NSObject- (void)test1;@end@implementation BMPerson- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; NSLog(@&quot;%@&quot;, NSStringFromSelector(aSelector)); SEL selector = @selector(test1BMGood); // 创建NSMethodSignature BMGood *target = BMGood.new; NSMethodSignature *signature = [target methodSignatureForSelector:selector]; // 创建NSInvocation NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature]; // 设置target invocation.target = target; // 设置SEL invocation.selector = selector; // 开始调用 [invocation invoke]; return signature;&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; NSLog(@&quot;%@&quot;, anInvocation);&#125;@endint main(int argc, const char * argv[]) &#123; BMPerson *peron = BMPerson.new; [peron test1]; return 0;&#125; 崩溃阶段 如果在上面的 3 步都没挽救，那么系统会调用 doesNotRecognizeSelector 方法来输出崩溃的日志信息. 简单总结 由上面的简单分析，我们在调用没有实现的方法到崩溃经过了 方法查找 动态方法解析 转发 自由派发 崩溃 5 个过程，我们可以在 2 3 4 中拦截这个崩溃的产生。 完整DEMO]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSPatch简单分析1]]></title>
    <url>%2F2018%2F10%2F19%2F00-%E6%8A%80%E6%9C%AF-iOS%2FJSPatch%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%901%2F</url>
    <content type="text"><![CDATA[说在前面 https://github.com/bang590/JSPatch JSPatch 是一个基于 JavaScriptCore 的开源项目，只需要在项目里引入极小的引擎文件，就可以使用 JavaScript 实时修复线上 bug。 JavaScriptCore初探 本段参考来自 注：JavaScriptCore API也可以用Swift来调用，本文用Objective-C来介绍。 在iOS7之前，原生应用和Web应用之间很难通信。如果你想在iOS设备上渲染HTML或者运行JavaScript，你不得不使用UIWebView。iOS7引入了JavaScriptCore，功能更强大，使用更简单。 JavaScriptCore是封装了JavaScript和Objective-C桥接的Objective-C API，只要用很少的代码，就可以做到JavaScript调用Objective-C，或者Objective-C调用JavaScript。 在之前的iOS版本，你只能通过向UIWebView发送stringByEvaluatingJavaScriptFromString:消息来执行一段JavaScript脚本。并且如果想用JavaScript调用Objective-C，必须打开一个自定义的URL（例如：foo://），然后在UIWebView的delegate方法webView:shouldStartLoadWithRequest:navigationType中进行处理。 然而现在可以利用JavaScriptCore的先进功能了，它可以： 运行JavaScript脚本而不需要依赖UIWebView 使用现代Objective-C的语法（例如Blocks和下标） 在Objective-C和JavaScript之间无缝的传递值或者对象 创建混合对象（原生对象可以将JavaScript值或函数作为一个属性） 使用 JavaScriptCore 做 JavaScript 和 OC 之间的相互调用的2个小例子Objective-C调用JavaScript11234JSContext *context = [[JSContext alloc] init];NSString *str = @"(1*(2-2)+1)*5*8-2+9";JSValue *value = [context evaluateScript:str];NSLog(@"%@ = %@", str,value.toNumber); 2123456JSContext *context = [[JSContext alloc] init];NSString *jsfunc = @"function fac(n)&#123; return (n * 2);&#125;";[context evaluateScript:jsfunc];JSValue *func = context[@"fac"];JSValue *value1 = [func callWithArguments:@[@100]];NSLog(@"%@",value1.toNumber); JavaScript调用Objective-C1234567JSContext *context = [[JSContext alloc] init];[context evaluateScript:@"function printHello() &#123;print(\"Hello, World! 我在 JS 中 来的\");&#125;"];context[@"print"] = ^(NSString *text) &#123; NSLog(@"%@", text);&#125;;JSValue *function = context[@"printHello"];[function callWithArguments:@[]]; 知道了 JavaScriptCore 的强大之处，又由于 JavaScript 是脚本语言同时 OC 的动态语言，所以 JSPatch 就诞生了。 原理分析 参考来自 JSPatch 实现原理详解 我们从 JSPatch 例子开始看，比如：我们使用了下面的 js 来动态创建一个view 1234require('UIView')var view = UIView.alloc().init()view.setBackgroundColor(require('UIColor').grayColor())view.setAlpha(0.5) 当我们在 oc 中执行上面的 js 时， require(‘UIView’) 是调用 js 中的一个方法 12345678var _require = function(clsName) &#123; if (!global[clsName]) &#123; global[clsName] = &#123; __clsName: clsName &#125; &#125; return global[clsName]&#125; var view = UIView.alloc().init() 表示使用 UIView 调用 alloc init 方法，那么我们的 js 中其实是没有 这2 个方法的，但如果没有的话会报错，开发者开始想的办法动态给 js 添加，因为 js 可以随时随地增加方法，但比较痛苦。因为这些方法其实是来自于 oc 中 需要我们去遍历 oc 。由于 js 没有方法转发的功能，最后用了一个精巧的解决这个问题，在每一个 js 发放调用前先调一个 js 已经实现好的方法 __c（），其实现如下图。在这个js方法中做处理，同时想办法回调到 oc 中做应该做的事。使用上面的 js 就会最后回调到吗oc 中创建一个 view 设置颜色等。 动添加 __c 的调用如下： 1NSString *formatedScript = [NSString stringWithFormat:@";(function()&#123;try&#123;\n%@\n&#125;catch(e)&#123;_OC_catch(e.message, e.stack)&#125;&#125;)();", 123456789101112131415161718192021222324252627282930313233343536373839404142434445;(function()&#123;try&#123;defineClass('JPViewController', &#123; handleBtn: function(sender) &#123; var tableViewCtrl = JPTableViewController.__c("alloc")().__c("init")() self.__c("navigationController")().__c("pushViewController_animated")(tableViewCtrl, YES) &#125;&#125;)defineClass('JPTableViewController : UITableViewController &lt;UIAlertViewDelegate&gt;', ['data'], &#123; dataSource: function() &#123; var data = self.__c("data")(); if (data) return data; var data = []; for (var i = 0; i &lt; 20; i ++) &#123; data.__c("push")("cell from js " + i); &#125; self.__c("setData")(data) return data; &#125;, numberOfSectionsInTableView: function(tableView) &#123; return 1; &#125;, tableView_numberOfRowsInSection: function(tableView, section) &#123; return self.__c("dataSource")().length; &#125;, tableView_cellForRowAtIndexPath: function(tableView, indexPath) &#123; var cell = tableView.__c("dequeueReusableCellWithIdentifier")("cell") if (!cell) &#123; cell = require('UITableViewCell').__c("alloc")().__c("initWithStyle_reuseIdentifier")(0, "cell") &#125; cell.__c("textLabel")().__c("setText")(self.__c("dataSource")()[indexPath.__c("row")()]) return cell &#125;, tableView_heightForRowAtIndexPath: function(tableView, indexPath) &#123; return 60 &#125;, tableView_didSelectRowAtIndexPath: function(tableView, indexPath) &#123; var alertView = require('UIAlertView').__c("alloc")().__c("initWithTitle_message_delegate_cancelButtonTitle_otherButtonTitles")("Alert",self.__c("dataSource")()[indexPath.__c("row")()], self, "OK", null); alertView.__c("show")() &#125;, alertView_willDismissWithButtonIndex: function(alertView, idx) &#123; console.__c("log")('click btn ' + alertView.__c("buttonTitleAtIndex")(idx).__c("toJS")()) &#125;&#125;)&#125;catch(e)&#123;_OC_catch(e.message, e.stack)&#125;&#125;)(); 12345678910111213141516var _customMethods = &#123;__c: function(methodName) &#123; var slf = this if (slf instanceof Boolean) &#123; return function() &#123; return false &#125; &#125; if (slf[methodName]) &#123; return slf[methodName].bind(slf); &#125; if (!slf.__obj &amp;&amp; !slf.__clsName) &#123; throw new Error(slf + '.' + methodName + ' is undefined') &#125; JSPatch 的最基本的操作底层原理就是依靠 js 和 oc 的相互调用来实现的，同时 JavaScriptCore 可以做到 oc 对象 在 oc 和 js 组件无缝传递。 下面简单说下 JSPatch 是怎么样做到动态添加方法 和 交换方法的。我们使用 runtime 来添加方法 一般是提前已经有了 C函数的实现，我们在添加时，让 IMP 指向我们的 c函数指针即可，但是 JSPatch 是完全动态的添加任何类型的方法，怎么做到呢？？ 肯定不可能我们提前就实现好了 c函数，这里开发者是使用了一个通用的 c函数来实现这个问题，就是 所有添加的方法 其实都是执行到了写死的 c函数中，c函数如下，当然做了各种的坑处理，包括各种参数匹配， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277static void JPForwardInvocation(__unsafe_unretained id assignSlf, SEL selector, NSInvocation *invocation)&#123; #ifdef DEBUG _JSLastCallStack = [NSThread callStackSymbols];#endif BOOL deallocFlag = NO; id slf = assignSlf; BOOL isBlock = [[assignSlf class] isSubclassOfClass : NSClassFromString(@"NSBlock")]; NSMethodSignature *methodSignature = [invocation methodSignature]; NSInteger numberOfArguments = [methodSignature numberOfArguments]; NSString *selectorName = isBlock ? @"" : NSStringFromSelector(invocation.selector); NSString *JPSelectorName = [NSString stringWithFormat:@"_JP%@", selectorName]; JSValue *jsFunc = isBlock ? objc_getAssociatedObject(assignSlf, "_JSValue")[@"cb"] : getJSFunctionInObjectHierachy(slf, JPSelectorName); if (!jsFunc) &#123; JPExecuteORIGForwardInvocation(slf, selector, invocation); return; &#125; NSMutableArray *argList = [[NSMutableArray alloc] init]; if (!isBlock) &#123; if ([slf class] == slf) &#123; [argList addObject:[JSValue valueWithObject:@&#123;@"__clsName": NSStringFromClass([slf class])&#125; inContext:_context]]; &#125; else if ([selectorName isEqualToString:@"dealloc"]) &#123; [argList addObject:[JPBoxing boxAssignObj:slf]]; deallocFlag = YES; &#125; else &#123; [argList addObject:[JPBoxing boxWeakObj:slf]]; &#125; &#125; for (NSUInteger i = isBlock ? 1 : 2; i &lt; numberOfArguments; i++) &#123; const char *argumentType = [methodSignature getArgumentTypeAtIndex:i]; switch(argumentType[0] == 'r' ? argumentType[1] : argumentType[0]) &#123; #define JP_FWD_ARG_CASE(_typeChar, _type) \ case _typeChar: &#123; \ _type arg; \ [invocation getArgument:&amp;arg atIndex:i]; \ [argList addObject:@(arg)]; \ break; \ &#125; JP_FWD_ARG_CASE('c', char) JP_FWD_ARG_CASE('C', unsigned char) JP_FWD_ARG_CASE('s', short) JP_FWD_ARG_CASE('S', unsigned short) JP_FWD_ARG_CASE('i', int) JP_FWD_ARG_CASE('I', unsigned int) JP_FWD_ARG_CASE('l', long) JP_FWD_ARG_CASE('L', unsigned long) JP_FWD_ARG_CASE('q', long long) JP_FWD_ARG_CASE('Q', unsigned long long) JP_FWD_ARG_CASE('f', float) JP_FWD_ARG_CASE('d', double) JP_FWD_ARG_CASE('B', BOOL) case '@': &#123; __unsafe_unretained id arg; [invocation getArgument:&amp;arg atIndex:i]; if ([arg isKindOfClass:NSClassFromString(@"NSBlock")]) &#123; [argList addObject:(arg ? [arg copy]: _nilObj)]; &#125; else &#123; [argList addObject:(arg ? arg: _nilObj)]; &#125; break; &#125; case '&#123;': &#123; NSString *typeString = extractStructName([NSString stringWithUTF8String:argumentType]); #define JP_FWD_ARG_STRUCT(_type, _transFunc) \ if ([typeString rangeOfString:@#_type].location != NSNotFound) &#123; \ _type arg; \ [invocation getArgument:&amp;arg atIndex:i]; \ [argList addObject:[JSValue _transFunc:arg inContext:_context]]; \ break; \ &#125; JP_FWD_ARG_STRUCT(CGRect, valueWithRect) JP_FWD_ARG_STRUCT(CGPoint, valueWithPoint) JP_FWD_ARG_STRUCT(CGSize, valueWithSize) JP_FWD_ARG_STRUCT(NSRange, valueWithRange) @synchronized (_context) &#123; NSDictionary *structDefine = _registeredStruct[typeString]; if (structDefine) &#123; size_t size = sizeOfStructTypes(structDefine[@"types"]); if (size) &#123; void *ret = malloc(size); [invocation getArgument:ret atIndex:i]; NSDictionary *dict = getDictOfStruct(ret, structDefine); [argList addObject:[JSValue valueWithObject:dict inContext:_context]]; free(ret); break; &#125; &#125; &#125; break; &#125; case ':': &#123; SEL selector; [invocation getArgument:&amp;selector atIndex:i]; NSString *selectorName = NSStringFromSelector(selector); [argList addObject:(selectorName ? selectorName: _nilObj)]; break; &#125; case '^': case '*': &#123; void *arg; [invocation getArgument:&amp;arg atIndex:i]; [argList addObject:[JPBoxing boxPointer:arg]]; break; &#125; case '#': &#123; Class arg; [invocation getArgument:&amp;arg atIndex:i]; [argList addObject:[JPBoxing boxClass:arg]]; break; &#125; default: &#123; NSLog(@"error type %s", argumentType); break; &#125; &#125; &#125; if (_currInvokeSuperClsName[selectorName]) &#123; Class cls = NSClassFromString(_currInvokeSuperClsName[selectorName]); NSString *tmpSelectorName = [[selectorName stringByReplacingOccurrencesOfString:@"_JPSUPER_" withString:@"_JP"] stringByReplacingOccurrencesOfString:@"SUPER_" withString:@"_JP"]; if (!_JSOverideMethods[cls][tmpSelectorName]) &#123; NSString *ORIGSelectorName = [selectorName stringByReplacingOccurrencesOfString:@"SUPER_" withString:@"ORIG"]; [argList removeObjectAtIndex:0]; id retObj = callSelector(_currInvokeSuperClsName[selectorName], ORIGSelectorName, [JSValue valueWithObject:argList inContext:_context], [JSValue valueWithObject:@&#123;@"__obj": slf, @"__realClsName": @""&#125; inContext:_context], NO); id __autoreleasing ret = formatJSToOC([JSValue valueWithObject:retObj inContext:_context]); [invocation setReturnValue:&amp;ret]; return; &#125; &#125; NSArray *params = _formatOCToJSList(argList); char returnType[255]; strcpy(returnType, [methodSignature methodReturnType]); // Restore the return type if (strcmp(returnType, @encode(JPDouble)) == 0) &#123; strcpy(returnType, @encode(double)); &#125; if (strcmp(returnType, @encode(JPFloat)) == 0) &#123; strcpy(returnType, @encode(float)); &#125; switch (returnType[0] == 'r' ? returnType[1] : returnType[0]) &#123; #define JP_FWD_RET_CALL_JS \ JSValue *jsval; \ [_JSMethodForwardCallLock lock]; \ jsval = [jsFunc callWithArguments:params]; \ [_JSMethodForwardCallLock unlock]; \ while (![jsval isNull] &amp;&amp; ![jsval isUndefined] &amp;&amp; [jsval hasProperty:@"__isPerformInOC"]) &#123; \ NSArray *args = nil; \ JSValue *cb = jsval[@"cb"]; \ if ([jsval hasProperty:@"sel"]) &#123; \ id callRet = callSelector(![jsval[@"clsName"] isUndefined] ? [jsval[@"clsName"] toString] : nil, [jsval[@"sel"] toString], jsval[@"args"], ![jsval[@"obj"] isUndefined] ? jsval[@"obj"] : nil, NO); \ args = @[[_context[@"_formatOCToJS"] callWithArguments:callRet ? @[callRet] : _formatOCToJSList(@[_nilObj])]]; \ &#125; \ [_JSMethodForwardCallLock lock]; \ jsval = [cb callWithArguments:args]; \ [_JSMethodForwardCallLock unlock]; \ &#125; #define JP_FWD_RET_CASE_RET(_typeChar, _type, _retCode) \ case _typeChar : &#123; \ JP_FWD_RET_CALL_JS \ _retCode \ [invocation setReturnValue:&amp;ret];\ break; \ &#125; #define JP_FWD_RET_CASE(_typeChar, _type, _typeSelector) \ JP_FWD_RET_CASE_RET(_typeChar, _type, _type ret = [[jsval toObject] _typeSelector];) \ #define JP_FWD_RET_CODE_ID \ id __autoreleasing ret = formatJSToOC(jsval); \ if (ret == _nilObj || \ ([ret isKindOfClass:[NSNumber class]] &amp;&amp; strcmp([ret objCType], "c") == 0 &amp;&amp; ![ret boolValue])) ret = nil; \ #define JP_FWD_RET_CODE_POINTER \ void *ret; \ id obj = formatJSToOC(jsval); \ if ([obj isKindOfClass:[JPBoxing class]]) &#123; \ ret = [((JPBoxing *)obj) unboxPointer]; \ &#125; #define JP_FWD_RET_CODE_CLASS \ Class ret; \ ret = formatJSToOC(jsval); #define JP_FWD_RET_CODE_SEL \ SEL ret; \ id obj = formatJSToOC(jsval); \ if ([obj isKindOfClass:[NSString class]]) &#123; \ ret = NSSelectorFromString(obj); \ &#125; JP_FWD_RET_CASE_RET('@', id, JP_FWD_RET_CODE_ID) JP_FWD_RET_CASE_RET('^', void*, JP_FWD_RET_CODE_POINTER) JP_FWD_RET_CASE_RET('*', void*, JP_FWD_RET_CODE_POINTER) JP_FWD_RET_CASE_RET('#', Class, JP_FWD_RET_CODE_CLASS) JP_FWD_RET_CASE_RET(':', SEL, JP_FWD_RET_CODE_SEL) JP_FWD_RET_CASE('c', char, charValue) JP_FWD_RET_CASE('C', unsigned char, unsignedCharValue) JP_FWD_RET_CASE('s', short, shortValue) JP_FWD_RET_CASE('S', unsigned short, unsignedShortValue) JP_FWD_RET_CASE('i', int, intValue) JP_FWD_RET_CASE('I', unsigned int, unsignedIntValue) JP_FWD_RET_CASE('l', long, longValue) JP_FWD_RET_CASE('L', unsigned long, unsignedLongValue) JP_FWD_RET_CASE('q', long long, longLongValue) JP_FWD_RET_CASE('Q', unsigned long long, unsignedLongLongValue) JP_FWD_RET_CASE('f', float, floatValue) JP_FWD_RET_CASE('d', double, doubleValue) JP_FWD_RET_CASE('B', BOOL, boolValue) case 'v': &#123; JP_FWD_RET_CALL_JS break; &#125; case '&#123;': &#123; NSString *typeString = extractStructName([NSString stringWithUTF8String:returnType]); #define JP_FWD_RET_STRUCT(_type, _funcSuffix) \ if ([typeString rangeOfString:@#_type].location != NSNotFound) &#123; \ JP_FWD_RET_CALL_JS \ _type ret = [jsval _funcSuffix]; \ [invocation setReturnValue:&amp;ret];\ break; \ &#125; JP_FWD_RET_STRUCT(CGRect, toRect) JP_FWD_RET_STRUCT(CGPoint, toPoint) JP_FWD_RET_STRUCT(CGSize, toSize) JP_FWD_RET_STRUCT(NSRange, toRange) @synchronized (_context) &#123; NSDictionary *structDefine = _registeredStruct[typeString]; if (structDefine) &#123; size_t size = sizeOfStructTypes(structDefine[@"types"]); JP_FWD_RET_CALL_JS void *ret = malloc(size); NSDictionary *dict = formatJSToOC(jsval); getStructDataWithDict(ret, dict, structDefine); [invocation setReturnValue:ret]; free(ret); &#125; &#125; break; &#125; default: &#123; break; &#125; &#125; if (_pointersToRelease) &#123; for (NSValue *val in _pointersToRelease) &#123; void *pointer = NULL; [val getValue:&amp;pointer]; CFRelease(pointer); &#125; _pointersToRelease = nil; &#125; if (deallocFlag) &#123; slf = nil; Class instClass = object_getClass(assignSlf); Method deallocMethod = class_getInstanceMethod(instClass, NSSelectorFromString(@"ORIGdealloc")); void (*originalDealloc)(__unsafe_unretained id, SEL) = (__typeof__(originalDealloc))method_getImplementation(deallocMethod); originalDealloc(assignSlf, NSSelectorFromString(@"dealloc")); &#125;&#125; 平台使用 平台使用说明 如果使用其平台来做还是算简单的，基本不用做其他配置。 集成 SDK 一般情况的SDK的使用完全按照文档基本没有问题 在平台创建 APP 下载SDK集成到项目中 已经集成完毕 在需要修复 bug 时，先写好 js 脚本 本地测试 测试成功后，去平台下发即可。 平台 SDK 使用注意点： 补丁累计不要超过 1 个 每一次 App 更新必须使用原生来处理掉所有的补丁，同时需要清除相应的补丁下载。 每一次下发补丁需提本地测试 自建平台 自建平台时需要处理的一些问题 拷贝下官方的一个 DEMO 有一个最简单的控制器上有一个按钮，现在想加点功能，就是在点击这个按钮时跳转到一个新界面，新的界面上有一个 tableView，同时做相应的简单展示、 123456789101112131415161718#import &quot;JPViewController.h&quot;@implementation JPViewController- (void)viewDidLoad &#123; [super viewDidLoad]; UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(0, 100, [UIScreen mainScreen].bounds.size.width, 50)]; [btn setTitle:@&quot;Push JPTableViewController&quot; forState:UIControlStateNormal]; [btn addTarget:self action:@selector(handleBtn:) forControlEvents:UIControlEventTouchUpInside]; [btn setBackgroundColor:[UIColor grayColor]]; [self.view addSubview:btn];&#125;- (void)handleBtn:(id)sender&#123;&#125;@end 集成项目 1234[JPEngine startEngine];NSString *sourcePath = [[NSBundle mainBundle] pathForResource:@&quot;demo&quot; ofType:@&quot;js&quot;];NSString *script = [NSString stringWithContentsOfFile:sourcePath encoding:NSUTF8StringEncoding error:nil];[JPEngine evaluateScript:script]; JS 脚本如下 12345678910111213141516171819202122232425262728293031323334353637383940414243defineClass(&apos;JPViewController&apos;, &#123; handleBtn: function(sender) &#123; var tableViewCtrl = JPTableViewController.alloc().init() self.navigationController().pushViewController_animated(tableViewCtrl, YES) &#125;&#125;)defineClass(&apos;JPTableViewController : UITableViewController &lt;UIAlertViewDelegate&gt;&apos;, [&apos;data&apos;], &#123; dataSource: function() &#123; var data = self.data(); if (data) return data; var data = []; for (var i = 0; i &lt; 20; i ++) &#123; data.push(&quot;cell from js &quot; + i); &#125; self.setData(data) return data; &#125;, numberOfSectionsInTableView: function(tableView) &#123; return 1; &#125;, tableView_numberOfRowsInSection: function(tableView, section) &#123; return self.dataSource().length; &#125;, tableView_cellForRowAtIndexPath: function(tableView, indexPath) &#123; var cell = tableView.dequeueReusableCellWithIdentifier(&quot;cell&quot;) if (!cell) &#123; cell = require(&apos;UITableViewCell&apos;).alloc().initWithStyle_reuseIdentifier(0, &quot;cell&quot;) &#125; cell.textLabel().setText(self.dataSource()[indexPath.row()]) return cell &#125;, tableView_heightForRowAtIndexPath: function(tableView, indexPath) &#123; return 60 &#125;, tableView_didSelectRowAtIndexPath: function(tableView, indexPath) &#123; var alertView = require(&apos;UIAlertView&apos;).alloc().initWithTitle_message_delegate_cancelButtonTitle_otherButtonTitles(&quot;Alert&quot;,self.dataSource()[indexPath.row()], self, &quot;OK&quot;, null); alertView.show() &#125;, alertView_willDismissWithButtonIndex: function(alertView, idx) &#123; console.log(&apos;click btn &apos; + alertView.buttonTitleAtIndex(idx).toJS()) &#125;&#125;)]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时光轴]]></title>
    <url>%2F2018%2F10%2F18%2F05-%E7%94%9F%E6%B4%BB-%E6%84%9F%E5%8F%B9%2F%E6%97%B6%E5%85%89%E8%BD%B4%2F</url>
    <content type="text"><![CDATA[2018 领证了; 小朋友比以前听话多了; 赚了点外快把之前的所有外债还清了，无债一身轻，存了点粮食; 感谢苹果粑粑，虽然被虐千百遍，但还是有一些收获; 世界杯输了点，但还好，因祸得福; 技术方面就不谈了; 2019 加油。 2018年计划 学习 Web前端 -&gt; 会实现基本的界面。 在 Web前端 的基础上学习微信小程序 -&gt; 会简单的业务功能开发。 深耕 iOS 技术，对性能优化，有一点的积累。 稍微复习下算法。 加强 Swift 的学习。]]></content>
      <categories>
        <category>05-生活-感叹</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正确高效使用 Google]]></title>
    <url>%2F2018%2F07%2F11%2F03-%E6%8A%80%E6%9C%AF-%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E6%AD%A3%E7%A1%AE%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8-Google%2F</url>
    <content type="text"><![CDATA[写在前面 文章来自 七年就是一辈子-李笑来 研究这个词，在英文中是research，我把它理解为re-search，实际上各种语言是相通的，所谓re-search其实就是“反复搜索”，就是“上下求索”（路漫漫其修远兮，吾将上下而求索）。所以，如果你想学点什么，就要善于搜索。而在这个时代里，最好的搜索工具就是 Google。 搜索引擎之所以迷人，就是因为它就好像望远镜一样： 能让你看到你原本完全看不到的东西…… 互联网就好像那浩瀚的宇宙，里面几乎什么都有，只要你肯用“望远镜”去看、用搜索引擎去搜…… 搜索引擎是公开的，人人都可以用的，可偏偏大多数人不用、不会用，甚至错误地用…… 于是人与人之间的差异多了另外一个不断延展的维度。在这个维度上你不如人家你能怪谁？ 最烂的提问是：“我连不上 Google 怎么办呀？” 答案是“自己想办法” —— 如果你在乎，你就肯花时间自己解决这个问题，如果你不在乎，就不用在乎了。 使用“本尊”最好使用 http://www.google.com/ncr NCR: No Country Redirection，而不是http://www.google.com.hk；有时，直接输入http://www.google.com也会被自动转到“本地Google”，比如，我用日本的 VPN，浏览器就会把我转到http://www.google.co.jp…… 优先使用英文关键字搜索这是个好习惯。别说不会英文，不会就学，没那么难。 基本技巧Google 搜索引擎也许是世界上最简单的应用界面，只有一个输入框和一个按钮。然而，用好它还是需要花点时间去学习的。Google 有帮助文档，还专门设计了个学习网站 A Google A Day 加号在 Google 的输入框里，所有的空格都被 Google 理解为加号+。如果你输入的是 purpose of education那么 Google 返回的文章里既有“purpose”存在，也有“education”存在，但不一定有“purpose of education”存在。另外，过分常用的、单独存在没有意义的词汇往往被忽略掉，比如冠词“a”、“the”；介词“of”、“in”、“on”、“at”、“to”；连词“and”、“or”、“but”；从属连词“that”、“which”、“when”；代词“my”、“his”、“them”等等。 引号如果你想要找含有“purpose of education”这个词组的文章，那么你必须输入”purpose of education”。现在的 Google 已经可以处理 utf-8 大字符集了，所以，即便你在输入的时候使用的是全角字符（不是半角字符的”而是“或者”）Google也照样能够正确处理。比较一下两种输入返回的结果：purpose of education vs.“purpose of education”。再试试 the most important benefit of education 和 “the most important benefit of education”。这就是引号（“……”）的作用——返回“完整匹配”的结果。 减号为了进一步筛选搜索结果，还需要学会另外一个符号——减号-。比如，“the most important benefit of education” – “united states”要求Google返回含有“the most important benefit of education”但不存在“united states”的文章。 星号另外一个威力无穷的符号是星号。Google 支持通配符搜索，即搜索字符串中可以包含星号，用来替代任意字符串。比如，“the most * examples of censorship”将会返回含有类似“the most outrageous examples of censorship”、“the most brazen examples of censorship”、“the most heinous examples of censorship”、“the most stupidest examples of censorship”、“the most dangerous examples of censorship”、“the most egregious examples of censorship”、“the most prolific examples of censorship”、“the most absurd examples of censorship”…… 波浪号还有一个运用相当灵活、经常带来意外收获的符号是波浪号~。把波浪号~加在某个单词前面，是在告诉 Google：除了给出的关键字之外，还要搜索与波浪号~后面的那个单词相关的词汇。比如，搜索the importance of ~censorship的结果中包含着“the importance of censorship”，也包含着与censorship相关的另外一个词汇“propaganda”——“the importance of propaganda”。 高级技巧站内搜索再学一个在指定网站中搜索的语法“site:”。比如，“the purpose of education” site:http://www.time.com/就是要求 Google 只返回 http://www.time.com 这个网站里的含有“the purpose of education”的文章。 定制搜索2006年，Google 推出了“co-op”服务（自定义搜索引擎）。其中最常用的功能之一就是可以指定 Google 搜索一个或者若干个指定的网站——相当于前面提到的 Google 语法“site:”的扩展。比如，我就曾经为我的学生定制了一个 Google cse（Custom Search Engine）——Search News Media。不妨看看在这个自定义搜索引擎上搜索censorship返回的结果（GRE/SAT 的作文考试中，都有很多关于“censorship”的作文题）。这个 cse 只搜索以下10个网站： http://www.economist.com/ http://www.cnn.com/ http://www.time.com/ http://nytimes.com/ http://www.washingtonpost.com/ http://www.usnews.com/ http://usatoday.com/ http://www.reuters.com/ http://www.bbc.co.uk/ http://en.wikinews.org/ 特别声明 文章来自 七年就是一辈子-李笑来]]></content>
      <categories>
        <category>03-技术-计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 - 中国教育问题的根源在于大学而不在高中]]></title>
    <url>%2F2018%2F06%2F25%2F05-%E7%94%9F%E6%B4%BB-%E6%84%9F%E5%8F%B9%2F%E8%BD%AC-%E4%B8%AD%E5%9B%BD%E6%95%99%E8%82%B2%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%BA%90%E5%9C%A8%E4%BA%8E%E5%A4%A7%E5%AD%A6%E8%80%8C%E4%B8%8D%E5%9C%A8%E9%AB%98%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[文章转载自 https://mp.weixin.qq.com/s/PJc-EPoYWCiIK06zngWBCw，特别推荐大家关注此公众号。]]></content>
      <categories>
        <category>05-生活-感叹</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发相关]]></title>
    <url>%2F2018%2F06%2F13%2F01-%E6%8A%80%E6%9C%AF-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[介绍 微信小程序开发指南 https://developers.weixin.qq.com/miniprogram/dev/framework/ 微信小程序官网 &lt;https://mp.weixin.qq.com/wxamp/ https://developer.mozilla.org/zh-CN/docs/Web/CSS/Universal_selectors https://www.w3school.com.cn/css/css_selector_child.asp http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html 布局flex display: flex; 阮一峰 - Flex 布局教程：语法篇 阮一峰 - Flex 布局教程：实例篇 mozilla.org - 使用 CSS 弹性盒子 容器的属性 flex-direction 主轴方向 row（默认值）：主轴为水平方向，起点在左端。​ row-reverse：主轴为水平方向，起点在右端。​ column：主轴为垂直方向，起点在上沿。​ column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap 换行样式 （1）nowrap（默认）：不换行。​ （2）wrap：换行，第一行在上方。​ （3）wrap-reverse：换行，第一行在下方。 flex-flow flex-direction 和 flex-wrap 简写方式 默认值为row nowrap justify-content 主轴对齐方式 flex-start（默认值）：左对齐​ flex-end：右对齐​ center： 居中​ space-between：两端对齐 (边上的项目到边框的距离是 0 )，项目之间的间隔都相等。​ space-around：每个项目两侧的间隔相等。所以，项目之间的间隔 是 项目与边框的间隔的 2 倍。 align-items 交叉轴/侧轴 对齐方式 flex-start：交叉轴的起点对齐。​ flex-end：交叉轴的终点对齐。​ center：交叉轴的中点对齐。​ baseline: 项目的第一行文字的基线对齐。​ stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content 多轴线时,一般是多条交叉轴时，多行项目就有多条交叉轴线相当于交叉轴的对齐方式 是对全部的项目的对齐方式。 ​ flex-start：与交叉轴的起点对齐。​ flex-end：与交叉轴的终点对齐。​ center：与交叉轴的中点对齐。​ space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。​ space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。​ stretch（默认值）：轴线占满整个交叉轴。​ 项目的属性 order order属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0 。​ flex-grow属性 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。​ 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。​ 如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。​ 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。​ 如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。​ 负值对该属性无效。​ flex-basis属性 (待理解)​ flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。​ 浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。​ 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flex属性​ flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 12345.item &#123; flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]&#125;该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。​​ .item {​ align-self: auto | flex-start | flex-end | center | baseline | stretch;​ }​ 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 position 定位http://www.runoob.com/css/css-padding.html position 位置的意思， position: static 默认， 不会被定位，由上下文自动确定其位置 position: absolute 绝对定位，向上找到第一个 position 为 relative 的标签为参考，可以使用 top left right bottom 等属性 position: relative 相对定位，以自己为参考 position: fixed 固定定位 一些实例单行文本框垂直居中 可以把其 [行高 line-height ] 设置为标签高度即可 line-height: height; 多行文本框垂直居中 可以使用 table 和 table-cell 参考 https://www.cnblogs.com/xiaofeixiang/p/5005587.html?utm_source=tuicool&amp;utm_medium=referral CSS样式类型标签选择器12345/* 标签选择器 *//* &lt;view&gt;&lt;/view&gt; */view &#123; background-color: #333;&#125; 类选择器12345/* 类选择器 *//* &lt;view class=&quot;con con&quot;&gt;&lt;/view&gt; */.con &#123; background-color: #333;&#125; id选择器12345/* id选择器 *//* &lt;view id=&quot;con&quot;&gt;&lt;/view&gt; */#con &#123; background-color: #333;&#125; 通配样式 暂时不考虑1/* 通配样式 暂时不考虑*/ 交集1234/* 交集 */.con1.con2 &#123; background-color: #333;&#125; 并集1234/* 并集 */.con1,.con2 &#123; background-color: #333;&#125; 子代1234/* 子代 */.con1&gt;con2 &#123; background-color: #333;&#125; 后代1234/* 后代 */.con1 .con2 &#123; background-color: #333;&#125; JS数据类型WXS 语言目前共有以下几种数据类型： number ： 数值 string ：字符串 boolean：布尔值 object：对象 function：函数 array : 数组 date：日期 regexp：正则 小程序官方文档 数组操作1234567891011// 声明一个数组var arr = []// 添加一个对象,同时返回添加后的数组长度arr.push(&apos;&apos;)// 删除最后一个对象,同时返回这个数组arr.pop()// 从sidx位置开始删除len个对象arr.splice(sidx, len) JavaScript中对数组的一些操作函数，可参考 String 和 Number 相互转换1234567891011121314151617// 会自动忽略掉末尾的0 比如 【 1.00.toString() = '1' 】 【 parseFloat('1.00') = 1 】var n = 10String(1)n.toString()console.log(parseInt("1.001"));console.log(parseFloat('1.00'));// 价格转换var price = 100.99; // 元为单位price.toFixed(price); // '100.99'(100.00).toFixed(); // '100.00'var price = 10009; // 分为单位(10009/100.0).toFixed(price); // '100.99'(10000/100.0).toFixed(100.00); // '100.00' JS文件中的各种写法 12345678910111213141516171819202122232425262728293031323334// 使用 module.exports 输出对象module.exports = &#123;formatTime: formatTime&#125;// 引用const obj = require(&apos;./utils/util&apos;) // 相对路径 . 表示当前路径 .. 表示当前路径的上一层路径const obj = require(&apos;/utils/util&apos;) // 绝对路径const obj = require(&apos;../utils/util&apos;) // 相对路径// 定义一个变量var num1 = 10;// 定义一个常量const num2 = 10;// 定义一个函数var f2 = function(res) &#123;&#125;// 定义一个函数var f3 = (res) =&gt; &#123;&#125;// 定义一个函数var f4 = res =&gt; &#123;&#125;// 定义一个函数function get(res) &#123;&#125;// 定义一个对象，在对象中定义函数和在外面基本一样var http = &#123; a: () =&gt; &#123; &#125;, kk: 10,&#125;// 更简洁的方式fun(&#123;&#125;) // module class Promise 箭头函数 =&gt; Promise 个人理解，Promise 是一个对象，他的目的是封装异步操作，让异步操作处理更简洁。 创建 promise下面是创建 promise 的代码，需要过它传入的参数是一个函数 ()=&gt;() resolve, reject 是函数的参数。同时他们也是一个函数，这里暂时不管它是干撒的，反正必须这写就好了。 1234567891011const promise = new Promise( (resolve, reject)=&gt;() ) const promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(function() &#123; if (true) &#123; resolve('value'); &#125; else &#123; reject('error'); &#125; &#125;, 1000)&#125;); 创建一个支持 Promise 函数123456789101112131415161718const func = (options = &#123;time: 2000&#125;) =&gt; ( promise) // 合并起来const func = (options = &#123;time: 2000&#125;) =&gt; ( new Promise((resolve, reject) =&gt; &#123; setTimeout(function () &#123; if (false) &#123; // 成功回调 resolve('value'); &#125; else &#123; // 异常回调 reject('error'); &#125; &#125;, options.time) &#125;)) 调用支持 Promise 的函数12345 // then 的（）中的内容其实就是 上面的 resolve 是一个函数。 // catch 的（）中的内容其实就是 上面的 reject 是一个函数。func().then(res =&gt; &#123; &#125;).catch(res =&gt; &#123; &#125;) 上面介绍了最简单的 Promise 定义，其他各种功能可参考下面的内容。 http://es6.ruanyifeng.com/#docs/promise https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544 Promise 的其他功能 转载 http://es6.ruanyifeng.com/#docs/promise Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 12345getJSON("/posts.json").then(function(json) &#123; return json.post; &#125;).then(function(post) &#123; // ...&#125;); 上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 1234567getJSON("/post/1.json").then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function (comments) &#123; console.log("resolved: ", comments);&#125;, function (err)&#123; console.log("rejected: ", err);&#125;); 上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用第一个回调函数，如果状态变为rejected，就调用第二个回调函数。 如果采用箭头函数，上面的代码可以写得更简洁。 123456getJSON("/post/1.json").then( post =&gt; getJSON(post.commentURL)).then( comments =&gt; console.log("resolved: ", comments), err =&gt; console.log("rejected: ", err)); 多个 then 连起来写的时候，后面的 then 要等前面的 then 或者 catch 执行后才执行，同时前面的 then 或者 catch 的返回值会带到后面的 then 中。 如下面的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const func = (options = &#123;time: 2000&#125;) =&gt; ( new Promise((resolve, reject) =&gt; &#123; setTimeout(function () &#123; if (false) &#123; resolve('value'); &#125; else &#123; reject('error'); &#125; &#125;, options.time) &#125;) ) func(&#123; time: 2000&#125;).then(function(res) &#123; wx.showToast(&#123; title: 'then 1' + res, &#125;) return 3000&#125;).catch(res=&gt;&#123; wx.showToast(&#123; title: 'catch 1' + res, &#125;) return 4000&#125;).then(function(post) &#123; console.log('then2' + post) baseRequest.func(&#123; time: post &#125;).then(res =&gt; wx.showToast(&#123; title: 'then 2' + res, &#125;) ) &#125;).catch(post=&gt;&#123; baseRequest.func(&#123; time: post &#125;).catch(res =&gt; wx.showToast(&#123; title: 'catch 2' + res, &#125;) )&#125;) 组件 组件的定义，使用，传值、事件传递 响应标识 定义 Blocks 循环 界面跳转 css的各种布局 wxml 中各种条件判断 组件的导入，css的导入，js方法的导入和导出使用 定时器 微信提供的一些系统功能的使用 刷新组件 小程序源码破解 查看 ip 地址 12// 输出 行内有 inet 且没有 127.0.0.1 的内容ifconfig | grep &quot;inet &quot; | grep -v 127.0.0.1 微信小程序 12345678910111213141516// 进入手机文件中ssh root@192.168.2.12// 搜索相关find / -name &quot;*.wxapkg&quot;// 删除相关rm -rf $(find / -name &quot;*.wxapkg&quot;)// 把文件拷贝到电脑scp root@192.168.2.12:/private/var/mobile/Containers/Data/Application/24B958CE-A2B6-4B8C-ABC6-90075E90F2A0/Library/WechatPrivate/5fbbe972df96a510dc8560269047c82a/WeApp/LocalCache/release/wxe7c3f366905ced15/1.wxapkg /Users/___liangdahong/Desktop/wx// 解包node ./wxappUnpacker-master/wuWxapkg.js 1.wxapkg335418265]]></content>
      <categories>
        <category>01-技术-微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈 iOS 事件的传递和响应过程]]></title>
    <url>%2F2018%2F06%2F08%2F00-%E6%8A%80%E6%9C%AF-iOS%2F%E6%B5%85%E8%B0%88-iOS-%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E9%80%92%E5%92%8C%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[问题 iOS 中 View 的事件到底是怎么传递和响应的？ 为什么 父View 关闭了事件响应时，子View 就无法响应事件？ 底层原理？ 如何扩大 Button 的点击范围 ？ 如何让 父View 和 子View 同时响应同一事件？默认情况下只会响应 子View 的事件回调。 为什么 子View 关闭了事件，但其 父View 开启事件的情况下，点击 子View 时，父View 可以正常响应事件？ 为什么 子View 是 UIView时，如果没有添加手势，点击子 View时，会由其父View来响应，而 子View 是 UIControl 时，子View 没有添加手势，一样不会由 父View 来响应 … 分析 iOS 的事件可以分为三种 Touch Events(触摸事件) Motion Events(运动事件，比如重力感应和摇一摇等) Remote Events(远程事件，比如用耳机上得按键来控制手机) 下面主要讲解 Touch Events(触摸事件) Touch Events事件的整个过程可以分为 传递和响应 2 个阶段， 传递： 是当我们触摸屏幕时，为我们找出最适合的 View， 响应： 当我们找出最适合的 View 后，此时只是找到了最合适的 View，但未必 此 View 可以响应此事件，所以需要继续找出能响应此事件的 View。 传递过程 每当手指接触屏幕，操作系统会把事件传递给当前的 App， 在 UIApplication接收到手指的事件之后，就会去调用`UIWindow的hitTest:withEvent:，看看当前点击的点是不是在window内，如果是则继续依次调用其 subView的hitTest:withEvent:方法，直到找到最后需要的view。调用结束并且hit-test view确定之后，便可以确定最合适的 View。 引用几张图来说明 图片表示的内容可用下面的话描述来自这里 递归是向界面的根节点UIWindow发送hitTest:withEvent:消息开始的，从这个消息返回的是一个UIView，也就是手指当前位置最前面的那个 hittest view。 当向UIWindow发送hitTest:withEvent:消息时，hitTest:withEvent:里面所做的事，就是判断当前的点击位置是否在window里面，如果在则遍历window的subview然后依次对subview发送hitTest:withEvent:消息(注意这里给subview发送消息是根据当前subview的index顺序，index越大就越先被访问)。如果当前的point没有在view上面，那么这个view的subview也就不会被遍历了。当事件遍历到了view B.1，发现point在view B.1里面，并且view B.1没有subview，那么他就是我们要找的hittest view了，找到之后就会一路返回直到根节点，而view B之后的view A也不会被遍历了。 下面是 - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event 方法的内部实现 1234567891011121314 - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; if (self.hidden || !self.userInteractionEnabled || self.alpha &lt; 0.01 || ![self pointInside:point withEvent:event] || ![self _isAnimatedUserInteractionEnabled]) &#123; return nil; &#125; else &#123; for (UIView *subview in [self.subviews reverseObjectEnumerator]) &#123; UIView *hitView = [subview hitTest:[subview convertPoint:point fromView:self] withEvent:event]; if (hitView) &#123; return hitView; &#125; &#125; return self; &#125;&#125; 上面的代码来自这里 响应过程 个人对响应过程的理解如下： 当我们知道最合适的 View 后，事件会 由上向下【子view -&gt; 父view，控制器view -&gt; 控制器】来找出合适响应事件的 View，来响应相关的事件。如果当前的 View 有添加手势，那么直接响应相应的事件，不会继续向下寻找了，如果没有手势事件，那么会看其是否实现了如下的方法： 1234- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; 如果有实现那么就由此 View 响应，如果没有实现，那么就会传递给他的下一个响应者【子view -&gt; 父view，控制器view -&gt; 控制器】， 这里我们可以做一个简单的验证，在默认情况下 UIView 是不响应事件的，UIControl 就算没有添加手势一样的会由他来响应， 这里可以使用 runtime查看 UIView 和 UIControl 的方法列表， 或 查看 UIKit 源码 可知， UIView 没有实现如上的 touchesBegan方法，而 UIControl 是实现了如上的相关方法，所以验证了刚才的 UIView 不响应，和 UIControl 的响应。一旦找到最合适响应的View就结束, 在执行响应的绑定的事件，如果没有就抛弃此事件。 我的验证 首先处理添加了手势时，其便可以处理事件。 我们创建一个view A 在 A 中添加一个 view B, 如果我们给 A 加了手势，B没有加手势， 我们在点击 B 时，会响应 A 的事件，非常正常的情况，那么它是怎么判断 B 是否可以处理的呢？ 我们现在给 B 加一个手势，那么同样的操作时会触发 B 的手势，现在我们 给 B 增加一个方法， @implementation BMSonView - (NSArray&lt;UIGestureRecognizer *&gt; *)gestureRecognizers { NSLog(@"%@", self); return @[]; } 手势返回 @[]，此时点击 B 只会触发 A 的事件，由此可以说明在判断 view 是否可以处理事件实现是判断 gestureRecognizers 即是否添加了手势，上面提到了还有判断如下的方法是否实现了,默认情况下 UIView 是没有实现如下的方法的，使用在没有添加手势时他不响应事件。 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event; - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event; - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event; - (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; 如果我们手动实现了如上的方法时，就算没有给 B 添加手势，点击 B 时， 事件不会响应 A 的方法，会到上面的方法中。从 UIControl 的源码便可清除看到。 所以个人理解： 事件在传递时和上面的 hit 方法有关，一层层向上传递，【窗口—&gt; view】由其相应的 view 中具体的实现来确定谁才是是最合适响应的view 在响应时，又上向下找出第一个能处理的view来处理事件，[view —&gt; 窗口]，在寻找刚过程中 会判断是否增加了手势 和是否实现了如上的 触摸方法。 至于 UIControl Button 的特殊事件相应，个人认为是在其m文件中实现了上面的4个方法，在这4个方法中做了相关的处理，这里可以从 UIControl 代码中在知道一些内容。 所以如果想自己实现 UIControl Button ，首先要想办法处理好上面的4个方法。 图如下 问题解答 iOS 中 View 的事件到底是怎么传递和响应的？ 如上所描。 为什么 父View 关闭了事件响应时，子View 就无法响应事件？ 因为在事件传递的时，先到父view，当父view无法响应事，直接就跳过了遍历其子view，故只要父类关闭了事件，子 view 就已经没有机会响应事件了。 如何扩大 Button 的点击范围？ 扩大点击范围，无非就是想本来没有点击 btn 但想让 btn 响应事件，那么可以在 hitTest 方法中做适当的操作，当满足xxx条件时，强行返回 btn 来达到最佳点击范围的效果，相关的实现可以自行 Google ，有一些较优雅而简洁的方式。 如何让 父View 和 子View 同时响应同一事件？ 父View 和 子View同时响应同一事件，默认当点击子view时，如果ziview可以处理事件，那么其他父view 是不会响应的，但是在 父view 传到 子view 时我们在 hitTest 方法中是清楚知道的，使用可以在这里做相关的操作便实现了子view 和父view 同时响应事件的效果。 为什么子View 关闭了事件，但其 父View 开启事件的情况下，点击 子View 时，父View 可以响应事件？ 子view关闭了事件，事件的传递是 父view 到子view，在 父view时，父view可以响应，那么会继续访问其 子view是否可以响应，如果此时子view不可以响应，那么他会直接返回 父view，所以 子View 关闭了事件 父View 正常执行事件是必然的。 为什么 子View 是 UIView时，如果没有添加手势，点击子 View时，会由其父View来响应，而 子View 是 UIControl 时，子View 没有添加手势，一样不会由 父View 来响应 这个问题可以见上面的寻找可以响应的 view 来解决，UIControl 实现了如上的 4 大方法，而 UIView 没有实现。 这里其实还有许多内容待挖掘，比如：scrollview 的事件响应等。 参考资料 http://smnh.me/hit-testing-in-ios/ https://zhoon.github.io/ios/2015/04/12/ios-event.html http://southpeak.github.io/blog/2015/03/07/uiresponder/ https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIScrollView_Class/index.html#//apple_ref/doc/uid/TP40006922 https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW2 https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW2]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 - 优化 iOS 程序性能的 24 个方法]]></title>
    <url>%2F2018%2F05%2F23%2F00-%E6%8A%80%E6%9C%AF-iOS%2F%E8%BD%AC-%E4%BC%98%E5%8C%96-iOS-%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E7%9A%84-24-%E4%B8%AA%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[用ARC管理内存 转自 http://www.codeceo.com/article/optimize-ios-program-performance.html ARC(Automatic ReferenceCounting, 自动引用计数)和iOS5一起发布，它避免了最常见的也就是经常是由于我们忘记释放内存所造成的内存泄露。它自动为你管理retain和release的过程，所以你就不必去手动干预了。忘掉代码段结尾的release简直像记得吃饭一样简单。而ARC会自动在底层为你做这些工作。除了帮你避免内存泄露，ARC还可以帮你提高性能，它能保证释放掉不再需要的对象的内存。 现在所有的iOS程序都用ARC了，这条可以忽略。 在正确的地方使用 reuseIdentifier 一个开发中常见的错误就是没有给UITableViewCells， UICollectionViewCells，甚至是UITableViewHeaderFooterViews设置正确的reuseIdentifier。 为了性能最优化，table view用tableView:cellForRowAtIndexPath:为rows分配cells的时候，它的数据应该重用自UITableViewCell。一个table view维持一个队列的数据可重用的UITableViewCell对象。 不使用reuseIdentifier的话，每显示一行table view就不得不设置全新的cell。这对性能的影响可是相当大的，尤其会使app的滚动体验大打折扣。 自iOS6起，除了UICollectionView的cells和补充views，你也应该在header和footer views中使用reuseIdentifiers。 想要使用reuseIdentifiers的话，在一个table view中添加一个新的cell时在data source object中添加这个方法： staticNSString *CellIdentifier = @&quot;Cell&quot;; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier forIndexPath:indexPath]; 这个方法把那些已经存在的cell从队列中排除，或者在必要时使用先前注册的nib或者class创造新的cell。如果没有可重用的cell，你也没有注册一个class或者nib的话，这个方法返回nil。 尽量把views设置为透明 如果你有透明的Views你应该设置它们的opaque属性为YES。 原因是这会使系统用一个最优的方式渲染这些views。这个简单的属性在IB或者代码里都可以设定。 Apple的文档对于为图片设置透明属性的描述是： (opaque)这个属性给渲染系统提供了一个如何处理这个view的提示。如果设为YES，渲染系统就认为这个view是完全不透明的，这使得渲染系统优化一些渲染过程和提高性能。如果设置为NO，渲染系统正常地和其它内容组成这个View。默认值是YES。 在相对比较静止的画面中，设置这个属性不会有太大影响。然而当这个view嵌在scroll view里边，或者是一个复杂动画的一部分，不设置这个属性的话会在很大程度上影响app的性能。 你可以在模拟器中用Debug\Color Blended Layers选项来发现哪些view没有被设置为opaque。目标就是，能设为opaque的就全设为opaque! 这里有一点需要注意，只要是有中文字符的Label，哪怕你设置成不透明，模拟器中这个Label依然会变红，这个猜测是字符绘制的时候出的问题，这个目前没找到好的解决方法。 避免过于庞大的XIB iOS5中加入的Storyboards(分镜)正在快速取代XIB。然而XIB在一些场景中仍然很有用。比如你的app需要适应iOS5之前的设备，或者你有一个自定义的可重用的view,你就不可避免地要用到他们。 如果你不得不XIB的话，使他们尽量简单。尝试为每个Controller配置一个单独的XIB，尽可能把一个View Controller的view层次结构分散到单独的XIB中去。 需要注意的是，当你加载一个XIB的时候所有内容都被放在了内存里，包括任何图片。如果有一个不会即刻用到的view，你这就是在浪费宝贵的内存资源了。Storyboards就是另一码事儿了，storyboard仅在需要时实例化一个view controller. 当家在XIB是，所有图片都被chache，如果你在做OS X开发的话，声音文件也是。Apple在相关文档中的记述是： 当你加载一个引用了图片或者声音资源的nib时，nib加载代码会把图片和声音文件写进内存。在OS X中，图片和声音资源被缓存在named cache中以便将来用到时获取。在iOS中，仅图片资源会被存进named caches。取决于你所在的平台，使用NSImage 或UIImage的imageNamed:方法来获取图片资源。 这个问题我深有体会，用xib写的界面加载速度比直接用代码写的要慢好多。 不要阻塞主线程 永远不要使主线程承担过多。因为UIKit在主线程上做所有工作，渲染，管理触摸反应，回应输入等都需要在它上面完成。 一直使用主线程的风险就是如果你的代码真的block了主线程，你的app会失去反应。 大部分阻碍主进程的情形是你的app在做一些牵涉到读写外部资源的I/O操作，比如存储或者网络。 你可以使用NSURLConnection异步地做网络操作: + (void)sendAsynchronousRequest:(NSURLRequest *)request queue:(NSOperationQueue*)queue completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*))handler 或者使用像AFNetworking这样的框架来异步地做这些操作。 如果你需要做其它类型的需要耗费巨大资源的操作(比如时间敏感的计算或者存储读写)那就用 Grand Central Dispatch，或者&gt;NSOperation和 NSOperationQueues. 下面代码是使用GCD的模板 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // switch to a background thread and perform your expensive operation dispatch_async(dispatch_get_main_queue(), ^{ // switch back to the main thread to update your UI }); }); 发现代码中有一个嵌套的dispatch_async吗？这是因为任何UIKit相关的代码需要在主线程上进行。 在Image Views中调整图片大小 如果要在UIImageView中显示一个来自bundle的图片，你应保证图片的大小和UIImageView的大小相同。在运行中缩放图片是很耗费资源的，特别是UIImageView嵌套在UIScrollView中的情况下。 如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用background &gt;thread，缩放一次，然后在UIImageView中使用缩放后的图片。 选择正确的Collection 学会选择对业务场景最合适的类或者对象是写出能效高的代码的基础。当处理collections时这句话尤其正确。 一些常见collection的总结： Arrays: 有序的一组值。使用index来lookup很快，使用value lookup很慢，插入/删除很慢。Dictionaries: 存储键值对。用键来查找比较快。Sets: 无序的一组值。用值来查找很快，插入/删除很快。因为Set用到了哈希，所以插入删除查找速度比Array快很多 打开gzip压缩 大量app依赖于远端资源和第三方API，你可能会开发一个需要从远端下载XML, JSON, HTML或者其它格式的app。 问题是我们的目标是移动设备，因此你就不能指望网络状况有多好。一个用户现在还在edge网络，下一分钟可能就切换到了3G。不论什么场景，你肯定不想让你的用户等太长时间。 减小文档的一个方式就是在服务端和你的app中打开gzip。这对于文字这种能有更高压缩率的数据来说会有更显著的效用。 好消息是，iOS已经在NSURLConnection中默认支持了gzip压缩，当然AFNetworking这些基于它的框架亦然。像Google App Engine这些云服务提供者也已经支持了压缩输出。 重用和延迟加载(lazy load) Views 更多的view意味着更多的渲染，也就是更多的CPU和内存消耗，对于那种嵌套了很多view在UIScrollView里边的app更是如此。 这里我们用到的技巧就是模仿UITableView和UICollectionView的操作:不要一次创建所有的subview，而是当需要时才创建，当它们完成了使命，把他们放进一个可重用的队列中。 这样的话你就只需要在滚动发生时创建你的views，避免了不划算的内存分配。 创建views的能效问题也适用于你app的其它方面。想象一下一个用户点击一个按钮的时候需要呈现一个view的场景。有两种实现方法： 创建并隐藏这个view当这个screen加载的时候，当需要时显示它； 当需要时才创建并展示。 每个方案都有其优缺点。用第一种方案的话因为你需要一开始就创建一个view并保持它直到不再使用，这就会更加消耗内存。然而这也会使你的app操作更敏感因为当用户点击按钮的时候它只需要改变一下这个view的可见性。 第二种方案则相反-消耗更少内存，但是会在点击按钮的时候比第一种稍显卡顿。 Cache, Cache, 还是Cache!注意你的缓存 一个极好的原则就是，缓存所需要的，也就是那些不大可能改变但是需要经常读取的东西。 我们能缓存些什么呢？一些选项是，远端服务器的响应，图片，甚至计算结果，比如UITableView的行高。 NSURLConnection默认会缓存资源在内存或者存储中根据它所加载的HTTP Headers。你甚至可以手动创建一个NSURLRequest然后使它只加载缓存的值。 下面是一个可用的代码段，你可以可以用它去为一个基本不会改变的图片创建一个NSURLRequest并缓存它： + (NSMutableURLRequest *)imageRequestWithURL:(NSURL *)url { NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url]; request.cachePolicy = NSURLRequestReturnCacheDataElseLoad;// this will make sure the request always returns the cached image request.HTTPShouldHandleCookies = NO; request.HTTPShouldUsePipelining = YES; [request addValue:@&quot;image/*&quot;forHTTPHeaderField:@&quot;Accept&quot;]; return request; } 注意你可以通过 NSURLConnection 获取一个URL request， AFNetworking也一样的。这样你就不必为采用这条tip而改变所有的networking代码了。 如果你需要缓存其它不是HTTP Request的东西，你可以用NSCache。 NSCache和NSDictionary类似，不同的是系统回收内存的时候它会自动删掉它的内容。 权衡渲染方法 在iOS中可以有很多方法做出漂亮的按钮。你可以用整幅的图片，可调大小的图片，或者可以用CALayer， CoreGraphics甚至OpenGL来画它们。当然每个不同的解决方法都有不同的复杂程度和相应的性能。 简单来说，就是用事先渲染好的图片更快一些，因为如此一来iOS就免去了创建一个图片再画东西上去然后显示在屏幕上的程序。问题是你需要把所有你需要用到的图片放到app的bundle里面，这样就增加了体积–这就是使用可变大小的图片更好的地方了:你可以省去一些不必要的空间，也不需要再为不同的元素(比如按钮)来做不同的图。 然而，使用图片也意味着你失去了使用代码调整图片的机动性，你需要一遍又一遍不断地重做他们，这样就很浪费时间了，而且你如果要做一个动画效果，虽然每幅图只是一些细节的变化你就需要很多的图片造成bundle大小的不断增大。 总得来说，你需要权衡一下利弊，到底是要性能能还是要bundle保持合适的大小。 处理内存警告 一旦系统内存过低，iOS会通知所有运行中app。在官方文档中是这样记述: 如果你的app收到了内存警告，它就需要尽可能释放更多的内存。最佳方式是移除对缓存，图片object和其他一些可以重创建的objects的strong references. 幸运的是，UIKit提供了几种收集低内存警告的方法: 在app delegate中使用applicationDidReceiveMemoryWarning:的方法在你的自定义UIViewController的子类(subclass)中覆盖didReceiveMemoryWarning注册并接收 UIApplicationDidReceiveMemoryWarningNotification的通知一旦收到这类通知，你就需要释放任何不必要的内存使用。 例如，UIViewController的默认行为是移除一些不可见的view，它的一些子类则可以补充这个方法，删掉一些额外的数据结构。一个有图片缓存的app可以移除不在屏幕上显示的图片。 这样对内存警报的处理是很必要的，若不重视，你的app就可能被系统杀掉。 然而，当你一定要确认你所选择的object是可以被重现创建的来释放内存。一定要在开发中用模拟器中的内存提醒模拟去测试一下。 当然，现在iOS设备运行内存越来越大，这一点很难出现了。 重用大开销对象 一些objects的初始化很慢，比如NSDateFormatter和NSCalendar。然而，你又不可避免地需要使用它们，比如从JSON或者XML中解析数据。 想要避免使用这个对象的瓶颈你就需要重用他们，可以通过添加属性到你的class里或者创建静态变量来实现。 注意如果你要选择第二种方法，对象会在你的app运行时一直存在于内存中，和单例(singleton)很相似。 下面的代码说明了使用一个属性来延迟加载一个date formatter. 第一次调用时它会创建一个新的实例，以后的调用则将返回已经创建的实例： // in your .h or inside a class extension @property (nonatomic, strong) NSDateFormatter *formatter; // inside the implementation (.m) // When you need, just use self.formatter - (NSDateFormatter *)formatter { if(!_formatter) { _formatter = [[NSDateFormatter alloc] init]; _formatter.dateFormat = @&quot;EEE MMM dd HH:mm:ss Z yyyy&quot;;// twitter date format } return _formatter; } 还需要注意的是，其实设置一个NSDateFormatter的速度差不多是和创建新的一样慢的！所以如果你的app需要经常进行日期格式处理的话，你会从这个方法中得到不小的性能提升。 使用Sprite Sheets Sprite sheet可以让渲染速度加快，甚至比标准的屏幕渲染方法节省内存。 避免反复处理数据 许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要。在内存中操作数据使它们满足你的数据结构是开销很大的。 比如你需要数据来展示一个table view,最好直接从服务器取array结构的数据以避免额外的中间数据结构改变。 类似的，如果需要从特定key中取数据，那么就使用键值对的dictionary。 这一点在处理大量数据的时候极为重要，用空间换时间的方法也许是极好的。 选择正确的数据格式 从app和网络服务间传输数据有很多方案，最常见的就是JSON和XML。你需要选择对你的app来说最合适的一个。 解析JSON会比XML更快一些，JSON也通常更小更便于传输。从iOS5起有了官方内建的JSON deserialization就更加方便使用了。 但是XML也有XML的好处，比如使用SAX来解析XML就像解析本地文件一样，你不需像解析json一样等到整个文档下载完成才开始解析。当&gt;你处理很大的数据的时候就会极大地减低内存消耗和增加性能。 现在基本上都是JSON了。 正确设定背景图片 在View里放背景图片就像很多其它iOS编程一样有很多方法: 使用UIColor的 colorWithPatternImage来设置背景色； 在view中添加一个UIImageView作为一个子View。 如果你使用全画幅的背景图，你就必须使用UIImageView因为UIColor的colorWithPatternImage是用来创建小的重复的图片作为背&gt;景的。这种情形下使用UIImageView可以节约不少的内存： // You could also achieve the same result in Interface Builder UIImageView *backgroundView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;background&quot;]]; [self.view addSubview:backgroundView]; 如果你用小图平铺来创建背景，你就需要用UIColor的colorWithPatternImage来做了，它会更快地渲染也不会花费很多内存： self.view.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@&quot;background&quot;]]; 减少使用Web特性 UIWebView很有用，用它来展示网页内容或者创建UIKit很难做到的动画效果是很简单的一件事。 但是你可能有注意到UIWebView并不像驱动Safari的那么快。这是由于以JIT compilation为特色的Webkit的Nitro Engine的限制。 所以想要更高的性能你就要调整下你的HTML了。第一件要做的事就是尽可能移除不必要的JavaScript，避免使用过大的框架。能只用原生js就更好了。 另外，尽可能异步加载例如用户行为统计script这种不影响页面表达的javascript。 最后，永远要注意你使用的图片，保证图片的符合你使用的大小。使用Sprite sheet提高加载速度和节约内存。 设定Shadow Path 如何在一个View或者一个layer上加一个shadow呢，QuartzCore框架是很多开发者的选择： UIView *view = [[UIView alloc] init]; view.layer.shadowOffset = CGSizeMake(-1.0f, 1.0f); view.layer.shadowRadius = 5.0f; view.layer.shadowOpacity = 0.6; 看起来很简单，对吧。可是，坏消息是使用这个方法也有它的问题… Core Animation不得不先在后台得出你的图形并加好阴影然后才渲染，这开销是很大的。 使用shadowPath的话就避免了这个问题： view.layer.shadowPath = [[UIBezierPath bezierPathWithRect:view.bounds] CGPath];使用shadow path的话iOS就不必每次都计算如何渲染，它使用一个预先计算好的路径。但问题是自己计算path的话可能在某些View中比较困难，且每当view的frame变化的时候你都需要去update shadow path. 我更喜欢用CALayer自己画一个阴影出来，这样可以设置阴影光栅化，节省大量CPU的运算，坏处就是比较消耗内存。因为如果给view的&gt;layer设置光栅化的话整个View都会变得模糊。 优化Table View Table view需要有很好的滚动性能，不然用户会在滚动过程中发现动画的瑕疵。 为了保证table view平滑滚动，确保你采取了以下的措施: 正确使用reuseIdentifier来重用cells 尽量使所有的view opaque，包括cell自身 避免渐变，图片缩放，后台选人 缓存行高 如果cell内现实的内容来自web，使用异步加载，缓存请求结果 使用shadowPath来画阴影 减少subviews的数量 尽量不使用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果 使用正确的数据结构来存储数据 使用rowHeight, sectionFooterHeight和 sectionHeaderHeight来设定固定的高，不要请求delegate 选择正确的数据存储选项当存储大块数据时你会怎么做？ 你有很多选择，比如： 使用NSUerDefaults 使用XML, JSON, 或者 plist 使用NSCoding存档 使用类似SQLite的本地SQL数据库 使用 Core Data NSUserDefaults的问题是什么？虽然它很nice也很便捷，但是它只适用于小数据，比如一些简单的布尔型的设置选项，再大点你就要考虑其它方式了 XML这种结构化档案呢？总体来说，你需要读取整个文件到内存里去解析，这样是很不经济的。使用SAX又是一个很麻烦的事情。 NSCoding？不幸的是，它也需要读写文件，所以也有以上问题。 在这种应用场景下，使用SQLite 或者 Core Data比较好。使用这些技术你用特定的查询语句就能只加载你需要的对象。 在性能层面来讲，SQLite和Core Data是很相似的。他们的不同在于具体使用方法。Core Data代表一个对象的graph model，但SQLite就是一个DBMS。Apple在一般情况下建议使用Core Data，但是如果你有理由不使用它，那么就去使用更加底层的SQLite吧。 如果你使用SQLite，你可以用FMDB(https://GitHub.com/ccgus/fmdb)这个库来简化SQLite的操作，这样你就不用花很多经历了解SQLite的C API了。 使用Autorelease Pool NSAutoreleasePool负责释放block中的autoreleased objects。一般情况下它会自动被UIKit调用。但是有些状况下你也需要手动去创建它。 假如你创建很多临时对象，你会发现内存一直在减少直到这些对象被release的时候。这是因为只有当UIKit用光了autorelease pool的时候memory才会被释放。好消息是你可以在你自己的@autoreleasepool里创建临时的对象来避免这个行为： NSArray *urls = &lt;# An array of file URLs #&gt;; for(NSURL *url in urls) { @autoreleasepool { NSError *error; NSString *fileContents = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error]; /* Process the string, creating and autoreleasing more objects. */ } } 这段代码在每次遍历后释放所有autorelease对象 选择是否缓存图片 常见的从bundle中加载图片的方式有两种，一个是用imageNamed，二是用imageWithContentsOfFile，第一种比较常见一点。 既然有两种类似的方法来实现相同的目的，那么他们之间的差别是什么呢？ imageNamed的优点是当加载时会缓存图片。imageNamed的文档中这么说:这个方法用一个指定的名字在系统缓存中查找并返回一个图片对象如果它存在的话。如果缓存中没有找到相应的图片，这个方法从指定的文档中加载然后缓存并返回这个对象。 相反的，imageWithContentsOfFile仅加载图片。 下面的代码说明了这两种方法的用法: UIImage *img = [UIImage imageNamed:@&quot;myImage&quot;];// caching // or UIImage *img = [UIImage imageWithContentsOfFile:@&quot;myImage&quot;];// no caching 那么我们应该如何选择呢？ 如果你要加载一个大图片而且是一次性使用，那么就没必要缓存这个图片，用imageWithContentsOfFile足矣，这样不会浪费内存来缓存它。 然而，在图片反复重用的情况下imageNamed是一个好得多的选择。 避免日期格式转换 如果你要用NSDateFormatter来处理很多日期格式，应该小心以待。就像先前提到的，任何时候重用NSDateFormatters都是一个好的实践。 然而，如果你需要更多速度，那么直接用C是一个好的方案。Sam Soffes有一个不错的帖子(http://soff.es/how-to-drastically-improve-your-app-with-an-afternoon-and-instruments)里面有一些可以用来解析ISO-8601日期字符串的代码，简单重写一下就可以拿来用了。 嗯，直接用C来搞，看起来不错了，但是你相信吗，我们还有更好的方案！ 如果你可以控制你所处理的日期格式，尽量选择Unix时间戳。你可以方便地从时间戳转换到NSDate: - (NSDate*)dateFromUnixTimestamp:(NSTimeInterval)timestamp { return[NSDate dateWithTimeIntervalSince1970:timestamp]; } 这样会比用C来解析日期字符串还快！需要注意的是，许多web API会以微秒的形式返回时间戳，因为这种格式在javascript中更方便使用。记住用dateFromUnixTimestamp之前除以1000就好了。]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 - 面试中的 10 大排序算法总结]]></title>
    <url>%2F2018%2F05%2F22%2F03-%E6%8A%80%E6%9C%AF-%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E8%BD%AC-%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84-10-%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本文转载自码农网 https://github.com/francistao/LearningNotes 查找和排序算法是算法的入门知识，其经典思想可以用于很多算法当中。因为其实现代码较短，应用较常见。所以在面试中经常会问到排序算法及其相关的问题。但万变不离其宗，只要熟悉了思想，灵活运用也不是难事。一般在面试中最常考的是快速排序和归并排序，并且经常有面试官要求现场写出这两种排序的代码。对这两种排序的代码一定要信手拈来才行。还有插入排序、冒泡排序、堆排序、基数排序、桶排序等。面试官对于这些排序可能会要求比较各自的优劣、各种算法的思想及其使用场景。还有要会分析算法的时间和空间复杂度。通常查找和排序算法的考察是面试的开始，如果这些问题回答不好，估计面试官都没有继续面试下去的兴趣都没了。所以想开个好头就要把常见的排序算法思想及其特点要熟练掌握，有必要时要熟练写出代码。 接下来我们就分析一下常见的排序算法及其使用场景。限于篇幅，某些算法的详细演示和图示请自行寻找详细的参考。 冒泡排序冒泡排序是最简单的排序之一了，其大体思想就是通过与相邻元素的比较和交换来把小的数交换到最前面。这个过程类似于水泡向上升一样，因此而得名。举个栗子，对5,3,8,6,4这个无序序列进行冒泡排序。首先从后向前冒泡，4和6比较，把4交换到前面，序列变成5,3,8,4,6。同理4和8交换，变成5,3,4,8,6,3和4无需交换。5和3交换，变成3,5,4,8,6,3.这样一次冒泡就完了，把最小的数3排到最前面了。对剩下的序列依次冒泡就会得到一个有序序列。冒泡排序的时间复杂度为O(n^2)。 实现代码： /* @Description:&lt;p&gt;冒泡排序算法实现&lt;/p&gt; @author 王旭 @time 2016-3-3 下午8:54:27 */public class BubbleSort { public static void bubbleSort(int[] arr) { if(arr == null || arr.length == 0) return ; for(int i=0; i&amp;lt;arr.length-1; i++) { for(int j=arr.length-1; j&amp;gt;i; j--) { if(arr[j] &amp;lt; arr[j-1]) { swap(arr, j-1, j); } } } } public static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } 选择排序选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。举个栗子，对5,3,8,6,4这个无序序列进行简单选择排序，首先要选择5以外的最小数来和5交换，也就是选择3和5交换，一次排序后就变成了3,5,8,6,4.对剩下的序列一次进行选择和交换，最终就会得到一个有序序列。其实选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。选择排序的时间复杂度为O(n^2) 实现代码： /* @Description:&lt;p&gt;简单选择排序算法的实现&lt;/p&gt; @author 王旭 @time 2016-3-3 下午9:13:35 */public class SelectSort { public static void selectSort(int[] arr) { if(arr == null || arr.length == 0) return ; int minIndex = 0; for(int i=0; i&amp;lt;arr.length-1; i++) { //只需要比较n-1次 minIndex = i; for(int j=i+1; j&amp;lt;arr.length; j++) { //从i+1开始比较，因为minIndex默认为i了，i就没必要比了。 if(arr[j] &amp;lt; arr[minIndex]) { minIndex = j; } } if(minIndex != i) { //如果minIndex不为i，说明找到了更小的值，交换之。 swap(arr, i, minIndex); } } } public static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } 插入排序插入排序不是通过交换位置而是通过比较找到合适的位置插入元素来达到排序的目的的。相信大家都有过打扑克牌的经历，特别是牌数较大的。在分牌时可能要整理自己的牌，牌多的时候怎么整理呢？就是拿到一张牌，找到一个合适的位置插入。这个原理其实和插入排序是一样的。举个栗子，对5,3,8,6,4这个无序序列进行简单插入排序，首先假设第一个数的位置时正确的，想一下在拿到第一张牌的时候，没必要整理。然后3要插到5前面，把5后移一位，变成3,5,8,6,4.想一下整理牌的时候应该也是这样吧。然后8不用动，6插在8前面，8后移一位，4插在5前面，从5开始都向后移一位。注意在插入一个数的时候要保证这个数前面的数已经有序。简单插入排序的时间复杂度也是O(n^2)。 实现代码： /* @Description:&lt;p&gt;简单插入排序算法实现&lt;/p&gt; @author 王旭 @time 2016-3-3 下午9:38:55 */public class InsertSort { public static void insertSort(int[] arr) { if(arr == null || arr.length == 0) return ; for(int i=1; i&amp;lt;arr.length; i++) { //假设第一个数位置时正确的；要往后移，必须要假设第一个。 int j = i; int target = arr[i]; //待插入的 //后移 while(j &amp;gt; 0 &amp;amp;&amp;amp; target &amp;lt; arr[j-1]) { arr[j] = arr[j-1]; j --; } //插入 arr[j] = target; } } } 快速排序快速排序一听名字就觉得很高端，在实际应用当中快速排序确实也是表现最好的排序算法。冒泡排序虽然高端，但其实其思想是来自冒泡排序，冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序是比较和交换小数和大数，这样一来不仅把小数冒泡到上面同时也把大数沉到下面。 举个栗子：对5,3,8,6,4这个无序序列进行快速排序，思路是右指针找比基准数小的，左指针找比基准数大的，交换之。 5,3,8,6,4 用5作为比较的基准，最终会把5小的移动到5的左边，比5大的移动到5的右边。 5,3,8,6,4 首先设置i,j两个指针分别指向两端，j指针先扫描（思考一下为什么？）4比5小停止。然后i扫描，8比5大停止。交换i,j位置。 5,3,4,6,8 然后j指针再扫描，这时j扫描4时两指针相遇。停止。然后交换4和基准数。 4,3,5,6,8 一次划分后达到了左边比5小，右边比5大的目的。之后对左右子序列递归排序，最终得到有序序列。 上面留下来了一个问题为什么一定要j指针先动呢？首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。 快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)。 实现代码： /* @Description:&lt;p&gt;实现快速排序算法&lt;/p&gt; @author 王旭 @time 2016-3-3 下午5:07:29 */public class QuickSort { //一次划分 public static int partition(int[] arr, int left, int right) { int pivotKey = arr[left]; int pivotPointer = left; while(left &amp;lt; right) { while(left &amp;lt; right &amp;amp;&amp;amp; arr[right] &amp;gt;= pivotKey) right --; while(left &amp;lt; right &amp;amp;&amp;amp; arr[left] &amp;lt;= pivotKey) left ++; swap(arr, left, right); //把大的交换到右边，把小的交换到左边。 } swap(arr, pivotPointer, left); //最后把pivot交换到中间 return left; } public static void quickSort(int[] arr, int left, int right) { if(left &amp;gt;= right) return ; int pivotPos = partition(arr, left, right); quickSort(arr, left, pivotPos-1); quickSort(arr, pivotPos+1, right); } public static void sort(int[] arr) { if(arr == null || arr.length == 0) return ; quickSort(arr, 0, arr.length-1); } public static void swap(int[] arr, int left, int right) { int temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; } } 其实上面的代码还可以再优化，上面代码中基准数已经在pivotKey中保存了，所以不需要每次交换都设置一个temp变量，在交换左右指针的时候只需要先后覆盖就可以了。这样既能减少空间的使用还能降低赋值运算的次数。优化代码如下： /* @Description:&lt;p&gt;实现快速排序算法&lt;/p&gt; @author 王旭 @time 2016-3-3 下午5:07:29 */public class QuickSort { /** * 划分 * @param arr * @param left * @param right * @return */ public static int partition(int[] arr, int left, int right) { int pivotKey = arr[left]; while(left &amp;lt; right) { while(left &amp;lt; right &amp;amp;&amp;amp; arr[right] &amp;gt;= pivotKey) right --; arr[left] = arr[right]; //把小的移动到左边 while(left &amp;lt; right &amp;amp;&amp;amp; arr[left] &amp;lt;= pivotKey) left ++; arr[right] = arr[left]; //把大的移动到右边 } arr[left] = pivotKey; //最后把pivot赋值到中间 return left; } /** * 递归划分子序列 * @param arr * @param left * @param right */ public static void quickSort(int[] arr, int left, int right) { if(left &amp;gt;= right) return ; int pivotPos = partition(arr, left, right); quickSort(arr, left, pivotPos-1); quickSort(arr, pivotPos+1, right); } public static void sort(int[] arr) { if(arr == null || arr.length == 0) return ; quickSort(arr, 0, arr.length-1); } } 总结快速排序的思想：冒泡+二分+递归分治，慢慢体会。。。 堆排序堆排序是借助堆来实现的选择排序，思想同简单的选择排序，以下以大顶堆为例。注意：如果想升序排序就使用大顶堆，反之使用小顶堆。原因是堆顶元素需要交换到序列尾部。 首先，实现堆排序需要解决两个问题： 1. 如何由一个无序序列键成一个堆？ 2. 如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？ 第一个问题，可以直接使用线性数组来表示一个堆，由初始的无序序列建成一个堆就需要自底向上从第一个非叶元素开始挨个调整成一个堆。 第二个问题，怎么调整成堆？首先是将堆顶元素和最后一个元素交换。然后比较当前堆顶元素的左右孩子节点，因为除了当前的堆顶元素，左右孩子堆均满足条件，这时需要选择当前堆顶元素与左右孩子节点的较大者（大顶堆）交换，直至叶子节点。我们称这个自堆顶自叶子的调整成为筛选。 从一个无序序列建堆的过程就是一个反复筛选的过程。若将此序列看成是一个完全二叉树，则最后一个非终端节点是n/2取底个元素，由此筛选即可。举个栗子： 49,38,65,97,76,13,27,49序列的堆排序建初始堆和调整的过程如下： 实现代码： /* @Description:&lt;p&gt;堆排序算法的实现，以大顶堆为例。&lt;/p&gt; @author 王旭 @time 2016-3-4 上午9:26:02 */public class HeapSort { /** * 堆筛选，除了start之外，start~end均满足大顶堆的定义。 * 调整之后start~end称为一个大顶堆。 * @param arr 待调整数组 * @param start 起始指针 * @param end 结束指针 */ public static void heapAdjust(int[] arr, int start, int end) { int temp = arr[start]; for(int i=2*start+1; i&amp;lt;=end; i*=2) { //左右孩子的节点分别为2*i+1,2*i+2 //选择出左右孩子较小的下标 if(i &amp;lt; end &amp;amp;&amp;amp; arr[i] &amp;lt; arr[i+1]) { i ++; } if(temp &amp;gt;= arr[i]) { break; //已经为大顶堆，=保持稳定性。 } arr[start] = arr[i]; //将子节点上移 start = i; //下一轮筛选 } arr[start] = temp; //插入正确的位置 } public static void heapSort(int[] arr) { if(arr == null || arr.length == 0) return ; //建立大顶堆 for(int i=arr.length/2; i&amp;gt;=0; i--) { heapAdjust(arr, i, arr.length-1); } for(int i=arr.length-1; i&amp;gt;=0; i--) { swap(arr, 0, i); heapAdjust(arr, 0, i-1); } } public static void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } 希尔排序希尔排序是插入排序的一种高效率的实现，也叫缩小增量排序。简单的插入排序中，如果待排序列是正序时，时间复杂度是O(n)，如果序列是基本有序的，使用直接插入排序效率就非常高。希尔排序就利用了这个特点。基本思想是：先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时再对全体记录进行一次直接插入排序。 举个栗子： 从上述排序过程可见，希尔排序的特点是，子序列的构成不是简单的逐段分割，而是将某个相隔某个增量的记录组成一个子序列。如上面的例子，第一堂排序时的增量为5，第二趟排序的增量为3。由于前两趟的插入排序中记录的关键字是和同一子序列中的前一个记录的关键字进行比较，因此关键字较小的记录就不是一步一步地向前挪动，而是跳跃式地往前移，从而使得进行最后一趟排序时，整个序列已经做到基本有序，只要作记录的少量比较和移动即可。因此希尔排序的效率要比直接插入排序高。 希尔排序的分析是复杂的，时间复杂度是所取增量的函数，这涉及一些数学上的难题。但是在大量实验的基础上推出当n在某个范围内时，时间复杂度可以达到O(n^1.3)。 实现代码： /* @Description:&lt;p&gt;希尔排序算法实现&lt;/p&gt; @author 王旭 @time 2016-3-3 下午10:53:55 */public class ShellSort { /** * 希尔排序的一趟插入 * @param arr 待排数组 * @param d 增量 */ public static void shellInsert(int[] arr, int d) { for(int i=d; i&amp;lt;arr.length; i++) { int j = i - d; int temp = arr[i]; //记录要插入的数据 while (j&amp;gt;=0 &amp;amp;&amp;amp; arr[j]&amp;gt;temp) { //从后向前，找到比其小的数的位置 arr[j+d] = arr[j]; //向后挪动 j -= d; } if (j != i - d) //存在比其小的数 arr[j+d] = temp; } } public static void shellSort(int[] arr) { if(arr == null || arr.length == 0) return ; int d = arr.length / 2; while(d &amp;gt;= 1) { shellInsert(arr, d); d /= 2; } } } 归并排序归并排序是另一种不同的排序方法，因为归并排序使用了递归分治的思想，所以理解起来比较容易。其基本思想是，先递归划分子问题，然后合并结果。把待排序列看成由两个有序的子序列，然后合并两个子序列，然后把子序列看成由两个有序序列。。。。。倒着来看，其实就是先两两合并，然后四四合并。。。最终形成有序序列。空间复杂度为O(n)，时间复杂度为O(nlogn)。 举个栗子： 实现代码： /* @Description:&lt;p&gt;归并排序算法的实现&lt;/p&gt; @author 王旭 @time 2016-3-4 上午8:14:20 */public class MergeSort { public static void mergeSort(int[] arr) { mSort(arr, 0, arr.length-1); } /** * 递归分治 * @param arr 待排数组 * @param left 左指针 * @param right 右指针 */ public static void mSort(int[] arr, int left, int right) { if(left &amp;gt;= right) return ; int mid = (left + right) / 2; mSort(arr, left, mid); //递归排序左边 mSort(arr, mid+1, right); //递归排序右边 merge(arr, left, mid, right); //合并 } /** * 合并两个有序数组 * @param arr 待合并数组 * @param left 左指针 * @param mid 中间指针 * @param right 右指针 */ public static void merge(int[] arr, int left, int mid, int right) { //[left, mid] [mid+1, right] int[] temp = new int[right - left + 1]; //中间数组 int i = left; int j = mid + 1; int k = 0; while(i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= right) { if(arr[i] &amp;lt;= arr[j]) { temp[k++] = arr[i++]; } else { temp[k++] = arr[j++]; } } while(i &amp;lt;= mid) { temp[k++] = arr[i++]; } while(j &amp;lt;= right) { temp[k++] = arr[j++]; } for(int p=0; p&amp;lt;temp.length; p++) { arr[left + p] = temp[p]; } } } 计数排序如果在面试中有面试官要求你写一个O(n)时间复杂度的排序算法，你千万不要立刻说：这不可能！虽然前面基于比较的排序的下限是O(nlogn)。但是确实也有线性时间复杂度的排序，只不过有前提条件，就是待排序的数要满足一定的范围的整数，而且计数排序需要比较多的辅助空间。其基本思想是，用待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序序列。 实现代码： /* @Description:&lt;p&gt;计数排序算法实现&lt;/p&gt; @author 王旭 @time 2016-3-4 下午4:52:02 */public class CountSort { public static void countSort(int[] arr) { if(arr == null || arr.length == 0) return ; int max = max(arr); int[] count = new int[max+1]; Arrays.fill(count, 0); for(int i=0; i&amp;lt;arr.length; i++) { count[arr[i]] ++; } int k = 0; for(int i=0; i&amp;lt;=max; i++) { for(int j=0; j&amp;lt;count[i]; j++) { arr[k++] = i; } } } public static int max(int[] arr) { int max = Integer.MIN_VALUE; for(int ele : arr) { if(ele &amp;gt; max) max = ele; } return max; } } 桶排序桶排序算是计数排序的一种改进和推广，但是网上有许多资料把计数排序和桶排序混为一谈。其实桶排序要比计数排序复杂许多。 对桶排序的分析和解释借鉴这位兄弟的文章（有改动）：http://hxraid.iteye.com/blog/647759 桶排序的基本思想： 假设有一组长度为N的待排关键字序列K[1….n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]&#8230;.B[M]中的全部内容即是一个有序序列。bindex=f(key) 其中，bindex 为桶数组B的下标(即第bindex个桶), k为待排序列的关键字。桶排序之所以能够高效，其关键在于这个映射函数，它必须做到：如果关键字k1&lt;k2，那么f(k1)&lt;=f(k2)。也就是说B(i)中的最小数据都要大于B(i-1)中最大数据。很显然，映射函数的确定与数据本身的特点有很大的关系。 举个栗子： 假如待排序列K= {49、 38 、 35、 97 、 76、 73 、 27、 49 }。这些数据全部在1—100之间。因此我们定制10个桶，然后确定映射函数f(k)=k/10。则第一个关键字49将定位到第4个桶中(49/10=4)。依次将所有关键字全部堆入桶中，并在每个非空的桶中进行快速排序后得到如图所示。只要顺序输出每个B[i]中的数据就可以得到有序序列了。 桶排序分析： 桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，希尔排序中的子序列，归并排序中的子问题，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。 对N个关键字进行桶排序的时间复杂度分为两个部分： (1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。 (2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为 ∑ O(Ni*logNi) 。其中Ni 为第i个桶的数据量。 很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要尽量做到下面两点： (1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。 (2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。 对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为： O(N)+O(M(N/M)log(N/M))=O(N+N(logN-logM))=O(N+NlogN-N*logM) 当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。 总结： 桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。 当然桶排序的空间复杂度 为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。 实现代码： /* @Description:&lt;p&gt;桶排序算法实现&lt;/p&gt; @author 王旭 @time 2016-3-4 下午7:39:31 */public class BucketSort { public static void bucketSort(int[] arr) { if(arr == null &amp;amp;&amp;amp; arr.length == 0) return ; int bucketNums = 10; //这里默认为10，规定待排数[0,100) List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; buckets = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;(); //桶的索引 for(int i=0; i&amp;lt;10; i++) { buckets.add(new LinkedList&amp;lt;Integer&amp;gt;()); //用链表比较合适 } //划分桶 for(int i=0; i&amp;lt;arr.length; i++) { buckets.get(f(arr[i])).add(arr[i]); } //对每个桶进行排序 for(int i=0; i&amp;lt;buckets.size(); i++) { if(!buckets.get(i).isEmpty()) { Collections.sort(buckets.get(i)); //对每个桶进行快排 } } //还原排好序的数组 int k = 0; for(List&amp;lt;Integer&amp;gt; bucket : buckets) { for(int ele : bucket) { arr[k++] = ele; } } } /** * 映射函数 * @param x * @return */ public static int f(int x) { return x / 10; } } 基数排序基数排序又是一种和前面排序方式不同的排序方式，基数排序不需要进行记录关键字之间的比较。基数排序是一种借助多关键字排序思想对单逻辑关键字进行排序的方法。所谓的多关键字排序就是有多个优先级不同的关键字。比如说成绩的排序，如果两个人总分相同，则语文高的排在前面，语文成绩也相同则数学高的排在前面。。。如果对数字进行排序，那么个位、十位、百位就是不同优先级的关键字，如果要进行升序排序，那么个位、十位、百位优先级一次增加。基数排序是通过多次的收分配和收集来实现的，关键字优先级低的先进行分配和收集。 举个栗子： 实现代码： /* @Description:&lt;p&gt;基数排序算法实现&lt;/p&gt; @author 王旭 @time 2016-3-4 下午8:29:52 */public class RadixSort { public static void radixSort(int[] arr) { if(arr == null &amp;amp;&amp;amp; arr.length == 0) return ; int maxBit = getMaxBit(arr); for(int i=1; i&amp;lt;=maxBit; i++) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; buf = distribute(arr, i); //分配 collecte(arr, buf); //收集 } } /** * 分配 * @param arr 待分配数组 * @param iBit 要分配第几位 * @return */ public static List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; distribute(int[] arr, int iBit) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; buf = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;(); for(int j=0; j&amp;lt;10; j++) { buf.add(new LinkedList&amp;lt;Integer&amp;gt;()); } for(int i=0; i&amp;lt;arr.length; i++) { buf.get(getNBit(arr[i], iBit)).add(arr[i]); } return buf; } /** * 收集 * @param arr 把分配的数据收集到arr中 * @param buf */ public static void collecte(int[] arr, List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; buf) { int k = 0; for(List&amp;lt;Integer&amp;gt; bucket : buf) { for(int ele : bucket) { arr[k++] = ele; } } } /** * 获取最大位数 * @param x * @return */ public static int getMaxBit(int[] arr) { int max = Integer.MIN_VALUE; for(int ele : arr) { int len = (ele+&quot;&quot;).length(); if(len &amp;gt; max) max = len; } return max; } /** * 获取x的第n位，如果没有则为0. * @param x * @param n * @return */ public static int getNBit(int x, int n) { String sx = x + &quot;&quot;; if(sx.length() &amp;lt; n) return 0; else return sx.charAt(sx.length()-n) - &apos;0&apos;; } } 总结在前面的介绍和分析中我们提到了冒泡排序、选择排序、插入排序三种简单的排序及其变种快速排序、堆排序、希尔排序三种比较高效的排序。后面我们又分析了基于分治递归思想的归并排序还有计数排序、桶排序、基数排序三种线性排序。我们可以知道排序算法要么简单有效，要么是利用简单排序的特点加以改进，要么是以空间换取时间在特定情况下的高效排序。但是这些排序方法都不是固定不变的，需要结合具体的需求和场景来选择甚至组合使用。才能达到高效稳定的目的。没有最好的排序，只有最适合的排序。 下面就总结一下排序算法的各自的使用场景和适用场合。 1. 从平均时间来看，快速排序是效率最高的，但快速排序在最坏情况下的时间性能不如堆排序和归并排序。而后者相比较的结果是，在n较大时归并排序使用时间较少，但使用辅助空间较多。 2. 上面说的简单排序包括除希尔排序之外的所有冒泡排序、插入排序、简单选择排序。其中直接插入排序最简单，但序列基本有序或者n较小时，直接插入排序是好的方法，因此常将它和其他的排序方法，如快速排序、归并排序等结合在一起使用。 3. 基数排序的时间复杂度也可以写成O(d*n)。因此它最使用于n值很大而关键字较小的的序列。若关键字也很大，而序列中大多数记录的最高关键字均不同，则亦可先按最高关键字不同，将序列分成若干小的子序列，而后进行直接插入排序。 4. 从方法的稳定性来比较，基数排序是稳定的内排方法，所有时间复杂度为O(n^2)的简单排序也是稳定的。但是快速排序、堆排序、希尔排序等时间性能较好的排序方法都是不稳定的。稳定性需要根据具体需求选择。 5. 上面的算法实现大多数是使用线性存储结构，像插入排序这种算法用链表实现更好，省去了移动元素的时间。具体的存储结构在具体的实现版本中也是不同的。 附：基于比较排序算法时间下限为O(nlogn)的证明： 基于比较排序下限的证明是通过决策树证明的，决策树的高度Ω（nlgn），这样就得出了比较排序的下限。 首先要引入决策树。 首先决策树是一颗二叉树，每个节点表示元素之间一组可能的排序，它予以京进行的比较相一致，比较的结果是树的边。 先来说明一些二叉树的性质，令T是深度为d的二叉树，则T最多有2^片树叶。 具有L片树叶的二叉树的深度至少是logL。 所以，对n个元素排序的决策树必然有n!片树叶（因为n个数有n!种不同的大小关系），所以决策树的深度至少是log(n!)，即至少需要log(n!)次比较。 而 log(n!)=logn+log(n-1)+log(n-2)+&#8230;+log2+log1 &gt;=logn+log(n-1)+log(n-2)+&#8230;+log(n/2) &gt;=(n/2)log(n/2) &gt;=(n/2)logn-n/2 =O(nlogn) 所以只用到比较的排序算法最低时间复杂度是O(nlogn)。 参考资料： 《数据结构》 严蔚敏 吴伟民 编著 桶排序分析：http://hxraid.iteye.com/blog/647759 部分排序算法分析与介绍：http://www.cnblogs.com/weixliu/archive/2012/12/23/2829671.html var strBatchView = 37731]]></content>
      <categories>
        <category>03-技术-计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nots]]></title>
    <url>%2F2018%2F02%2F26%2F02-%E6%8A%80%E6%9C%AF-%E5%89%8D%E7%AB%AF%2FNots%2F</url>
    <content type="text"><![CDATA[一些名词 HTTP 超文本传输协议（HyperText Transfer Protocol) TCP 传输控制协议（Transmission Control Protocol) IP 网际协议（Internet Protocol) HTML 超文本标记语言（HyperText Markup Language) CSS 层叠样式表(Cascading Style Sheets) URI 统一资源标识符（Uniform Resource Identifier) URL 统一资源定位符（Uniform Resource Locator) URN 统一资源名称（Uniform Resource Name) 应用层 HTTP ↓ 表示层 ↓ 会话层 ↓ 传输层 TCP ↓ 网络层 IP ↓ 数据链路层 ↓ 物理层 HTML 标签 http://www.w3school.com.cn/tags/index.asp 注释标签 br 标签 换行标签 hr 分割线标签 p 段落标签 h1…h6 标题标签，一个界面最多一个h1标签，搜索引擎搜索问题 font 文本标签 html 标签，root标签， body 主体标签，给用户看的内容在这里面，浏览器也需看 head head标签，只要是给浏览器看的内容 title 标签标签，网站名称 strong （文本标签 font 的加粗样式，也可以使用 b ，b只是简单的加粗，但strong有更好的着重意义，推荐使用 strong） em （文本标签 font 的斜体样式，也可以使用 i ，i只是简单的斜体，但em有更好的着重意义，推荐使用 em） del (删除线标签 也可以使用 s 推荐使用 del) ins （下划线标签 也可以使用 u 推荐使用 ins ） a （超链接 title 提示文字） img （图片标签，可以设置加载失败的占位文字 提醒文字等 height width等，路径使用..表示到上一个文件夹） 锚点id 在标签中添加锚点，可以在超链接中设置点击超链接到指定的锚点 特殊符号 和OC中的转义字符一样，需要特殊处理，需注意下 列表 ul li 表示无序列表，type可以设置前面的图标类型 列表 ol li 有序列表，可以使用type设置编号类型 start表示从xx开始 列表 dl 自定义列表 dt标题 dd标签介绍 embed 音乐标签 marquee 滚动标签 文字（图片等）跑马灯自动滚动 abbr 简写标签，在移动到此内容时，自动显示详细内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt; &lt;html&gt;&lt;/html&gt; &lt;head&gt;&lt;/head&gt; 浏览器看的 &lt;body&gt;&lt;/body&gt; 主体 用户看的内容 &lt;title&gt;&lt;/title&gt; 网站标题 &lt;p&gt;&lt;/p&gt; 段落 &lt;strong&gt;&lt;/strong&gt; 强调加粗黑体,在阅读时会强调着用，b 只是简单的加粗黑体 &lt;em&gt;&lt;/em&gt; 着重 i也可以，建议使用 em &lt;abbr&gt;&lt;/abbr&gt; 简写 &lt;!----&gt; 注释 &lt;ins&gt;&lt;/ins&gt; 下划线 u也可以 &lt;del&gt;&lt;/del&gt; 删除 s也可以 &lt;h1&gt;&lt;/h1&gt; 标题 &lt;h6&gt;&lt;/h6&gt; 标题 &lt;br&gt;换行 &lt;hr&gt; 分割线 &lt;address&gt;&lt;/address&gt; 作者信息 &lt;font size=&quot;30&quot; color=&quot;red&quot;&gt;font &lt;/font&gt; &lt;img scr=&quot;sss.png&quot; width=&quot;100&quot; height=&quot;200&quot; alt=&quot;林志玲的图片&quot; title=&quot;我是图片&quot;&gt; alt 加载失败时是提示文字 加强体验 title 提醒文本 鼠标移动到图片上时 height width 按照比例变化 路径问题 ../ 到上一家目录 目前在当前html文件的目录 开始寻找图片。 &lt;a href=&quot;www.xxx.com&quot; title=&quot;提醒文本&quot;&gt;&lt;/a&gt; &lt;a target=&quot;_parent&quot;&gt;&lt;/a&gt; &lt;a target=&quot;_blank&quot;&gt;&lt;/a&gt; 打开新的界面 当前界面不会关闭 &lt;a target=&quot;_self&quot;&gt;&lt;/a&gt; 在当前界面打开，会覆盖调 默认 &lt;a target=&quot;_top&quot;&gt;&lt;/a&gt; 在不知道具体到xxx界面时 href=&quot;#&quot; 不需跳转 在当前界面就可以了，以后再补充具体怎么跳转。 锚点，可以让滚动到界面的指定位置 定义锚点 &lt;p id=&quot;top&quot;&gt;&lt;/p&gt; 超链接点击就到锚点 &lt;a href=&quot;#top&quot;&gt; 去顶部啊啊啊啊 &lt;/a&gt; 特殊符号(转移字符需特殊处理下才可以 可以自行查看和补充) 空格 &amp;nbsp; 列表 无序列表（没有重要区分） &lt;ul&gt; &lt;li&gt;001&lt;/li&gt; &lt;li&gt;002&lt;/li&gt; &lt;li&gt;003&lt;/li&gt; &lt;li&gt;004&lt;/li&gt; &lt;li&gt;005&lt;/li&gt; &lt;/ul&gt; type 表示前面的符号类型 有序列表（有重要区分 12345） &lt;ol&gt; &lt;li&gt;001&lt;/li&gt; &lt;li&gt;002&lt;/li&gt; &lt;li&gt;003&lt;/li&gt; &lt;li&gt;004&lt;/li&gt; &lt;li&gt;005&lt;/li&gt; &lt;/ol&gt; type 1 A i ..... start 从xxx开始 自定义列表 &lt;dl&gt; &lt;dt&gt;dt 小标题&lt;/dt&gt; &lt;dd&gt;dd 解释标题&lt;/dd&gt; &lt;/dl&gt; 音乐标签 &lt;embed src=&quot;1.mp3&quot; hiden=&quot;true&quot;&gt;&lt;/embed&gt; 滚动标签 （可查看其他属性） marquee 块标签 div p h1-h6 ul li 不设置宽度时默认和父标签的宽度一样，而且会独立站一行。 块转行 display：inLine 块转行内块 display：inline-block 行内标签 span a strong em del ins 连续布局，可以一行存放n个标签，自动布局。不可以自定义size， 行转块 display：block 行转行内块 display：inline-block 行内块标签 img input 连续布局，可以一行存放n个标签，可以自定义size， 标签css的继承性 必须是嵌套关系 文字颜色 文字大小 文字粗细 整体样式 字体风格 行高 文字属性都可以继承 h1 可以继承文字大小，但会自动乘一个系数，所以看为不可以继承 a 链接 不可继承颜色color css样式优先级 默认 &lt; 标签样式 &lt; class &lt; id样式 &lt; 行内样式表 可以使用 !important 强制设置为重要 继承的的优先级最低 CSS HTML 结构 CSS 内嵌写法 / 外链写法 12345&lt;style type=&quot;text/css&quot;&gt; ... &lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;1.css&quot;&gt; JavaScript 内嵌写法 / 外链写法 1234&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt; JavaScript 的几种调试方式 12345alert(&apos;ssssss&apos;); // alert 确定按钮confirm(&apos;s&apos;); // alert + 确定 和 取消按钮console.log(&apos;2&apos;); // 控制台输出prompt(&apos;sss&apos;); // 弹出一个用户输入框 搜集消息document.write(&apos;ssss&apos;) ; // 在页面输入内容]]></content>
      <categories>
        <category>02-技术-前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS第三方库背后的原理和简单使用]]></title>
    <url>%2F2017%2F11%2F27%2F00-%E6%8A%80%E6%9C%AF-iOS%2FiOS%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E8%83%8C%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在我们平时的开发中，或多或少都会使用到一些开源库，在小公司甚至大量依赖第三方，那么我们对一些知名第三方是否有必要了解下它背后的原理呢，甚至应该阅读一些知名第三方的底层实现和原理，下面就简单介绍一些第三方的实现原理和简单的使用方法吧。 MJExtension MJExtension 基本使用json -&gt; Model12345// json -&gt; Model + (instancetype)mj_objectWithKeyValues:(id)keyValues;// json -&gt; Model 数组+ (NSMutableArray *)mj_objectArrayWithKeyValuesArray:(NSArray *)keyValuesArray; Model -&gt; json123456789101112/** * 转换为JSON Data */- (NSData *)mj_JSONData;/** * 转换为字典或者数组 */- (id)mj_JSONObject;/** * 转换为JSON 字符串 */- (NSString *)mj_JSONString; 其他12345678910111213141516171819202122/*数组中需要转换的模型*/+ (NSDictionary *)mj_objectClassInArray&#123; return @&#123; @"array1": BMImageInfoModel.class, &#125;;&#125;/*key 重命名 属性名为key : json 中的key为 value */+ (NSDictionary *)mj_replacedKeyFromPropertyName &#123; return @&#123; @"desc": @"description", @"ID": @"id", &#125;;&#125;/*json -&gt; Model 完成时*/- (void)mj_keyValuesDidFinishConvertingToObject &#123;&#125;/*Model -&gt; json 完成时*/- (void)mj_objectDidFinishConvertingToKeyValues &#123;&#125; 原理 我们知道 json-&gt;Model时，其实就是在dict中取对应的值然后设置到Model中， obj.name = dict[@&quot;name&quot;]; 我们知道Model中的属性一般是非常多的，而且一个项目中Model也是非常多，而且Model中的属性随时可能变动，像上面的赋值代码就会成千上万，而且非常不好维护，那么我们有没有快捷的方法解决好这些问题呢？MJExtension就是为我们解决了这些问题的一个库而且可以扩展许多功能。不管你有多少属性只需要mj_objectWithKeyValues这样一行代码完美搞定。 在上面的分析中我们肯定要想办法动态的获取Model中的属性，同时去dict中取相应的值设置给Model相应的属性，其实MJExtension的核心功能就是解决这个问题，MJExtension使用Runtime动态地的获取模型的属性，然后动态的在dict中取相应的值设置给Model，当然其中做了特别多的优化和扩展。 动态获取模型的属性 NSObject+MJKeyValue.m 文件 87 行的如下代码 1[clazz mj_enumerateProperties:^(MJProperty *property, BOOL *stop)... 使用KVC赋值 NSObject+MJKeyValue.m 文件 189 行的如下代码 12// 3.赋值[property setValue:value forObject:self]; 此方法内部如下（NSObject+MJKeyValue.m 文件78行）： 12345678/** * 设置成员变量的值 */- (void)setValue:(id)value forObject:(id)object&#123; if (self.type.KVCDisabled || value == nil) return; [object setValue:value forKey:self.name];&#125; 基本功能的代码基本就是上面的代码段，当然有大量的优化和扩展防错等功能未展开。 支持模型的继承属性，比如：Model的父类有一个name属性，那么在转换时会支持name属性的获取 对一些特殊类型做了特殊处理，比如：BOOL类型等 支持模型嵌套模型转换 支持模型嵌套数组转换，如果数组中的对象是模型需实现相应协议 支持指定属性名称支持转换和指定属性名称不支持转换 只对属性有效 支持readonly属性 对Model的属性做了缓存大幅度增加性能 添加一些扩展方法，Model-&gt;jsonData, Model-&gt;json, Model-&gt;dict json(NSData dict，NSString)-&gt;模型 json(NSData arr，NSString)-&gt;模型数组 获取到模型的属性列表时做缓存 内部使用KVC赋值 YYModelYYCacheUITableView-FDTemplateLayoutCell]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS面试题笔记]]></title>
    <url>%2F2017%2F11%2F19%2FiOS%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[写一个标准宏 MIN/MAX 利用 __typeof__ 重新声明 2 个相同类型的变量，在把相关的值赋值给新的变量，在进行比较，这样可以排除其他的各种优先级问题。 12#define kMIN(a,b) (&#123;__typeof__(a) __a__COUNTER__ = (a);__typeof__(b) __b__COUNTER__ = (b);(__a__COUNTER__) &lt; (__b__COUNTER__) ? (__a__COUNTER__) : (__b__COUNTER__);&#125;)#define kMAX(a,b) (&#123;__typeof__(a) __a__COUNTER__ = (a);__typeof__(b) __b__COUNTER__ = (b);(__a__COUNTER__) &gt; (__b__COUNTER__) ? (__a__COUNTER__) : (__b__COUNTER__);&#125;) 圆角卡顿问题 卡顿的原因？ 屏幕显示图像的原理是从上到下一行行继续扫描【当扫描完一行时发出一个HSyncx信号，扫描完整个屏幕时发出一个VSyncx信号】 当收到VSyncx信号时 CPU需把相关需要显示的内容交给GPU来渲染，渲染好了交到帧缓冲区准备显示，在下一帧显示的时候直接到帧缓冲区取出显示即可以， 理想状态的这样的，但是如果CPU或者GPU任务繁重，在需要显示的时候还没有准备好，就无法显示，会导致本来应该显示新的内容还会停留在上一帧， 可能造成跳帧的情况，卡顿就产生了，使用卡顿的本质就是 CPU 和 GPU任务未完成导致的。 圆角为什么可能导致卡顿呢？ 正如【 卡顿的原因？】所诉，为了尽量不卡顿，所以推出多个帧缓冲区的概念，正所谓鱼和熊掌不可兼得，多个帧缓冲区虽然可以解决一些卡顿问题， 但帧缓冲区之间切换又是一个特别耗性能的问题，在设置圆角时【主要是 masksToBounds masksToBounds】就是在其他的帧缓冲区处理的【称：离屏渲染】 如果一个屏幕上太多圆角时就会导致频繁的帧缓冲区切换，消耗太多的 GPU性能，导致在收到VSyncx信号到显示 GPU没有处理完成，导致卡顿的产生。 那么怎么解决呢？ 正如【圆角为什么可能导致卡顿呢？】中所诉，GPU太忙了，但此时CPU可能比较闲，那么我们是否可以想办法把一些任务分配给CPU来处理呢， 通常的处理方案就是如此： 预先用CPU，构建圆角路径贝塞尔曲线UIBezierPath，用原来的图片填充进圆角路径，获得天然的自带圆角透明的bitmap数据UIImage，从而直接交给GPU进行普通渲染【不使用 masksToBounds masksToBounds】。 代码如下： 123456789101112131415161718192021222324@implementation UIImage (BMKit)- (instancetype)_imageAddCornerWithRadius:(CGFloat)radius size:(CGSize)size &#123; //0、获取 size CGRect rect = CGRectMake(0, 0, size.width, size.height); //1、开启图形上下文 UIGraphicsBeginImageContextWithOptions(size, NO, [UIScreen mainScreen].scale); //2、获取当前的图形上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); //3、创建路径 path UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:UIRectCornerAllCorners cornerRadii:CGSizeMake(radius, radius)]; //4、把路径添加上下文 CGContextAddPath(ctx,path.CGPath); //5、剪切 CGContextClip(ctx); //6、绘制图片 [self drawInRect:rect]; //7、设置填充的样式 CGContextDrawPath(ctx, kCGPathFillStroke); //8、取得图片 UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); //9、关闭图形上下文 UIGraphicsEndImageContext(); return newImage;&#125; 是不是全部用CPU来处理就彻底解决了圆角问题呢？ 当然不是的，如果我们全部都给CPU来处理，CPU的任务重了同样可能造成卡顿问题，通常情况下： 1、小量圆角直接使用 masksToBounds masksToBounds 即可，因为如果使用CPU来处理可能反而适得其反。 2、较多圆角时使用CPU来处理可以很好的处理卡顿问题，同时可以集合一些缓存策略。 3、如果实在无法解决时可以使用异步渲染的方式来处理参考：AsyncDisplayKit demo - https://github.com/liangdahong/iOS-Interview-Notes/tree/master/002-CornerRadius-Demo0 003-响应链 触摸事件的传递和响应过程 在触摸事件的处理过程中会有 事件传递 和 事件响应过程，首先当用户触摸屏幕时，会从上向下 (UIApplication-&gt;keyWindow-&gt;vc-&gt;View-&gt;View1... 会判断范围是否包含，是否开启了响应，是否设置了透明度等) 找到最合适的对象，当找到最合适的View时会由下向上 (...View1-&gt;keyWindow-&gt; View-&gt; vc-&gt; keyWindow-&gt; UIApplication 会判断是否加了相关处理的方法) 找最合适响应的对象。 参考 http://blog.flight.dev.qunar.com/2016/10/28/ios-event-mechanism-summary/ http://www.jianshu.com/p/2e074db792ba Runloop Runloop 就是为了应用在有事做的时候干活，没事做时休眠，具体是使用 内核函数 mach_msg Mach_port来实现线程的休眠，和激活。 runloop默认是没有创建的，只可以获取，懒加载的形式，runloop 和 线程是一个哈希关系，线程是 k，runloop 是 v，子线程中只可以获取当前线程的runloop或者max runloop。 Runloop里分 mode 模式，每一个模式里面有 soure0 soure1 timer obje 来处理。循环处理相应模式下的任务，在切换模式的时候被切换的模式下的任务就会暂停，比如：定时器默认情况下载 scrollView 跟踪的时候就暂停了。 1、定时器在 scrollView 跟踪也处理可以使用 把定时器加到相应的模式下，或者直接标记为 COMM ，COMM不是一个具体的模式，只是把相应的 item 加到 COMM 中。又因为 【默认模式】和 【跟踪模式】都是 COMM 所以一举两得。2、线程保活，需要处理 runloop，同时需要指定模式run起来，还需要 while 和 flag 来处理是否关闭处理，【注意使用 run 开启 runloop 是无法关闭的】3、唤醒，是系统内核唤醒的；休眠，是系统内核让线程休眠的R 内存管理 arc : 其实是编译器特性，编译器在编译的时候主动加上了内存管理的代码。mrc: 在 arc 之前是程序员手动管理内存。oc 的内存回收机制使用了引用计数来处理的，当引用计数=0 的时候就释放掉对象，引用计数是在 对象的 isa 中存起来的，具体释放是在 release 的时候判断 引用计数是不是为0了，如果是就释放。 内存布局情况： 保留【系统使用】 代码段 数据段【。。。】 s s s s s s autorelease 和 自动释放池。 自动释放池，其实底层用到了【 c++结构体 4096 ，stack，双向链表】来实现的，在使用 &gt;autoreleasepool 的时候底层会在 autoreleasepool 开始的时候 做push 操作，【push操作其实就&gt;是在加入一个标记，然后每调 autolease 方法就会把此对象的地址加到 C++结构体的指定位置上，在 autoreleasepool 结束的时候 调用 pop 方法，底层其实就是 从这个位置向后处理刚才加到 c++结构体指定位置的对象执行 release 操作，当到 标记的地方就结束，这里就用到了stack，同时如果如果autolease的对象比较多的时候，这里会把 c++结构体 穿起来做成 双向链表，【在push的时候如果已经满了就去链表的下一个对象存储，在 pop 操作的时候如果一直没有找到标记就向上一个中去继续查，直到找到标记为止】】 同时 runloop 循环中也牵涉到 autoreleasepool 1、在进入 runloop 的时候 push 操作， …工作… 2、在休眠之前执行执行 pop 然后执行 push =====休息时间===== 3、唤醒 …工作.. -&gt;2 或者 5 5、退出 pop 所以如果所以 autoreleasepool 方法中的 使用autorelease的临时变量不一定在离开方法就释放。 001 dyld 装载app的可执行文件，同时加载依赖的动态库，然后通知 runtime 来处理。 1234567891011121314151617181920212223// 中间代码// cd 到指定的m文件 clang -emit-llvm -S xxx.m// C++ 代码// cd 到指定的m文件// xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc xxx.m// 看汇编代码// 断点看汇编代码： -&gt; Debug -&gt; Work flow -&gt; Always Show Disassembly// 直接看汇编代码： 选中m文件 -&gt; Prudect -&gt; Perform Action -&gt; Assembly(lldb) p/x per-&gt;isa(Class) $13 = 0x001d800100003631 BMPerson(lldb) p/x clas(Class) $14 = 0x0000000100003630 BMPerson （（ per-&gt;isa）&amp; 0x00007ffffffffff8ULL） = 0x0000000100003630 （（ 0x001d800100003631）&amp; 0x00007ffffffffff8ULL） = 0x0000000100003630 # define ISA_MASK 0x00007ffffffffff8ULL KVO]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之GCD详解]]></title>
    <url>%2F2017%2F10%2F30%2F00-%E6%8A%80%E6%9C%AF-iOS%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8BGCD%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[队列 dispatch_queue_t并行队列 其任务是随机顺序执行，完全由系统处理。 全局并行队列 1dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 自定义创建并行队列 1dispatch_queue_create("com.idhong.concurrentQueue", DISPATCH_QUEUE_CONCURRENT); 串行队列 其任务是按照先后顺序执行 全局串行队列 (主线程队列) 1dispatch_get_main_queue(); 自定义创建串行队列 12dispatch_queue_create("com.idhong.concurrentQueue", DISPATCH_QUEUE_SERIAL);dispatch_queue_create("com.idhong.concurrentQueue", NULL); 队列可以理解为对任务的管理，对任务使用 串行(先后顺序执行)还是并行（随机执行，由系统确定）处理。 异步执行&amp;同步执行dispatch_async 默认会开启新线程执行传入的队列，会立即返回。 dispatch_sync 在当前线程执行传入的队列，执行完才返回。 12dispatch_sync(dispatch_get_main_queue(), ^&#123;&#125;); 当前的线程在主线程中执行时会导致死锁，dispatch_sync 操作会让传如的队列在当前线程执行，而且必须执行完才返回，dispatch_get_main_queue()又是串行队列，是先进先出，（先后顺序执行）必须要让先加入 dispatch_get_main_queue() 中的任务执行完毕执行（外面的代码），从而导致相互等待导致死锁。 串行队列a 中 同步执行dispatch_sync 串行队列a 的任务会导致死锁 未完待续…]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈计算机内存分配]]></title>
    <url>%2F2017%2F10%2F16%2F03-%E6%8A%80%E6%9C%AF-%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[C语言 名称 内容 特性 栈区（stack） 栈区（stack）由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。后进先出（LIFO）；栈是逆向生长，先进栈的所分配的内存空间地址更大。 堆区（heap） 堆区（heap）一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收。注意它与数据结构中的堆是两回事，分配方式类似于链表。先进先出（FIFO）；堆是顺序生长，先进栈的所分配的内存空间地址更小。 数据区 全局非静态区、全局静态区、局部静态区、常量区 数据区主要包括静态全局区和常量区，如果要站在汇编角度细分的话还可以分为很多小的区； 数据区全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后有系统释放；常量字符串就是放在常量区。程序结束后由系统释放。 注：对于指针指向的所分配的某一块内存（无论是堆还是栈）的首地址永远是这块内存中最小的。 iOS 名称 内容 特性 栈区（stack） 存放的局部变量、先进后出、一旦出了作用域就会被销毁；函数跳转地址，现场保护等；程序猿不需要管理栈区变量的内存；栈区地址从高到低分配。 堆区（heap） 全局区非静态区、全局静态区、局部静态区 堆区的内存分配使用的是alloc；需要程序猿管理内存；ARC的内存的管理，是编译器再编译的时候自动添加retain、release、autorelease；堆区的地址是从低到高分配。 全局区/静态区（static） 全局区/静态区（static）包括两个部分：未初始化过 、初始化过；也就是说，（全局区/静态区）在内存中是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域；eg：int a;未初始化的。int a = 10;已初始化的。 常量区 常量字符串就是放在常量区。 代码区 代码区存放App二进制代码。]]></content>
      <categories>
        <category>03-技术-计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机存储单位和带宽等的关系]]></title>
    <url>%2F2017%2F10%2F15%2F03-%E6%8A%80%E6%9C%AF-%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E5%92%8C%E5%B8%A6%E5%AE%BD%E7%AD%89%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[计算机存储单位 计算机存储信息的最小单位是：位/bit (比特/Binary Digits)存放一位二进制数，即 0 或 1，是最小的存储单位。 计算机存储容量基本单位是：字节/B (byte), 8个二进制位为一个字节(B)，计算机中最常用的单位。 计算机的存储单位有：b，B，KB，MB，GB，TB，PB，EB，ZB，YB，BB等。 123456789101B (Byte 字节) = 8bit（比特，位）1KB (Kilobyte 千字节) = 1024B（1024=2^10）1MB (Megabyte 兆字节 简称“兆”) = 1024KB1GB (Gigabyte 吉字节 又称“千兆”) = 1024MB1TB (Trillionbyte 万亿字节 太字节) = 1024GB1PB（Petabyte 千万亿字节 拍字节） = 1024TB1EB（Exabyte 百亿亿字节 艾字节） = 1024PB1ZB (Zettabyte 十万亿亿字节 泽字节) = 1024 EB1YB (Yottabyte 一亿亿亿字节 尧字节) = 1024 ZB1BB (Brontobyte 一千亿亿亿字节) = 1024 YB. 在我们的平时开发中，经常说一个英文字母占1个字节（8bit/8个二进制位）int 类型占4/8个字节（32bit/64bit），所以可表示的数字范围就可以由其占的二进制位数来确定，当然要考虑正负数，符号等。 宽带时使用的单位 我们在牵宽带时，经常会接触到2M/4M/8M等，但是比如我们牵的2M带宽为什么往往在下载时下载速度在200KB/s左右徘徊，而不是2M/s呢？ 网络带宽中的2M带宽表示2Mbps/s (2x1024x1024bit/s) ，bps表示bit（位） 但在存储中2M（2x1024x1024x8bit）,这里使用的最基本单位不同，相差8倍 所以2M带宽的标准下载速度应该是 1(2x1024x1024bit/s)/8）= 256x1024bit/s = 256KB/s 当然会加上一些其他的损耗就在200KB/s左右浮动了。 厂商的硬盘存储单位 在好久之前可能我们都买给内存卡，硬盘等。买一个1G的内存卡往往只有大概930M左右的存储容量，why？难道是奸商，其实不是的，是他们计算方式不一样。我们都知道对计算机来说，它早知道二进制(010101)，但我们人类使用的基本是10进制，厂商使用的是10进制来计算了。 1234// 厂商的计算方式1G = 1 x 1000 x 1000 x 1000 x 8 bit = 8 000 000 000 bit// 计算机的计算方式1G = 1 x 1024 x 1024 x 1024 x 8 bit 所以厂商的 11G = 1G x （（1000x1000x1000）/ (1024x1024x1024 )) = 0.931G 左右。 参考http://xlnb.iteye.com/blog/842820]]></content>
      <categories>
        <category>03-技术-计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 - 给身处二流大学依旧迷茫的你一些过来人的大实话]]></title>
    <url>%2F2017%2F08%2F29%2F05-%E7%94%9F%E6%B4%BB-%E6%84%9F%E5%8F%B9%2F%E8%BD%AC-%E7%BB%99%E8%BA%AB%E5%A4%84%E4%BA%8C%E6%B5%81%E5%A4%A7%E5%AD%A6%E4%BE%9D%E6%97%A7%E8%BF%B7%E8%8C%AB%E7%9A%84%E4%BD%A0%E4%B8%80%E4%BA%9B%E8%BF%87%E6%9D%A5%E4%BA%BA%E7%9A%84%E5%A4%A7%E5%AE%9E%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[声明 原文：给身处二流大学依旧迷茫的你一些过来人的大实话作者：凰如水 正文有些路，只能自己一个人走 上了大学，第一堂课上老师说了一句话，至今仍然记忆犹新。“宿舍六个人，六条心”。或许刚刚步入大学的我们并没有太多的想法，但是，我们应该意识到一个问题，高中的时候，大家为了同一个目标——高考得胜而去奋斗，身边的人每天上一样的课，做一样的练习，读一样的书。而到了大学呢？一个宿舍的同学，有的人每天逃课打游戏，有的人每天忙着做兼职，有的人在学生会各个部门之间周旋，有的人从不缺课还要晚上坚持去图书馆。仿佛大学成了一个分水岭，大家开始走不一样的路，过不一样的生活了。那么，你又该何去何从？所以，大学一定要有专属于自己的一条主线，而这样的好处是什么呢？打个比方：如果我的主线是考研，那么在该加入学生会还是该去兼职还是该去上自习之间快速的做出契合自己主线的选择。我相信，这也是很多人建议大学四年一定要有一个很好规划的重要原因。知道自己要做什么，知道自己的主线在哪，才不会活的糊里糊涂，才能自己一个人走好自己的路。 学好英语很重要 如果你问自己那些已经从大学毕业多年的哥哥姐姐们自己该不该加入学生会？你可能会得到很多种不同的答案。但如果你问他们对你的大学有什么建议？其中一定有一条，把英语学好。通过英语四六级也许并不是什么牛逼的事，但是通过英语四六级，在别人眼里你可能变成一个牛逼的人。对于身处二流大学的我们来说，英语四六级的成绩极有可能成为我们大学四年之后唯一的可以拿出来证明自己的资本。如果有人告诉你学英语没有用，或者四六级的证书没有用，你信吗？且不说英语四六级可能和和保送研究生、就业等有很大的关系，起码我们应该证明自己，不留遗憾。我也相信，很多人都已经意识到了四六级的重要性，却望而却步，或无从下手。那题主可能很残酷的告诉你，学好英语从来就没有捷径可走。但题主也很欣慰的告诉你，通过英语四六级只要去付出再加上正确的方法，就可以顺利通关。单词很重要，单词很重要，单词很重要，重要的事情说三遍。我当年是买的星火的小册子，每天记20几个单词，坚持了两年多。从四六级考试的前两个月开始，每两天一套真题或模拟题（基础好的建议用新东方，比较薄弱的建议用星火）。还有一点，很多人今天记得单词可能明天就会忘，题主觉得忘就忘了，因为你没用，怎么可能一直记着。每天只要按计划去记，当真正在阅读里运用的时候，那种对单词似曾相识的感觉，才会让你把单词记得更牢。（不再这里赘述，可以私下交流） 学生会没那么重要 可能题主带了一些偏见，望勿喷。诚然，在学生会里混代表我们有一定的组织能力，有一定的人脉基础，甚至有相较一般学生的一点点优越感，这貌似已经越来越成为大家的共识。但我想说的是，学生会没有那么重要，更没有那么神秘。也许大你几级的部长、会长，有机会和你在同一个考场里见面。也许那些在低年级学生面前趾高气昂的干部身上并没有多少闪光点。我不是反对加入学生会，我只是不同意说学生会是一个多么多么锻炼人的地方，毕竟，我见过太多以学生会为名义逃课，因为学生会的琐事而浪费大把时间的人。我更希望，你加入学生会是因为这个平台可以教会你做事的方式，而不是每天对老师和上级的讨好，是因为这个平台有一些闪闪发光的朋友吸引着你，而不是陷入一种高人一等的幻觉之中。如果不是，请别再浪费自己的时间。 一定要多读书，多旅行 找几本好书，让自己变得不一样，我相信一个在图书馆里认真看书，认真做着读书笔记的女生或者男生，绝对比整天逛街或打游戏的女生男生更有魅力。其实，我们太年轻，很多东西需要有一个媒介去引导和启发，而读书毋庸置疑是最好的选择。更重要的是，如果我们不知道自己喜欢什么，多读读书也许慢慢的就会有一些自己的想法和乐趣。而如果我们模糊的知道自己对什么貌似有点兴趣，多读点书，我们可能会从中找到把兴趣变成专长的方式。多读书，哪怕只是为了让自己有独立的想法和思维方式。很多人可能看到多旅行觉得太过矫情，而我说这个是太过现实。从你上大学的那刻起，绝大多数人可能在一生中没有哪个阶段的空闲时间可以和大学媲美。多旅行，不是要诗意，而是要回忆。不是要炫耀，而是要经历。不是说大学一定要旅行，而是如果大学不旅行，以后，没有那么多自由的时间。所以，哪怕是穷游，也要多跑跑，多逛逛。 挂科并不光荣 可能很多人觉得我说了一句废话，因为即便是‘大学没有挂过科，不算是完整的大学’这样的言论盛行的现在，我相信也没有人愿意去主动挂科。那意味着一个假期的忐忐忑忑和每次开学的压力山大。我担心的是，你慢慢地习惯了自己的这种状态，你慢慢地看着挂的越来越多的科目变得麻木，那个时候也许对你真的没有什么是有所谓的。我相信，这样一种状态的你，离开大学的那一刻必定是一无所有的你。多么可怕，四年，你什么都没有留下，却带走了一个不再年轻，不再有斗志，麻木的你。 一定要自己赚一次外快 常听身边的朋友说，等到了社会，才发现原来钱这么难挣。不知道此刻在大学里的你，有没有这种体会？我们中的一些人，可能会看不起身边那些为了一小时几块钱去做兼职的同学，但我相信他们肯定比我们更能早早地体会到这个社会真实的一面。所以，大学里，请至少去做一次兼职，坚持几天就好。我只希望，你能通过自己的手，赚哪怕是不到100块钱，只要能体会到从别人的手里挣钱的难处就好，只要你可以在事后想想，你究竟可以做成什么事？你需不需要在踏入社会之前再多做一些准备，再多提升一下自己就足够了。挣钱真的很难，赚一次外快，想想自己，想想家人，想想未来。 不喜欢本专业，起码找点自己喜欢的做点成绩出来 听过太多的不喜欢这个专业、是因为被调剂了被迫学这个专业、不感兴趣等等这样的话，然后仿佛这个借口与你毫无关系，却可以成为你成绩不好，门门高挂的挡箭牌。那你喜欢什么？你自己说啊！我敢说，经常说这话的人，最后都喜欢上了借口，懒惰，迷茫。如果专业课不去上或者学不好是因为兴趣问题，那么剩下大把的时间你可以都放在自己喜欢的事上，做点成绩出来啊！到时候，我喜欢你可以昂首挺胸的说，这个专业我不喜欢，但我找到了自己喜欢做的。 能够坚持早起和跑步的人，你和人家真的有差距 早起没什么了不起，跑步更没什么大不了的，但能够一天一天去坚持，一个月一个月去做的人，你真的和人家有差距。我从未见过一个坚持了两个月早起和跑步的人会突然放弃，和你一样睡大觉。当你自己去做的时候，你才会发现原来坚持是这世界上最痛苦，也最充实的事。不妨看看身边那些这样做的人，看看他们的状态，看看他们的面貌，真的和你不一样。如果信我，请什么都不要管，你就这样坚持一个月早起跑步，然后，看看自己会不会发光可好？我敢打赌，你会发现一个全新的自己。而且，如果身边没有这样的人，请勇敢的无畏流言，做第一个。 你不得不信，人生来就有差距 以前学习好的同学貌似拥有整个世界，等你上了大学，可能感觉到同学之间有很明显的物质差距。也许你一年的生活费只是某些人一个月开销的一部分，也许你努力去拿的奖学金助学金别人却连申请都懒得写。到了快毕业的时候，你急的焦头烂额，简历投了一份又一份，而别人恐怕只等着拿毕业证上班。人生来就有差距，甚至单单是家境的差距就是你再努力也企及不上的高度。所以，看着别人任性，请先想想你有没有任性的资本。看着别人张狂，想一想你的将来要靠什么张狂。人也许生来就有差距，家境，智力等等，但请相信，你要是还不努力，你连反击的机会都没有一点。 假期实习助你脱颖而出 我们终究要走上社会，如果说我大学最后悔什么，那一定是没有提前出来历练。其实，你只要去精心制作一份有足够诚意的简历，找一份实习的工作并不难。当然，我说的是在一些一线城市。提早的了解自己专业将来在社会里的分工，提早熟悉一些自己有可能进入的行业领域，提早在自己感兴趣的工作上积累一些零散的经验，真的很有帮助。实习并不代表工作经历，却可以让你清晰的了解甚至预知未来。说一些不好听的话，我们的老师可能从学校拿到博士或者博士后学位的那一刻，就一直在大学里工作直到退休，他们对社会的了解可能很多来自自己的子女或者听闻。所以，社会真正是什么样子？你感兴趣的工作究竟是什么样子？孩子们，请提早行动，才能提早掌握优先权。 北上广没那么可怕 从何时开始，大家谈论起北上广，有些谈即色变的意思。节奏快，压力大，住房贵，消费高，空气差，交通堵，竞争强成了北上广的标配。有时候，我们听到北漂这个词觉得距离自己很遥远。在这里，我希望告诉你这样一个事实，每年校招季节，可能我们这些二流大学中一个销售，一个人力资源，一个工人，这样最基础的岗位都有成千甚至上万的人去争去抢。拿着宝贵的三方协议，随时打算把自己三十岁之前宝贵的青春断送出去。我并非对校招有偏见，而是我相信有太多的人在投出那一份简历时都不知道投的这个职位是干什么的。工作是很难找，可是我相信，一个对自己希望从事的行业或职业有过一定的了解和准备，一个踏实真诚认真有活力好学的应届大学生，一个对薪酬要求不那么高更愿意锻炼的年轻人在北上广很容易有一份适合自己的工作。而它绝不比校招所提供的差。年轻人眼界可以放的开一些，多来北上广看一看，找一找，反正我们本就一无所有。 希望你的能力撑得起你的爱情 毕业季即分手季，总有它存在的道理。以前觉得爱情被现实打败，是因为爱得不够深。后来才发现，爱情被现实打败，是因为一直活在理想里，不知道现实有多现实。爱情怎么来都行，可生活不同。相恋怎么美都好，可走到最后不同。如果一个姑娘愿意在你一无所有的年纪将自己的青春送上，将来分手时请一定不要说是因为不爱。如果一个小伙子愿意将生活费攒下来给你惊喜，将来分手时请一定不要说是因为他给不了你想要的。两个人在一起，从来就不是简简单单的甜蜜，反而是一起承担，一起成长，一起拼搏。当你的能力撑得起你的爱情，你才会嫁给最好的他，因为爱情。 你已经不小了，年龄也是竞争力 你可以算一算，大三的你如果是22岁甚至是往下，你该开始有一点危机感了。很多人在你这个年纪，已经大学毕业在社会上开始打拼，已经开始研究生的全新生活，这都是真的。请注意，我说的是很多人。你每天在大学里叫着外卖打着游戏，和你一样年龄的人可能正在加班加点的赶项目，你每天担心着老师点名和挂科，和你一样年龄的人可能正在一边工作一边为出国备战雅思托福。从你踏入社会的那一刻起，你该意识到年轻就是实力了，年龄小可以在自己喜欢的行业里摸爬滚打反复重来，年龄小可以凭着一股激情不计后果的往前冲在失败里积累经验，你可以吗？你已经不小了，你活的真的太安逸了。 请至少做好当下的事，人生再没有这样一个四年 如果你依旧迷茫，请至少做好当下的事。读二十几本不错的书，去十几个不错的地方，试着考点有含金量的证书，保证每一门功课都顺利通过，慢慢开始养成一些不错的习惯，多结交几个身上有闪光点的朋友，多了解了解新闻，有时间再掌握几个比较常用的图片处理或者办公编程的软件，就这样平淡的四年也很好。人生再也没有这样一个四年，只要你不做犯法的事，你可以做任何事，不论傻逼牛逼。人生再也没有这样一个四年，跌跌撞撞，悲悲喜喜，走走停停。人生再也没有这样一个四年，你可以凭心自由而活，纯粹为自己而活。 每一个走出校门的我们都很羡慕你们 我们不再有你们的幼稚，却也不再有你们的烂漫。我们不再有你们的荒唐，却也不再有你们的折腾。我们不再有你们的时光，因为大学变成了回忆。我们很羡慕你们，尤其是你们这绽放最狂野的年少。 唯愿你们青春荒唐却不辜负韶华 最后 原文：给身处二流大学依旧迷茫的你一些过来人的大实话作者：凰如水]]></content>
      <categories>
        <category>05-生活-感叹</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS自动布局之autoresizingMask的使用]]></title>
    <url>%2F2017%2F08%2F23%2F00-%E6%8A%80%E6%9C%AF-iOS%2FiOS%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E4%B9%8BautoresizingMask%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[写在前面的话 在iOS开发中，可能很少有人使用Autoresizing布局了，因为基本都使用强大的Autolayout了，Autoresizing可以做的Autolayout都可以做到，而且有一些是Autoresizing无法完成的，而且有强大的 Masonry库让约束写起来如此简洁。但在我们平时的开发中，可能封装一些小控件，并没有导入Masonry，如果我们所有代码添加约束时是特别麻烦，那么在一些简单的布局时可以尝试使用Autoresizing来玩玩。 UIView 的 autoresizingMask 属性 我们简单的看看UIViewAutoresizing的使用方法吧，其定义如下： 123456789typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) &#123; UIViewAutoresizingNone = 0, UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0, UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1, UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2, UIViewAutoresizingFlexibleTopMargin = 1 &lt;&lt; 3, UIViewAutoresizingFlexibleHeight = 1 &lt;&lt; 4, UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5&#125;; 1234567891011121314151617public struct UIViewAutoresizing : OptionSet &#123; public init(rawValue: UInt) public static var flexibleLeftMargin: UIViewAutoresizing &#123; get &#125; public static var flexibleWidth: UIViewAutoresizing &#123; get &#125; public static var flexibleRightMargin: UIViewAutoresizing &#123; get &#125; public static var flexibleTopMargin: UIViewAutoresizing &#123; get &#125; public static var flexibleHeight: UIViewAutoresizing &#123; get &#125; public static var flexibleBottomMargin: UIViewAutoresizing &#123; get &#125;&#125; UIViewAutoresizingNone 不做任何布局操作，默认是此类型 UIViewAutoresizingFlexibleLeftMargin 左边可变，右边距离固定。左边是灵活的 UIViewAutoresizingFlexibleWidth 宽度可变，两边固定。宽度是灵活的 UIViewAutoresizingFlexibleRightMargin 右边可变，左边固定。右边是灵活的 UIViewAutoresizingFlexibleTopMargin 上方可变，下方固定。顶部距离的灵活的 UIViewAutoresizingFlexibleHeight 高度可变，上下固定。高度是灵活的 UIViewAutoresizingFlexibleBottomMargin 底边距离可变，头部距离固定。底边距离是灵活的 代码OC12UIView *view = [UIView new];view.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight; Swift12let view = UIView()view.autoresizingMask = [.flexibleWidth, .flexibleHeight]]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSInvocation的简单使用]]></title>
    <url>%2F2017%2F08%2F18%2F00-%E6%8A%80%E6%9C%AF-iOS%2FNSInvocation%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[写在前面 在平时的开发中，可能有这样一个需求，别人给你方法名，给你参数，叫你去执行此方法，比如：在OC-JS交互时可能会遇到，那么我们怎么处理呢？我们调用方法最常见的是 [obj func...]; performSelector目前的需求[obj func...];肯定是不行了，使用performSelector可行，但是，它只可以处理不多余2个参数的情况，那么多余2个的怎么处理呢？可能会想到不就是想传多给参数吗？就把参数包装为 NSDictionary 来处理吧，对，是一个处理方案。but现在就是不想用包装的方式。其实用 NSInvocation是可以解决的，现在就随便说下他的使用方法吧。 代码实现 有如下的方法： 123- (void)test:(NSString *)a b:(NSString *)b c:(NSString *)c d:(NSString *)d &#123; NSLog(@"test: %@, %@, %@, %@", a, b, c, d);&#125; 现在给你Target 方法名(字符串)和 参数（数组） 需要你调用此方法 123id target = self;NSString *methodName = @"test:b:c:d:";NSArray *array = @[@"1", @"22", @"2233", @"c"]; 可以如下实现 123456789101112131415161718- (void)testWithTarget:(id)target SELString:(NSString *)sel parameters:(NSArray *)parameters &#123; // 创建SEL SEL selector = NSSelectorFromString(sel); // 创建NSMethodSignature NSMethodSignature *signature = [target methodSignatureForSelector:selector]; // 创建NSInvocation NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature]; // 设置target invocation.target = target; // 设置SEL invocation.selector = selector; // 增加参数 [parameters enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; [invocation setArgument:&amp;obj atIndex:idx+2]; &#125;]; // 开始调用 [invocation invoke];&#125; 完整Demo]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[介绍几个iOS开发中被忽略的系统框架]]></title>
    <url>%2F2017%2F08%2F12%2F00-%E6%8A%80%E6%9C%AF-iOS%2F%E4%BB%8B%E7%BB%8D%E5%87%A0%E4%B8%AAiOS%E5%BC%80%E5%8F%91%E4%B8%AD%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[之前在使用别人的APP时，有一些界面特别棒，好像自己写来玩玩，最后发现有一些其实的系统已经有框架提供了，所以在此简单收集一些被忽略但比较酷的框架，以供参考，若您有比较好的框架欢迎下方评价留言。 iOS开发系统框架123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990Accelerate.frameworkAccounts.frameworkAddressBook.frameworkAddressBookUI.frameworkAdSupport.frameworkAssetsLibrary.frameworkAudioToolbox.frameworkAudioUnit.frameworkAVFoundation.frameworkAVKit.frameworkCallKit.frameworkCFNetwork.frameworkCloudKit.frameworkContacts.frameworkContactsUI.frameworkCoreAudio.frameworkCoreAudioKit.frameworkCoreBluetooth.frameworkCoreData.frameworkCoreFoundation.frameworkCoreGraphics.frameworkCoreImage.frameworkCoreLocation.frameworkCoreMedia.frameworkCoreMIDI.frameworkCoreMotion.frameworkCoreSpotlight.frameworkCoreTelephony.frameworkCoreText.frameworkCoreVideo.frameworkEventKit.frameworkEventKitUI.frameworkExternalAccessory.frameworkFoundation.frameworkGameController.frameworkGameKit.frameworkGameplayKit.frameworkGLKit.frameworkGSS.frameworkHealthKit.frameworkHealthKitUI.frameworkHomeKit.frameworkiAd.frameworkImageIO.frameworkIntents.frameworkIntentsUI.frameworkIOKit.frameworkJavaScriptCore.frameworkLocalAuthentication.frameworkMapKit.frameworkMediaAccessibility.frameworkMediaPlayer.frameworkMediaToolbox.frameworkMessages.frameworkMessageUI.frameworkMetal.frameworkMetalKit.frameworkMetalPerformanceShaders.frameworkMobileCoreServices.frameworkModelIO.frameworkMultipeerConnectivity.frameworkNetworkExtension.frameworkNewsstandKit.frameworkNotificationCenter.frameworkOpenAL.frameworkOpenGLES.frameworkPassKit.frameworkPhotos.frameworkPhotosUI.frameworkPushKit.frameworkQuartzCore.frameworkQuickLook.frameworkReplayKit.frameworkSafariServices.frameworkSceneKit.frameworkSecurity.frameworkSocial.frameworkSpeech.frameworkSpriteKit.frameworkStoreKit.frameworkSystemConfiguration.frameworkTwitter.frameworkUIKit.frameworkUserNotifications.frameworkUserNotificationsUI.frameworkVideoSubscriberAccount.frameworkVideoToolbox.frameworkWatchConnectivity.frameworkWatchKit.frameworkWebKit.framework macOS开发系统框架123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134Accelerate.frameworkAccounts.frameworkAddressBook.frameworkAGL.frameworkAppKit.frameworkAppKitScripting.frameworkAppleScriptKit.frameworkAppleScriptObjC.frameworkApplicationServices.frameworkAudioToolbox.frameworkAudioUnit.frameworkAudioVideoBridging.frameworkAutomator.frameworkAVFoundation.frameworkAVKit.frameworkCalendarStore.frameworkCarbon.frameworkCFNetwork.frameworkCloudKit.frameworkCocoa.frameworkCollaboration.frameworkContacts.frameworkContactsUI.frameworkCoreAudio.frameworkCoreAudioKit.frameworkCoreBluetooth.frameworkCoreData.frameworkCoreDisplay.frameworkCoreFoundation.frameworkCoreGraphics.frameworkCoreImage.frameworkCoreLocation.frameworkCoreMedia.frameworkCoreMediaIO.frameworkCoreMIDI.frameworkCoreMIDIServer.frameworkCoreServices.frameworkCoreTelephony.frameworkCoreText.frameworkCoreVideo.frameworkCoreWLAN.frameworkCryptoTokenKit.frameworkDirectoryService.frameworkDiscRecording.frameworkDiscRecordingUI.frameworkDiskArbitration.frameworkDrawSprocket.frameworkDVComponentGlue.frameworkDVDPlayback.frameworkEventKit.frameworkExceptionHandling.frameworkFinderSync.frameworkForceFeedback.frameworkFoundation.frameworkFWAUserLib.frameworkGameController.frameworkGameKit.frameworkGameplayKit.frameworkGLKit.frameworkGLUT.frameworkGSS.frameworkHypervisor.frameworkICADevices.frameworkImageCaptureCore.frameworkImageIO.frameworkIMServicePlugIn.frameworkInputMethodKit.frameworkInstallerPlugins.frameworkInstantMessage.frameworkIntents.frameworkIOBluetooth.frameworkIOBluetoothUI.frameworkIOKit.frameworkIOSurface.frameworkJavaFrameEmbedding.frameworkJavaScriptCore.frameworkJavaVM.frameworkKerberos.frameworkKernel.frameworkLatentSemanticMapping.frameworkLDAP.frameworkLocalAuthentication.frameworkMapKit.frameworkMediaAccessibility.frameworkMediaLibrary.frameworkMediaPlayer.frameworkMediaToolbox.frameworkMessage.frameworkMetal.frameworkMetalKit.frameworkModelIO.frameworkMultipeerConnectivity.frameworkNetFS.frameworkNetworkExtension.frameworkNotificationCenter.frameworkOpenAL.frameworkOpenCL.frameworkOpenDirectory.frameworkOpenGL.frameworkOSAKit.frameworkPCSC.frameworkPhotos.frameworkPhotosUI.frameworkPreferencePanes.frameworkPubSub.frameworkPython.frameworkQTKit.frameworkQuartz.frameworkQuartzCore.frameworkQuickLook.frameworkQuickTime.frameworkRuby.frameworkSafariServices.frameworkSceneKit.frameworkScreenSaver.frameworkScripting.frameworkScriptingBridge.frameworkSecurity.frameworkSecurityFoundation.frameworkSecurityInterface.frameworkServiceManagement.frameworkSocial.frameworkSpriteKit.frameworkStoreKit.frameworkSyncServices.frameworkSystem.frameworkSystemConfiguration.frameworkTcl.frameworkTk.frameworkTWAIN.frameworkVideoDecodeAcceleration.frameworkVideoToolbox.frameworkvmnet.frameworkWebKit.framework 几个可能被忽略的框架12345678// iOS系统第三方分享框架#import &lt;Social/Social.h&gt;// 包括：不用跳转AppStore下载第三方应用#import &lt;StoreKit/StoreKit.h&gt;// 包括：应用内加载Safari一样的WebView界面#import &lt;SafariServices/SafariServices.h&gt;]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 - 对函数式编程的一点理解]]></title>
    <url>%2F2017%2F08%2F06%2F00-%E6%8A%80%E6%9C%AF-iOS%2F%E8%BD%AC-%E5%AF%B9%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[文章转载自https://github.com/nixzhu/dev-blog 虽然有不少对“函数式编程”的解释，但我没有遇到让我满意的。我不是说解释要多么的具体、全面，或者让我立马会使用、变得很厉害，我就想知道它是怎么一回事儿。 先考虑一个过程。假设您性别男，爱好女。有位优雅的女士愿意与您做爱，不过这位女士对做爱有些要求：前戏至少要15分钟，性交要求在3到5分钟之间，最后要抱抱30分钟，说些情话。 如果我们用程序来描述上面的过程，大概如下： 12345678910111213141516let foreplayMinutes = 20let sexualIntercourseMinutes = 5let hugMinutes = 40let smallTalk = trueif foreplayMinutes &gt;= 15 &#123; if sexualIntercourseMinutes &gt;= 3 &amp;&amp; sexualIntercourseMinutes &lt;= 5 &#123; if hugMinutes &gt;= 30 &amp;&amp; smallTalk &#123; print("Satisfied!") &#125; &#125; else &#123; print("Not satisfied!") &#125;&#125; else &#123; print("Not satisfied!")&#125; 虽然这个过程比较简单，但那是因为我们做了简化，不然会变得少儿不宜。在真实场景下，我们会将明显可独立的部分抽象成函数，帮助我们更好地理解整个过程，于是变为： 12345678910111213if foreplay(foreplayMinutes) &#123; if sexualIntercourse(sexualIntercourseMinutes) &#123; if hug(hugMinutes, smallTalk) &#123; print("Satisfied!") &#125; else &#123; print("Not satisfied!") &#125; &#125; else &#123; print("Not satisfied!") &#125;&#125; else &#123; print("Not satisfied!")&#125; 其中foreplay，sexualIntercourse，hug都是函数，它们的实现大概如下： 1234567891011func foreplay(_ minutes: Int) -&gt; Bool &#123; return minutes &gt;= 15 ? true : false&#125;func sexualIntercourse(_ minutes: Int) -&gt; Bool &#123; return (minutes &gt;= 3 &amp;&amp; minutes &lt;= 5) ? true : false&#125;func hug(_ minutes: Int, _ smallTalk: Bool) -&gt; Bool &#123; return ((minutes &gt;= 30) ? true : false) &amp;&amp; smallTalk&#125; 因为要按照女士的要求做爱，所以这三个子过程的顺序并不能颠倒，但目前这三个函数并没有体现出顺序。 我们在做的就是所谓的“编程”，那什么是“函数式编程”？ 先来分析一下最上面的过程： 首先我们定义了一些输入，如foreplayMinutes等； 然后我们（主要是您）先执行 foreplay，当这个过程符合要求后才进行下一步； 若三个子过程都满足要求，女士才会满足，中间某个过程一旦不满足，那就不可能满足了。 再简化一点说，即：有输入，过程有顺序，过程可能有输出。那什么是“函数式编程”？ 别慌，快了。 其实函数式编程是一种更高层的抽象（类似于我们将“过程”抽象成“函数”）：我们假设有个“高阶函数”，它能接受任意数据和一个函数（利用范型），并返回经过此函数处理的数据。我们命名此函数为bind： 1234567func bind&lt;A, B&gt;(_ a: A?, _ f: (A) -&gt; B?) -&gt; B? &#123; if let x = a &#123; return f(x) &#125; else &#123; return nil &#125;&#125; 因为函数不一定有返回值，所以返回值是可选的。注意这里的a参数不一定要是可选的，但是为了bind的通用性（后面会看出来），让其可选比较好。 而为了在子过程中体现顺序，我们要为它们增加参数： 12345678910111213141516171819func foreplay(minutes: Int) -&gt; Bool? &#123; return minutes &gt;= 15 ? true : false&#125;func sexualIntercourse(foreplaySatisfied: Bool, minutes: Int) -&gt; Bool? &#123; if foreplaySatisfied &#123; return (minutes &gt;= 3 &amp;&amp; minutes &lt;= 5) ? true : false &#125; else &#123; return nil &#125;&#125;func hug(sexualIntercourseSatisfied: Bool, minutes: Int, smallTalk: Bool) -&gt; Bool? &#123; if sexualIntercourseSatisfied &#123; return (minutes &gt;= 30 ? true : false) &amp;&amp; smallTalk &#125; else &#123; return nil &#125;&#125; 注意，除了增加判断参数外，为了能适用于bind，函数的返回值也变为可选了。 由此，该怎么用bind来描述上面的过程呢？ 12345678910var satisfied: Bool = falsesatisfied = bind(foreplayMinutes, foreplay) ?? falsesatisfied = bind(satisfied, sexualIntercourse) ?? false //错误satisfied = bind(satisfied, hug) ?? false //错误if satisfied &#123; print("Satisfied!")&#125; else &#123; print("Not satisfied!")&#125; 可惜我们不能这么写，因为函数sexualIntercourse和hug都不只接受一个参数，无法适用于bind。那怎么办？ 我们可以使用柯里化（Currying）技术改造我们的函数。所谓柯里化，就是将接受多个参数的函数变换成接受前几个参数（Swift的实现并不限定为第一个）的函数，而此函数返回一个“接受余下参数并能返回结果的新函数”。虽然柯里化的介绍并不直观，但其实改造很容易。我们只需要将多个参数分割成两个部分即可，我们直接传递参数给第一部分就可生成新函数，如： 12345678910111213func add(a: Int, b: Int) -&gt; Int &#123; return a + b&#125;add(3, 4) // 7func add(a: Int)(b: Int) -&gt; Int &#123; // 等价于上面的 add 函数 return a + b&#125;let addThree = add(3) // addThree 是一个新的函数，其可接受一个参数addThree(4) // 7 由此，我们改造sexualIntercourse和hug如下： 1234567func sexualIntercourse(_ minutes: Int) -&gt; (_ foreplaySatisfied: Bool) -&gt; Bool? &#123; //...&#125;func hug(_ minutes: Int, _ smallTalk: Bool) -&gt; (_ sexualIntercourseSatisfied: Bool) -&gt; Bool? &#123; //...&#125; 注意hug函数，表明了我们对多参数的分割可以在任意位置。事实上，我们也可以写为： 123func hug(_ minutes: Int) -&gt; (_ smallTalk: Bool) -&gt; (_ sexualIntercourseSatisfied: Bool) -&gt; Bool? &#123; //...&#125; 当然使用时会更加灵活。 之后，我们就能使用这两个柯里化函数了： 12345//...satisfied = bind(satisfied, sexualIntercourse(sexualIntercourseMinutes)) ?? falsesatisfied = bind(satisfied, hug(hugMinutes, smallTalk)) ?? false//... 此时，我们用bind将我们的过程顺序链接起来了。不过bind的语法依然让人困惑，我们可以增加一个中缀操作符： 123456789precedencegroup BindPrecedence &#123; higherThan: NilCoalescingPrecedence associativity: left&#125;infix operator &gt;&gt;&gt;: BindPrecedencefunc &gt;&gt;&gt;&lt;A, B&gt;(_ a: A?, _ f: (A) -&gt; B?) -&gt; B? &#123; return bind(a, f)&#125; 然后对应的计算就变为： 1let satisfied = foreplayMinutes &gt;&gt;&gt; foreplay &gt;&gt;&gt; sexualIntercourse(sexualIntercourseMinutes) &gt;&gt;&gt; hug(hugMinutes, smallTalk) ?? false 变成一条链了，顺序非常清楚。当然，我们写成这样可能更好看： 1let satisfied = foreplay(foreplayMinutes) &gt;&gt;&gt; sexualIntercourse(sexualIntercourseMinutes) &gt;&gt;&gt; hug(hugMinutes, smallTalk) ?? false 三个过程会更清楚。 在函数式编程的思想下，借助柯里化技术与自定义操作符，我们就能做到这样的“高阶操作”。 上面只是将数据和函数bind在一起处理，那若是其它“合成”情况，或更高阶呢？例如有某个函数接受两个函数作为参数并生成一个新的函数又会怎么样（完全不理会数据了）。只要发挥你的想象力，那函数式编程也就不再神秘。 小结函数式编程就是将函数当作一种数据类型，或者从更高的层面去看待数据和函数，使其可传递、可生成、可组合、可分解。有了这样的高级抽象，我们对函数的理解会更深刻，我们思考时就能更加自由。 有一点可能很关键，就是“形式”。虽然都是代码，完成的功能也一样，但形式的不同能反映我们思考的不同。语言可以影响思维早就被发现了，这也是类似于“新闻联播”这样的节目可以成为思想控制工具的原因。在生活中，独立思考的阻碍比你想象的要多得多。 如果你已开始用 Swift 写代码，可以考虑在某些地方试用这样的抽象观点，必有益处。 文章转载自https://github.com/nixzhu/dev-blog]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 - GCD 深入理解之二]]></title>
    <url>%2F2017%2F08%2F06%2F00-%E6%8A%80%E6%9C%AF-iOS%2F%E8%BD%AC-GCD-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[文章转自 https://github.com/nixzhu/dev-blog 在本系列的第一部分中，你已经学到超过你想像的关于并发、线程以及GCD 如何工作的知识。通过在初始化时利用 dispatch_once，你创建了一个线程安全的 PhotoManager 单例，而且你通过使用 dispatch_barrier_async 和 dispatch_sync 的组合使得对 Photos 数组的读取和写入都变得线程安全了。 除了上面这些，你还通过利用 dispatch_after 来延迟显示提示信息，以及利用 dispatch_async 将 CPU 密集型任务从 ViewController 的初始化过程中剥离出来异步执行，达到了增强应用的用户体验的目的。 如果你一直跟着第一部分的教程在写代码，那你可以继续你的工程。但如果你没有完成第一部分的工作，或者不想重用你的工程，你可以下载第一部分最终的代码。 那就让我们来更深入地探索 GCD 吧！ 纠正过早弹出的提示你可能已经注意到当你尝试用 Le Internet 选项来添加图片时，一个 UIAlertView 会在图片下载完成之前就弹出，如下如所示： 问题的症结在 PhotoManagers 的 downloadPhotoWithCompletionBlock: 里，它目前的实现如下： 12345678910111213141516171819202122232425262728293031323334- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock&#123; __block NSError *error; for (NSInteger i = 0; i &lt; 3; i++) &#123; NSURL *url; switch (i) &#123; case 0: url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString]; break; case 1: url = [NSURL URLWithString:kSuccessKidURLString]; break; case 2: url = [NSURL URLWithString:kLotsOfFacesURLString]; break; default: break; &#125; Photo *photo = [[Photo alloc] initwithURL:url withCompletionBlock:^(UIImage *image, NSError *_error) &#123; if (_error) &#123; error = _error; &#125; &#125;]; [[PhotoManager sharedManager] addPhoto:photo]; &#125; if (completionBlock) &#123; completionBlock(error); &#125;&#125; 在方法的最后你调用了 completionBlock ——因为此时你假设所有的照片都已下载完成。但很不幸，此时并不能保证所有的下载都已完成。 Photo 类的实例方法用某个 URL 开始下载某个文件并立即返回，但此时下载并未完成。换句话说，当 downloadPhotoWithCompletionBlock: 在其末尾调用 completionBlock 时，它就假设了它自己所使用的方法全都是同步的，而且每个方法都完成了它们的工作。 然而，-[Photo initWithURL:withCompletionBlock:] 是异步执行的，会立即返回——所以这种方式行不通。 因此，只有在所有的图像下载任务都调用了它们自己的 Completion Block 之后，downloadPhotoWithCompletionBlock: 才能调用它自己的 completionBlock 。问题是：你该如何监控并发的异步事件？你不知道它们何时完成，而且它们完成的顺序完全是不确定的。 或许你可以写一些比较 Hacky 的代码，用多个布尔值来记录每个下载的完成情况，但这样做就缺失了扩展性，而且说实话，代码会很难看。 幸运的是， 解决这种对多个异步任务的完成进行监控的问题，恰好就是设计 dispatch_group 的目的。 Dispatch Groups（调度组）Dispatch Group 会在整个组的任务都完成时通知你。这些任务可以是同步的，也可以是异步的，即便在不同的队列也行。而且在整个组的任务都完成时，Dispatch Group 可以用同步的或者异步的方式通知你。因为要监控的任务在不同队列，那就用一个 dispatch_group_t 的实例来记下这些不同的任务。 当组中所有的事件都完成时，GCD 的 API 提供了两种通知方式。 第一种是 dispatch_group_wait ，它会阻塞当前线程，直到组里面所有的任务都完成或者等到某个超时发生。这恰好是你目前所需要的。 打开 PhotoManager.m，用下列实现替换 downloadPhotosWithCompletionBlock:： 123456789101112131415161718192021222324252627282930313233343536373839404142- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock&#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; // 1 __block NSError *error; dispatch_group_t downloadGroup = dispatch_group_create(); // 2 for (NSInteger i = 0; i &lt; 3; i++) &#123; NSURL *url; switch (i) &#123; case 0: url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString]; break; case 1: url = [NSURL URLWithString:kSuccessKidURLString]; break; case 2: url = [NSURL URLWithString:kLotsOfFacesURLString]; break; default: break; &#125; dispatch_group_enter(downloadGroup); // 3 Photo *photo = [[Photo alloc] initwithURL:url withCompletionBlock:^(UIImage *image, NSError *_error) &#123; if (_error) &#123; error = _error; &#125; dispatch_group_leave(downloadGroup); // 4 &#125;]; [[PhotoManager sharedManager] addPhoto:photo]; &#125; dispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER); // 5 dispatch_async(dispatch_get_main_queue(), ^&#123; // 6 if (completionBlock) &#123; // 7 completionBlock(error); &#125; &#125;); &#125;);&#125; 按照注释的顺序，你会看到： 因为你在使用的是同步的 dispatch_group_wait ，它会阻塞当前线程，所以你要用 dispatch_async 将整个方法放入后台队列以避免阻塞主线程。 创建一个新的 Dispatch Group，它的作用就像一个用于未完成任务的计数器。 dispatch_group_enter 手动通知 Dispatch Group 任务已经开始。你必须保证 dispatch_group_enter 和 dispatch_group_leave 成对出现，否则你可能会遇到诡异的崩溃问题。 手动通知 Group 它的工作已经完成。再次说明，你必须要确保进入 Group 的次数和离开 Group 的次数相等。 dispatch_group_wait 会一直等待，直到任务全部完成或者超时。如果在所有任务完成前超时了，该函数会返回一个非零值。你可以对此返回值做条件判断以确定是否超出等待周期；然而，你在这里用 DISPATCH_TIME_FOREVER 让它永远等待。它的意思，勿庸置疑就是，永－远－等－待！这样很好，因为图片的创建工作总是会完成的。 此时此刻，你已经确保了，要么所有的图片任务都已完成，要么发生了超时。然后，你在主线程上运行 completionBlock 回调。这会将工作放到主线程上，并在稍后执行。 最后，检查 completionBlock 是否为 nil，如果不是，那就运行它。 编译并运行你的应用，尝试下载多个图片，观察你的应用是在何时运行 completionBlock 的。 注意：如果你是在真机上运行应用，而且网络活动发生得太快以致难以观察 completionBlock 被调用的时刻，那么你可以在 Settings 应用里的开发者相关部分里打开一些网络设置，以确保代码按照我们所期望的那样工作。只需去往 Network Link Conditioner 区，开启它，再选择一个 Profile，“Very Bad Network” 就不错。 如果你是在模拟器里运行应用，你可以使用 来自 GitHub 的 Network Link Conditioner 来改变网络速度。它会成为你工具箱中的一个好工具，因为它强制你研究你的应用在连接速度并非最佳的情况下会变成什么样。 目前为止的解决方案还不错，但是总体来说，如果可能，最好还是要避免阻塞线程。你的下一个任务是重写一些方法，以便当所有下载任务完成时能异步通知你。 在我们转向另外一种使用 Dispatch Group 的方式之前，先看一个简要的概述，关于何时以及怎样使用有着不同的队列类型的 Dispatch Group ： 自定义串行队列：它很适合当一组任务完成时发出通知。 主队列（串行）：它也很适合这样的情况。但如果你要同步地等待所有工作地完成，那你就不应该使用它，因为你不能阻塞主线程。然而，异步模型是一个很有吸引力的能用于在几个较长任务（例如网络调用）完成后更新 UI 的方式。 并发队列：它也很适合 Dispatch Group 和完成时通知。 Dispatch Group，第二种方式上面的一切都很好，但在另一个队列上异步调度然后使用 dispatch_group_wait 来阻塞实在显得有些笨拙。是的，还有另一种方式…… 在 PhotoManager.m 中找到 downloadPhotosWithCompletionBlock: 方法，用下面的实现替换它： 12345678910111213141516171819202122232425262728293031323334353637383940- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock&#123; // 1 __block NSError *error; dispatch_group_t downloadGroup = dispatch_group_create(); for (NSInteger i = 0; i &lt; 3; i++) &#123; NSURL *url; switch (i) &#123; case 0: url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString]; break; case 1: url = [NSURL URLWithString:kSuccessKidURLString]; break; case 2: url = [NSURL URLWithString:kLotsOfFacesURLString]; break; default: break; &#125; dispatch_group_enter(downloadGroup); // 2 Photo *photo = [[Photo alloc] initwithURL:url withCompletionBlock:^(UIImage *image, NSError *_error) &#123; if (_error) &#123; error = _error; &#125; dispatch_group_leave(downloadGroup); // 3 &#125;]; [[PhotoManager sharedManager] addPhoto:photo]; &#125; dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123; // 4 if (completionBlock) &#123; completionBlock(error); &#125; &#125;);&#125; 下面解释新的异步方法如何工作： 在新的实现里，因为你没有阻塞主线程，所以你并不需要将方法包裹在 async 调用中。 同样的 enter 方法，没做任何修改。 同样的 leave 方法，也没做任何修改。 dispatch_group_notify 以异步的方式工作。当 Dispatch Group 中没有任何任务时，它就会执行其代码，那么 completionBlock 便会运行。你还指定了运行 completionBlock 的队列，此处，主队列就是你所需要的。 对于这个特定的工作，上面的处理明显更清晰，而且也不会阻塞任何线程。 太多并发带来的风险既然你的工具箱里有了这些新工具，你大概做任何事情都想使用它们，对吧？ 看看 PhotoManager 中的 downloadPhotosWithCompletionBlock 方法。你可能已经注意到这里的 for 循环，它迭代三次，下载三个不同的图片。你的任务是尝试让 for 循环并发运行，以提高其速度。 dispatch_apply 刚好可用于这个任务。 dispatch_apply 表现得就像一个 for 循环，但它能并发地执行不同的迭代。这个函数是同步的，所以和普通的 for 循环一样，它只会在所有工作都完成后才会返回。 当在 Block 内计算任何给定数量的工作的最佳迭代数量时，必须要小心，因为过多的迭代和每个迭代只有少量的工作会导致大量开销以致它能抵消任何因并发带来的收益。而被称为跨越式（striding）的技术可以在此帮到你，即通过在每个迭代里多做几个不同的工作。 译者注：大概就能减少并发数量吧，作者是提醒大家注意并发的开销，记在心里！ 那何时才适合用 dispatch_apply 呢？ 自定义串行队列：串行队列会完全抵消 dispatch_apply 的功能；你还不如直接使用普通的 for 循环。 主队列（串行）：与上面一样，在串行队列上不适合使用 dispatch_apply 。还是用普通的 for 循环吧。 并发队列：对于并发循环来说是很好选择，特别是当你需要追踪任务的进度时。 回到 downloadPhotosWithCompletionBlock: 并用下列实现替换它： 12345678910111213141516171819202122232425262728293031323334353637383940- (void)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock&#123; __block NSError *error; dispatch_group_t downloadGroup = dispatch_group_create(); dispatch_apply(3, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^(size_t i) &#123; NSURL *url; switch (i) &#123; case 0: url = [NSURL URLWithString:kOverlyAttachedGirlfriendURLString]; break; case 1: url = [NSURL URLWithString:kSuccessKidURLString]; break; case 2: url = [NSURL URLWithString:kLotsOfFacesURLString]; break; default: break; &#125; dispatch_group_enter(downloadGroup); Photo *photo = [[Photo alloc] initwithURL:url withCompletionBlock:^(UIImage *image, NSError *_error) &#123; if (_error) &#123; error = _error; &#125; dispatch_group_leave(downloadGroup); &#125;]; [[PhotoManager sharedManager] addPhoto:photo]; &#125;); dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123; if (completionBlock) &#123; completionBlock(error); &#125; &#125;);&#125; 你的循环现在是并行运行的了；在上面的代码中，在调用 dispatch_apply 时，你用第一次参数指明了迭代的次数，用第二个参数指定了任务运行的队列，而第三个参数是一个 Block。 要知道虽然你有代码保证添加相片时线程安全，但图片的顺序却可能不同，这取决于线程完成的顺序。 编译并运行，然后从 “Le Internet” 添加一些照片。注意到区别了吗？ 在真机上运行新代码会稍微更快的得到结果。但我们所做的这些提速工作真的值得吗？ 实际上，在这个例子里并不值得。下面是原因： 你创建并行运行线程而付出的开销，很可能比直接使用 for 循环要多。若你要以合适的步长迭代非常大的集合，那才应该考虑使用 dispatch_apply。 你用于创建应用的时间是有限的——除非实在太糟糕否则不要浪费时间去提前优化代码。如果你要优化什么，那去优化那些明显值得你付出时间的部分。你可以通过在 Instruments 里分析你的应用，找出最长运行时间的方法。看看 如何在 Xcode 中使用 Instruments 可以学到更多相关知识。 通常情况下，优化代码会让你的代码更加复杂，不利于你自己和其他开发者阅读。请确保添加的复杂性能换来足够多的好处。 记住，不要在优化上太疯狂。你只会让你自己和后来者更难以读懂你的代码。 GCD 的其他趣味等一下！还有更多！有一些额外的函数在不同的道路上走得更远。虽然你不会太频繁地使用这些工具，但在对的情况下，它们可以提供极大的帮助。 阻塞——正确的方式这可能听起来像是个疯狂的想法，但你知道 Xcode 已有了测试功能吗？:] 我知道，虽然有时候我喜欢假装它不存在，但在代码里构建复杂关系时编写和运行测试非常重要。 Xcode 里的测试在 XCTestCase 的子类上执行，并运行任何方法签名以 test 开头的方法。测试在主线程运行，所以你可以假设所有测试都是串行发生的。 当一个给定的测试方法运行完成，XCTest 方法将考虑此测试已结束，并进入下一个测试。这意味着任何来自前一个测试的异步代码会在下一个测试运行时继续运行。 网络代码通常是异步的，因此你不能在执行网络获取时阻塞主线程。也就是说，整个测试会在测试方法完成之后结束，这会让对网络代码的测试变得很困难。也就是，除非你在测试方法内部阻塞主线程直到网络代码完成。 注意：有一些人会说，这种类型的测试不属于集成测试的首选集（Preferred Set）。一些人会赞同，一些人不会。但如果你想做，那就去做。 导航到 GooglyPuffTests.m 并查看 downloadImageURLWithString:，如下： 123456789101112131415- (void)downloadImageURLWithString:(NSString *)URLString&#123; NSURL *url = [NSURL URLWithString:URLString]; __block BOOL isFinishedDownloading = NO; __unused Photo *photo = [[Photo alloc] initwithURL:url withCompletionBlock:^(UIImage *image, NSError *error) &#123; if (error) &#123; XCTFail(@&quot;%@ failed. %@&quot;, URLString, error); &#125; isFinishedDownloading = YES; &#125;]; while (!isFinishedDownloading) &#123;&#125;&#125; 这是一种测试异步网络代码的幼稚方式。 While 循环在函数的最后一直等待，直到 isFinishedDownloading 布尔值变成 True，它只会在 Completion Block 里发生。让我们看看这样做有什么影响。 通过在 Xcode 中点击 Product / Test 运行你的测试，如果你使用默认的键绑定，也可以使用快捷键 ⌘+U 来运行你的测试。 在测试运行时，注意 Xcode debug 导航栏里的 CPU 使用率。这个设计不当的实现就是一个基本的 自旋锁 。它很不实用，因为你在 While 循环里浪费了珍贵的 CPU 周期；而且它也几乎没有扩展性。 译者注：所谓自旋锁，就是某个线程一直抢占着 CPU 不断检查以等到它需要的情况出现。因为现代操作系统都是可以并发运行多个线程的，所以它所等待的那个线程也有机会被调度执行，这样它所需要的情况早晚会出现。 你可能需要使用前面提到的 Network Link Conditioner ，已便清楚地看到这个问题。如果你的网络太快，那么自旋只会在很短的时间里发生，难以观察。 译者注：作者反复提到网速太快，而我们还需要对付 GFW，简直泪流满面！ 你需要一个更优雅、可扩展的解决方案来阻塞线程直到资源可用。欢迎来到信号量。 信号量信号量是一种老式的线程概念，由非常谦卑的 Edsger W. Dijkstra 介绍给世界。信号量之所以比较复杂是因为它建立在操作系统的复杂性之上。 如果你想学到更多关于信号量的知识，看看这个链接它更细致地讨论了信号量理论。如果你是学术型，那可以看一个软件开发中经典的哲学家进餐问题，它需要使用信号量来解决。 信号量让你控制多个消费者对有限数量资源的访问。举例来说，如果你创建了一个有着两个资源的信号量，那同时最多只能有两个线程可以访问临界区。其他想使用资源的线程必须在一个…你猜到了吗？…FIFO队列里等待。 让我们来使用信号量吧！ 打开 GooglyPuffTests.m 并用下列实现替换 downloadImageURLWithString:： 1234567891011121314151617181920212223- (void)downloadImageURLWithString:(NSString *)URLString&#123; // 1 dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); NSURL *url = [NSURL URLWithString:URLString]; __unused Photo *photo = [[Photo alloc] initwithURL:url withCompletionBlock:^(UIImage *image, NSError *error) &#123; if (error) &#123; XCTFail(@&quot;%@ failed. %@&quot;, URLString, error); &#125; // 2 dispatch_semaphore_signal(semaphore); &#125;]; // 3 dispatch_time_t timeoutTime = dispatch_time(DISPATCH_TIME_NOW, kDefaultTimeoutLengthInNanoSeconds); if (dispatch_semaphore_wait(semaphore, timeoutTime)) &#123; XCTFail(@&quot;%@ timed out&quot;, URLString); &#125;&#125; 下面来说明你代码中的信号量是如何工作的： 创建一个信号量。参数指定信号量的起始值。这个数字是你可以访问的信号量，不需要有人先去增加它的数量。（注意到增加信号量也被叫做发射信号量）。译者注：这里初始化为0，也就是说，有人想使用信号量必然会被阻塞，直到有人增加信号量。 在 Completion Block 里你告诉信号量你不再需要资源了。这就会增加信号量的计数并告知其他想使用此资源的线程。 这会在超时之前等待信号量。这个调用阻塞了当前线程直到信号量被发射。这个函数的一个非零返回值表示到达超时了。在这个例子里，测试将会失败因为它以为网络请求不会超过 10 秒钟就会返回——一个平衡点！ 再次运行测试。只要你有一个正常工作的网络连接，这个测试就会马上成功。请特别注意 CPU 的使用率，与之前使用自旋锁的实现作个对比。 关闭你的网络链接再运行测试；如果你在真机上运行，就打开飞行模式。如果你的在模拟器里运行，你可以直接断开 Mac 的网络链接。测试会在 10 秒后失败。这很棒，它真的能按照预想的那样工作！ 还有一些琐碎的测试，但如果你与一个服务器组协同工作，那么这些基本的测试能够防止其他人就最新的网络问题对你说三道四。 使用 Dispatch SourceGCD 的一个特别有趣的特性是 Dispatch Source，它基本上就是一个低级函数的 grab-bag ，能帮助你去响应或监测 Unix 信号、文件描述符、Mach 端口、VFS 节点，以及其它晦涩的东西。所有这些都超出了本教程讨论的范围，但你可以通过实现一个 Dispatch Source 对象并以一个相当奇特的方式来使用它来品尝那些晦涩的东西。 第一次使用 Dispatch Source 可能会迷失在如何使用一个源，所以你需要知晓的第一件事是 dispatch_source_create 如何工作。下面是创建一个源的函数原型： 12345dispatch_source_t dispatch_source_create( dispatch_source_type_t type, uintptr_t handle, unsigned long mask, dispatch_queue_t queue); 第一个参数是 dispatch_source_type_t 。这是最重要的参数，因为它决定了 handle 和 mask 参数将会是什么。你可以查看 Xcode 文档 得到哪些选项可用于每个 dispatch_source_type_t 参数。 下面你将监控 DISPATCH_SOURCE_TYPE_SIGNAL 。如文档所显示的： 一个监控当前进程信号的 Dispatch Source。 handle 是信号编号，mask 未使用（传 0 即可）。 这些 Unix 信号组成的列表可在头文件 signal.h 中找到。在其顶部有一堆 #define 语句。你将监控此信号列表中的 SIGSTOP 信号。这个信号将会在进程接收到一个无法回避的暂停指令时被发出。在你用 LLDB 调试器调试应用时你使用的也是这个信号。 去往 PhotoCollectionViewController.m 并添加如下代码到 viewDidLoad 的顶部，就在 [super viewDidLoad] 下面： 123456789101112131415161718192021222324252627282930313233343536- (void)viewDidLoad&#123; [super viewDidLoad]; // 1 #if DEBUG // 2 dispatch_queue_t queue = dispatch_get_main_queue(); // 3 static dispatch_source_t source = nil; // 4 __typeof(self) __weak weakSelf = self; // 5 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // 6 source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGSTOP, 0, queue); // 7 if (source) &#123; // 8 dispatch_source_set_event_handler(source, ^&#123; // 9 NSLog(@&quot;Hi, I am: %@&quot;, weakSelf); &#125;); dispatch_resume(source); // 10 &#125; &#125;); #endif // The other stuff&#125; 这些代码有点儿复杂，所以跟着注释一步步走，看看到底发生了什么： 最好是在 DEBUG 模式下编译这些代码，因为这会给“有关方面（Interested Parties）”很多关于你应用的洞察。 :] Just to mix things up，你创建了一个 dispatch_queue_t 实例变量而不是在参数上直接使用函数。当代码变长，分拆有助于可读性。 你需要 source 在方法范围之外也可被访问，所以你使用了一个 static 变量。 使用 weakSelf 以确保不会出现保留环（Retain Cycle）。这对 PhotoCollectionViewController 来说不是完全必要的，因为它会在应用的整个生命期里保持活跃。然而，如果你有任何其它会消失的类，这就能确保不会出现保留环而造成内存泄漏。 使用 dispatch_once 确保只会执行一次 Dispatch Source 的设置。 初始化 source 变量。你指明了你对信号监控感兴趣并提供了 SIGSTOP 信号作为第二个参数。进一步，你使用主队列处理接收到的事件——很快你就好发现为何要这样做。 如果你提供的参数不合格，那么 Dispatch Source 对象不会被创建。也就是说，在你开始在其上工作之前，你需要确保已有了一个有效的 Dispatch Source 。 当你收到你所监控的信号时，dispatch_source_set_event_handler 就会执行。之后你可以在其 Block 里设置合适的逻辑处理器（Logic Handler）。 一个基本的 NSLog 语句，它将对象打印到控制台。 默认的，所有源都初始为暂停状态。如果你要开始监控事件，你必须告诉源对象恢复活跃状态。 编译并运行应用；在调试器里暂停并立即恢复应用，查看控制台，你会看到这个来自黑暗艺术的函数确实可以工作。你看到的大概如下： 12014-03-29 17:41:30.610 GooglyPuff[8181:60b] Hi, I am: 你的应用现在具有调试感知了！这真是超级棒，但在真实世界里该如何使用它呢？ 你可以用它去调试一个对象并在任何你想恢复应用的时候显示数据；你同样能给你的应用加上自定义的安全逻辑以便在恶意攻击者将一个调试器连接到你的应用上时保护它自己（或用户的数据）。 译者注：好像挺有用！ 一个有趣的主意是，使用此方式的作为一个堆栈追踪工具去找到你想在调试器里操纵的对象。 稍微想想这个情况。当你意外地停止调试器，你几乎从来都不会在所需的栈帧上。现在你可以在任何时候停止调试器并在你所需的地方执行代码。如果你想在你的应用的某一点执行的代码非常难以从调试器访问的话，这会非常有用。有机会试试吧！ 将一个断点放在你刚添加在 viewDidLoad 里的事件处理器的 NSLog 语句上。在调试器里暂停，然后再次开始；应用会到达你添加的断点。现在你深入到你的 PhotoCollectionViewController 方法深处。你可以访问 PhotoCollectionViewController 的实例得到你关心的内容。非常方便！ 注意：如果你还没有注意到在调试器里的是哪个线程，那现在就看看它们。主线程总是第一个被 libdispatch 跟随，它是 GCD 的坐标，作为第二个线程。之后，线程计数和剩余线程取决于硬件在应用到达断点时正在做的事情。 在调试器里，键入命令：po [[weakSelf navigationItem] setPrompt:@&quot;WOOT!&quot;] 然后恢复应用的执行。你会看到如下内容： 使用这个方法，你可以更新 UI、查询类的属性，甚至是执行方法——所有这一切都不需要重启应用并到达某个特定的工作状态。相当优美吧！ 译者注：发挥这一点，是可以做出一些调试库的吧？ 之后又该往何处去？你可以在此下载最终的项目。 我讨厌再次提及此主题，但你真的要看看 如何使用 Instruments 教程。如果你计划优化你的应用，那你一定要学会使用它。请注意 Instruments 擅长于分析相对执行：比较哪些区域的代码相对于其它区域的代码花费了更长的时间。如果你尝试计算出某个方法实际的执行时间，那你可能需要拿出更多的自酿的解决方案（Home-brewed Solution）。 同样请看看 如何使用 NSOperations 和 NSOperationQueues 吧，它们是建立在 GCD 之上的并发技术。大体来说，如果你在写简单的用过就忘的任务，那它们就是使用 GCD 的最佳实践，。NSOperations 提供更好的控制、处理大量并发操作的实现，以及一个以速度为代价的更加面向对象的范例。 记住，除非你有特别的原因要往下流走（译者的玩笑：即使用低级别 API），否则永远应尝试并坚持使用高级的 API。如果你想学到更多或想做某些非常非常“有趣”的事情，那你就应该冒险进入 Apple 的黑暗艺术。 祝你好运，玩得开心！有任何问题或反馈请在下方的讨论区贴出！ 文章转自 https://github.com/nixzhu/dev-blog]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转 - GCD 深入理解之一]]></title>
    <url>%2F2017%2F08%2F06%2F00-%E6%8A%80%E6%9C%AF-iOS%2F%E8%BD%AC-GCD-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8B%E4%B8%80%2F</url>
    <content type="text"><![CDATA[文章转自 https://github.com/nixzhu/dev-blog 虽然 GCD 已经出现过一段时间了，但不是每个人都明了其主要内容。这是可以理解的；并发一直很棘手，而 GCD 是基于 C 的 API ，它们就像一组尖锐的棱角戳进 Objective-C 的平滑世界。我们将分两个部分的教程来深入学习 GCD 。 在这两部分的系列中，第一个部分的将解释 GCD 是做什么的，并从许多基本的 GCD 函数中找出几个来展示。在第二部分，你将学到几个 GCD 提供的高级函数。 什么是 GCDGCD 是 libdispatch 的市场名称，而 libdispatch 作为 Apple 的一个库，为并发代码在多核硬件（跑 iOS 或 OS X ）上执行提供有力支持。它具有以下优点： GCD 能通过推迟昂贵计算任务并在后台运行它们来改善你的应用的响应性能。 GCD 提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱。 GCD 具有在常见模式（例如单例）上用更高性能的原语优化你的代码的潜在能力。 本教程假设你对 Block 和 GCD 有基础了解。如果你对 GCD 完全陌生，先看看 iOS 上的多线程和 GCD 入门教程 学习其要领。 GCD 术语要理解 GCD ，你要先熟悉与线程和并发相关的几个概念。这两者都可能模糊和微妙，所以在开始 GCD 之前先简要地回顾一下它们。 Serial vs. Concurrent 串行 vs. 并发这些术语描述当任务相对于其它任务被执行，任务串行执行就是每次只有一个任务被执行，任务并发执行就是在同一时间可以有多个任务被执行。 虽然这些术语被广泛使用，本教程中你可以将任务设定为一个 Objective-C 的 Block 。不明白什么是 Block ？看看 iOS 5 教程中的如何使用 Block 。实际上，你也可以在 GCD 上使用函数指针，但在大多数场景中，这实际上更难于使用。Block 就是更加容易些！ Synchronous vs. Asynchronous 同步 vs. 异步在 GCD 中，这些术语描述当一个函数相对于另一个任务完成，此任务是该函数要求 GCD 执行的。一个_同步_函数只在完成了它预定的任务后才返回。 一个_异步_函数，刚好相反，会立即返回，预定的任务会完成但不会等它完成。因此，一个异步函数不会阻塞当前线程去执行下一个函数。 注意——当你读到同步函数“阻塞（Block）”当前线程，或函数是一个“阻塞”函数或阻塞操作时，不要被搞糊涂了！动词“阻塞”描述了函数如何影响它所在的线程而与名词“代码块（Block）”没有关系。代码块描述了用 Objective-C 编写的一个匿名函数，它能定义一个任务并被提交到 GCD 。 译者注：中文不会有这个问题，“阻塞”和“代码块”是两个词。 Critical Section 临界区就是一段代码不能被并发执行，也就是，两个线程不能同时执行这段代码。这很常见，因为代码去操作一个共享资源，例如一个变量若能被并发进程访问，那么它很可能会变质（译者注：它的值不再可信）。 Race Condition 竞态条件这种状况是指基于特定序列或时机的事件的软件系统以不受控制的方式运行的行为，例如程序的并发任务执行的确切顺序。竞态条件可导致无法预测的行为，而不能通过代码检查立即发现。 Deadlock 死锁两个（有时更多）东西——在大多数情况下，是线程——所谓的死锁是指它们都卡住了，并等待对方完成或执行其它操作。第一个不能完成是因为它在等待第二个的完成。但第二个也不能完成，因为它在等待第一个的完成。 Thread Safe 线程安全线程安全的代码能在多线程或并发任务中被安全的调用，而不会导致任何问题（数据损坏，崩溃，等）。线程不安全的代码在某个时刻只能在一个上下文中运行。一个线程安全代码的例子是 NSDictionary 。你可以在同一时间在多个线程中使用它而不会有问题。另一方面，NSMutableDictionary 就不是线程安全的，应该保证一次只能有一个线程访问它。 Context Switch 上下文切换一个上下文切换指当你在单个进程里切换执行不同的线程时存储与恢复执行状态的过程。这个过程在编写多任务应用时很普遍，但会带来一些额外的开销。 Concurrency vs Parallelism 并发与并行并发和并行通常被一起提到，所以值得花些时间解释它们之间的区别。 并发代码的不同部分可以“同步”执行。然而，该怎样发生或是否发生都取决于系统。多核设备通过并行来同时执行多个线程；然而，为了使单核设备也能实现这一点，它们必须先运行一个线程，执行一个上下文切换，然后运行另一个线程或进程。这通常发生地足够快以致给我们并发执行地错觉，如下图所示： 虽然你可以编写代码在 GCD 下并发执行，但 GCD 会决定有多少并行的需求。并行_要求并发，但并发并不能保证_并行。 更深入的观点是并发实际上是关于_构造_。当你在脑海中用 GCD 编写代码，你组织你的代码来暴露能同时运行的多个工作片段，以及不能同时运行的那些。如果你想深入此主题，看看 这个由Rob Pike做的精彩的讲座 。 Queues 队列GCD 提供有 dispatch queues 来处理代码块，这些队列管理你提供给 GCD 的任务并用 FIFO 顺序执行这些任务。这就保证了第一个被添加到队列里的任务会是队列中第一个开始的任务，而第二个被添加的任务将第二个开始，如此直到队列的终点。 所有的调度队列（dispatch queues）自身都是线程安全的，你能从多个线程并行的访问它们。当你了解了调度队列如何为你自己代码的不同部分提供线程安全后，GCD的优点就是显而易见的。关于这一点的关键是选择正确_类型的调度队列和正确的调度函数_来提交你的工作。 在本节你会看到两种调度队列，都是由 GCD 提供的，然后看一些描述如何用调度函数添加工作到队列的例子。 Serial Queues 串行队列串行队列中的任务一次执行一个，每个任务只在前一个任务完成时才开始。而且，你不知道在一个 Block 结束和下一个开始之间的时间长度，如下图所示： 这些任务的执行时机受到 GCD 的控制；唯一能确保的事情是 GCD 一次只执行一个任务，并且按照我们添加到队列的顺序来执行。 由于在串行队列中不会有两个任务并发运行，因此不会出现同时访问临界区的风险；相对于这些任务来说，这就从竞态条件下保护了临界区。所以如果访问临界区的唯一方式是通过提交到调度队列的任务，那么你就不需要担心临界区的安全问题了。 Concurrent Queues 并发队列在并发队列中的任务能得到的保证是它们会按照被添加的顺序开始执行，但这就是全部的保证了。任务可能以任意顺序完成，你不会知道何时开始运行下一个任务，或者任意时刻有多少 Block 在运行。再说一遍，这完全取决于 GCD 。 下图展示了一个示例任务执行计划，GCD 管理着四个并发任务： 注意 Block 1,2 和 3 都立马开始运行，一个接一个。在 Block 0 开始后，Block 1等待了好一会儿才开始。同样， Block 3 在 Block 2 之后才开始，但它先于 Block 2 完成。 何时开始一个 Block 完全取决于 GCD 。如果一个 Block 的执行时间与另一个重叠，也是由 GCD 来决定是否将其运行在另一个不同的核心上，如果那个核心可用，否则就用上下文切换的方式来执行不同的 Block 。 有趣的是， GCD 提供给你至少五个特定的队列，可根据队列类型选择使用。 Queue Types 队列类型首先，系统提供给你一个叫做 主队列（main queue） 的特殊队列。和其它串行队列一样，这个队列中的任务一次只能执行一个。然而，它能保证所有的任务都在主线程执行，而主线程是唯一可用于更新 UI 的线程。这个队列就是用于发生消息给 UIView 或发送通知的。 系统同时提供给你好几个并发队列。它们叫做 全局调度队列（Global Dispatch Queues） 。目前的四个全局队列有着不同的优先级：background、low、default 以及 high。要知道，Apple 的 API 也会使用这些队列，所以你添加的任何任务都不会是这些队列中唯一的任务。 最后，你也可以创建自己的串行队列或并发队列。这就是说，至少有_五个_队列任你处置：主队列、四个全局调度队列，再加上任何你自己创建的队列。 以上是调度队列的大框架！ GCD 的“艺术”归结为选择合适的队列来调度函数以提交你的工作。体验这一点的最好方式是走一遍下边的列子，我们沿途会提供一些一般性的建议。 入门既然本教程的目标是优化且安全的使用 GCD 调用来自不同线程的代码，那么你将从一个近乎完成的叫做 GooglyPuff 的项目入手。 GooglyPuff 是一个没有优化，线程不安全的应用，它使用 Core Image 的人脸检测 API 来覆盖一对曲棍球眼睛到被检测到的人脸上。对于基本的图像，可以从相机胶卷选择，或用预设好的URL从互联网下载。 点击此处下载项目 完成项目下载之后，将其解压到某个方便的目录，再用 Xcode 打开它并编译运行。这个应用看起来如下图所示： 注意当你选择 Le Internet 选项下载图片时，一个 UIAlertView 过早地弹出。你将在本系列教程地第二部分修复这个问题。 这个项目中有四个有趣的类： PhotoCollectionViewController：它是应用开始的第一个视图控制器。它用缩略图展示所有选定的照片。 PhotoDetailViewController：它执行添加曲棍球眼睛到图像上的逻辑，并用一个 UIScrollView 来显示结果图片。 Photo：这是一个类簇，它根据一个 NSURL 的实例或一个 ALAsset 的实例来实例化照片。这个类提供一个图像、缩略图以及从 URL 下载的状态。 PhotoManager：它管理所有 Photo 的实例. 用 dispatch_async 处理后台任务回到应用并从你的相机胶卷添加一些照片或使用 Le Internet 选项下载一些。 注意在按下 PhotoCollectionViewController 中的一个 UICollectionViewCell 到生成一个新的 PhotoDetailViewController 之间花了多久时间；你会注意到一个明显的滞后，特别是在比较慢的设备上查看很大的图。 在重载 UIViewController 的 viewDidLoad 时容易加入太多杂乱的工作（too much clutter），这通常会引起视图控制器出现前更长的等待。如果可能，最好是卸下一些工作放到后台，如果它们不是绝对必须要运行在加载时间里。 这听起来像是 dispatch_async 能做的事情！ 打开 PhotoDetailViewController 并用下面的实现替换 viewDidLoad ： 12345678910111213141516171819- (void)viewDidLoad&#123; [super viewDidLoad]; NSAssert(_image, @&quot;Image not set; required to use view controller&quot;); self.photoImageView.image = _image; //Resize if neccessary to ensure it&apos;s not pixelated if (_image.size.height &lt;= self.photoImageView.bounds.size.height &amp;&amp; _image.size.width &lt;= self.photoImageView.bounds.size.width) &#123; [self.photoImageView setContentMode:UIViewContentModeCenter]; &#125; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; // 1 UIImage *overlayImage = [self faceOverlayImageFromImage:_image]; dispatch_async(dispatch_get_main_queue(), ^&#123; // 2 [self fadeInNewImage:overlayImage]; // 3 &#125;); &#125;);&#125; 下面来说明上面的新代码所做的事： 你首先将工作从主线程移到全局线程。因为这是一个 dispatch_async() ，Block 会被异步地提交，意味着调用线程地执行将会继续。这就使得 viewDidLoad 更早地在主线程完成，让加载过程感觉起来更加快速。同时，一个人脸检测过程会启动并将在稍后完成。 在这里，人脸检测过程完成，并生成了一个新的图像。既然你要使用此新图像更新你的 UIImageView ，那么你就添加一个新的 Block 到主线程。记住——你必须总是在主线程访问 UIKit 的类。 最后，你用 fadeInNewImage: 更新 UI ，它执行一个淡入过程切换到新的曲棍球眼睛图像。 编译并运行你的应用；选择一个图像然后你会注意到视图控制器加载明显变快，曲棍球眼睛稍微在之后就加上了。这给应用带来了不错的效果，和之前的显示差别巨大。 进一步，如果你试着加载一个超大的图像，应用不会在加载视图控制器上“挂住”，这就使得应用具有很好伸缩性。 正如之前提到的， dispatch_async 添加一个 Block 到队列就立即返回了。任务会在之后由 GCD 决定执行。当你需要在后台执行一个基于网络或 CPU 紧张的任务时就使用 dispatch_async ，这样就不会阻塞当前线程。 下面是一个关于在 dispatch_async 上如何以及何时使用不同的队列类型的快速指导： 自定义串行队列：当你想串行执行后台任务并追踪它时就是一个好选择。这消除了资源争用，因为你知道一次只有一个任务在执行。注意若你需要来自某个方法的数据，你必须内联另一个 Block 来找回它或考虑使用 dispatch_sync。 主队列（串行）：这是在一个并发队列上完成任务后更新 UI 的共同选择。要这样做，你将在一个 Block 内部编写另一个 Block 。以及，如果你在主队列调用 dispatch_async 到主队列，你能确保这个新任务将在当前方法完成后的某个时间执行。 并发队列：这是在后台执行非 UI 工作的共同选择。 使用 dispatch_after 延后工作稍微考虑一下应用的 UX 。是否用户第一次打开应用时会困惑于不知道做什么？你是这样吗？ :] 如果用户的 PhotoManager 里还没有任何照片，那么显示一个提示会是个好主意！然而，你同样要考虑用户的眼睛会如何在主屏幕上浏览：如果你太快的显示一个提示，他们的眼睛还徘徊在视图的其它部分上，他们很可能会错过它。 显示提示之前延迟一秒钟就足够捕捉到用户的注意，他们此时已经第一次看过了应用。 添加如下代码到到 PhotoCollectionViewController.m 中 showOrHideNavPrompt 的废止实现里： 12345678910111213- (void)showOrHideNavPrompt&#123; NSUInteger count = [[PhotoManager sharedManager] photos].count; double delayInSeconds = 1.0; dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC)); // 1 dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123; // 2 if (!count) &#123; [self.navigationItem setPrompt:@&quot;Add photos with faces to Googlyify them!&quot;]; &#125; else &#123; [self.navigationItem setPrompt:nil]; &#125; &#125;);&#125; showOrHideNavPrompt 在 viewDidLoad 中执行，以及 UICollectionView 被重新加载的任何时候。按照注释数字顺序看看： 你声明了一个变量指定要延迟的时长。 然后等待 delayInSeconds 给定的时长，再异步地添加一个 Block 到主线程。 编译并运行应用。应该有一个轻微地延迟，这有助于抓住用户的注意力并展示所要做的事情。 dispatch_after 工作起来就像一个延迟版的 dispatch_async 。你依然不能控制实际的执行时间，且一旦 dispatch_after 返回也就不能再取消它。 不知道何时适合使用 dispatch_after ？ 自定义串行队列：在一个自定义串行队列上使用 dispatch_after 要小心。你最好坚持使用主队列。 主队列（串行）：是使用 dispatch_after 的好选择；Xcode 提供了一个不错的自动完成模版。 并发队列：在并发队列上使用 dispatch_after 也要小心；你会这样做就比较罕见。还是在主队列做这些操作吧。 让你的单例线程安全单例，不论喜欢还是讨厌，它们在 iOS 上的流行情况就像网上的猫。 :] 一个常见的担忧是它们常常不是线程安全的。这个担忧十分合理，基于它们的用途：单例常常被多个控制器同时访问。 单例的线程担忧范围从初始化开始，到信息的读和写。PhotoManager 类被实现为单例——它在目前的状态下就会被这些问题所困扰。要看看事情如何很快地失去控制，你将在单例实例上创建一个控制好的竞态条件。 导航到 PhotoManager.m 并找到 sharedManager ；它看起来如下： 123456789+ (instancetype)sharedManager &#123; static PhotoManager *sharedPhotoManager = nil; if (!sharedPhotoManager) &#123; sharedPhotoManager = [[PhotoManager alloc] init]; sharedPhotoManager-&gt;_photosArray = [NSMutableArray array]; &#125; return sharedPhotoManager;&#125; 当前状态下，代码相当简单；你创建了一个单例并初始化一个叫做 photosArray 的 NSMutableArray 属性。 然而，if 条件分支不是线程安全的；如果你多次调用这个方法，有一个可能性是在某个线程（就叫它线程A）上进入 if 语句块并可能在 sharedPhotoManager 被分配内存前发生一个上下文切换。然后另一个线程（线程B）可能进入 if ，分配单例实例的内存，然后退出。 当系统上下文切换回线程A，你会分配另外一个单例实例的内存，然后退出。在那个时间点，你有了两个单例的实例——很明显这不是你想要的（译者注：这还能叫单例吗？）！ 要强制这个（竞态）条件发生，替换 PhotoManager.m 中的 sharedManager 为下面的实现： 123456789101112+ (instancetype)sharedManager &#123; static PhotoManager *sharedPhotoManager = nil; if (!sharedPhotoManager) &#123; [NSThread sleepForTimeInterval:2]; sharedPhotoManager = [[PhotoManager alloc] init]; NSLog(@&quot;Singleton has memory address at: %@&quot;, sharedPhotoManager); [NSThread sleepForTimeInterval:2]; sharedPhotoManager-&gt;_photosArray = [NSMutableArray array]; &#125; return sharedPhotoManager;&#125; 上面的代码中你用 NSThread 的 sleepForTimeInterval: 类方法来强制发生一个上下文切换。 打开 AppDelegate.m 并添加如下代码到 application:didFinishLaunchingWithOptions: 的最开始处： 1234567dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; [PhotoManager sharedManager];&#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; [PhotoManager sharedManager];&#125;); 这里创建了多个异步并发调用来实例化单例，然后引发上面描述的竞态条件。 编译并运行项目；查看控制台输出，你会看到多个单例被实例化，如下所示： 注意到这里有好几行显示着不同地址的单例实例。这明显违背了单例的目的，对吧？:] 这个输出向你展示了临界区被执行多次，而它只应该执行一次。现在，固然是你自己强制这样的状况发生，但你可以想像一下这个状况会怎样在无意间发生。 注意：基于其它你无法控制的系统事件，NSLog 的数量有时会显示多个。线程问题极其难以调试，因为它们往往难以重现。 要纠正这个状况，实例化代码应该只执行一次，并阻塞其它实例在 if 条件的临界区运行。这刚好就是 dispatch_once 能做的事。 在单例初始化方法中用 dispatch_once 取代 if 条件判断，如下所示： 12345678910111213+ (instancetype)sharedManager&#123; static PhotoManager *sharedPhotoManager = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [NSThread sleepForTimeInterval:2]; sharedPhotoManager = [[PhotoManager alloc] init]; NSLog(@&quot;Singleton has memory address at: %@&quot;, sharedPhotoManager); [NSThread sleepForTimeInterval:2]; sharedPhotoManager-&gt;_photosArray = [NSMutableArray array]; &#125;); return sharedPhotoManager;&#125; 编译并运行你的应用；查看控制台输出，你会看到有且仅有一个单例的实例——这就是你对单例的期望！:] 现在你已经明白了防止竞态条件的重要性，从 AppDelegate.m 中移除 dispatch_async 语句，并用下面的实现替换 PhotoManager 单例的初始化： 12345678910+ (instancetype)sharedManager&#123; static PhotoManager *sharedPhotoManager = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; sharedPhotoManager = [[PhotoManager alloc] init]; sharedPhotoManager-&gt;_photosArray = [NSMutableArray array]; &#125;); return sharedPhotoManager;&#125; dispatch_once() 以线程安全的方式执行且仅执行其代码块一次。试图访问临界区（即传递给 dispatch_once 的代码）的不同的线程会在临界区已有一个线程的情况下被阻塞，直到临界区完成为止。 需要记住的是，这只是让访问共享实例线程安全。它绝对没有让类本身线程安全。类中可能还有其它竞态条件，例如任何操纵内部数据的情况。这些需要用其它方式来保证线程安全，例如同步访问数据，你将在下面几个小节看到。 处理读者与写者问题线程安全实例不是处理单例时的唯一问题。如果单例属性表示一个可变对象，那么你就需要考虑是否那个对象自身线程安全。 如果问题中的这个对象是一个 Foundation 容器类，那么答案是——“很可能不安全”！Apple 维护一个有用且有些心寒的列表，众多的 Foundation 类都不是线程安全的。 NSMutableArray，已用于你的单例，正在那个列表里休息。 虽然许多线程可以同时读取 NSMutableArray 的一个实例而不会产生问题，但当一个线程正在读取时让另外一个线程修改数组就是不安全的。你的单例在目前的状况下不能预防这种情况的发生。 要分析这个问题，看看 PhotoManager.m 中的 addPhoto:，转载如下： 123456789- (void)addPhoto:(Photo *)photo&#123; if (photo) &#123; [_photosArray addObject:photo]; dispatch_async(dispatch_get_main_queue(), ^&#123; [self postContentAddedNotification]; &#125;); &#125;&#125; 这是一个写方法，它修改一个私有可变数组对象。 现在看看 photos ，转载如下： 1234- (NSArray *)photos&#123; return [NSArray arrayWithArray:_photosArray];&#125; 这是所谓的读方法，它读取可变数组。它为调用者生成一个不可变的拷贝，防止调用者不当地改变数组，但这不能提供任何保护来对抗当一个线程调用读方法 photos 的同时另一个线程调用写方法 addPhoto: 。 这就是软件开发中经典的读者写者问题。GCD 通过用 dispatch barriers 创建一个读者写者锁 提供了一个优雅的解决方案。 Dispatch barriers 是一组函数，在并发队列上工作时扮演一个串行式的瓶颈。使用 GCD 的障碍（barrier）API 确保提交的 Block 在那个特定时间上是指定队列上唯一被执行的条目。这就意味着所有的先于调度障碍提交到队列的条目必能在这个 Block 执行前完成。 当这个 Block 的时机到达，调度障碍执行这个 Block 并确保在那个时间里队列不会执行任何其它 Block 。一旦完成，队列就返回到它默认的实现状态。 GCD 提供了同步和异步两种障碍函数。 下图显示了障碍函数对多个异步队列的影响： 注意到正常部分的操作就如同一个正常的并发队列。但当障碍执行时，它本质上就如同一个串行队列。也就是，障碍是唯一在执行的事物。在障碍完成后，队列回到一个正常并发队列的样子。 下面是你何时会——和不会——使用障碍函数的情况： 自定义串行队列：一个很坏的选择；障碍不会有任何帮助，因为不管怎样，一个串行队列一次都只执行一个操作。 全局并发队列：要小心；这可能不是最好的主意，因为其它系统可能在使用队列而且你不能垄断它们只为你自己的目的。 自定义并发队列：这对于原子或临界区代码来说是极佳的选择。任何你在设置或实例化的需要线程安全的事物都是使用障碍的最佳候选。 由于上面唯一像样的选择是自定义并发队列，你将创建一个你自己的队列去处理你的障碍函数并分开读和写函数。且这个并发队列将允许多个多操作同时进行。 打开 PhotoManager.m，添加如下私有属性到类扩展中： 1234@interface PhotoManager ()@property (nonatomic,strong,readonly) NSMutableArray *photosArray;@property (nonatomic, strong) dispatch_queue_t concurrentPhotoQueue; ///&lt; Add this@end 找到 addPhoto: 并用下面的实现替换它： 1234567891011- (void)addPhoto:(Photo *)photo&#123; if (photo) &#123; // 1 dispatch_barrier_async(self.concurrentPhotoQueue, ^&#123; // 2 [_photosArray addObject:photo]; // 3 dispatch_async(dispatch_get_main_queue(), ^&#123; // 4 [self postContentAddedNotification]; &#125;); &#125;); &#125;&#125; 你新写的函数是这样工作的： 在执行下面所有的工作前检查是否有合法的相片。 添加写操作到你的自定义队列。当临界区在稍后执行时，这将是你队列中唯一执行的条目。 这是添加对象到数组的实际代码。由于它是一个障碍 Block ，这个 Block 永远不会同时和其它 Block 一起在 concurrentPhotoQueue 中执行。 最后你发送一个通知说明完成了添加图片。这个通知将在主线程被发送因为它将会做一些 UI 工作，所以在此为了通知，你异步地调度另一个任务到主线程。 这就处理了写操作，但你还需要实现 photos 读方法并实例化 concurrentPhotoQueue 。 在写者打扰的情况下，要确保线程安全，你需要在 concurrentPhotoQueue 队列上执行读操作。既然你需要从函数返回，你就不能异步调度到队列，因为那样在读者函数返回之前不一定运行。 在这种情况下，dispatch_sync 就是一个绝好的候选。 dispatch_sync() 同步地提交工作并在返回前等待它完成。使用 dispatch_sync 跟踪你的调度障碍工作，或者当你需要等待操作完成后才能使用 Block 处理过的数据。如果你使用第二种情况做事，你将不时看到一个 __block 变量写在 dispatch_sync 范围之外，以便返回时在 dispatch_sync 使用处理过的对象。 但你需要很小心。想像如果你调用 dispatch_sync 并放在你已运行着的当前队列。这会导致死锁，因为调用会一直等待直到 Block 完成，但 Block 不能完成（它甚至不会开始！），直到当前已经存在的任务完成，而当前任务无法完成！这将迫使你自觉于你正从哪个队列调用——以及你正在传递进入哪个队列。 下面是一个快速总览，关于在何时以及何处使用 dispatch_sync ： 自定义串行队列：在这个状况下要非常小心！如果你正运行在一个队列并调用 dispatch_sync 放在同一个队列，那你就百分百地创建了一个死锁。 主队列（串行）：同上面的理由一样，必须非常小心！这个状况同样有潜在的导致死锁的情况。 并发队列：这才是做同步工作的好选择，不论是通过调度障碍，或者需要等待一个任务完成才能执行进一步处理的情况。 继续在 PhotoManager.m 上工作，用下面的实现替换 photos ： 12345678- (NSArray *)photos&#123; __block NSArray *array; // 1 dispatch_sync(self.concurrentPhotoQueue, ^&#123; // 2 array = [NSArray arrayWithArray:_photosArray]; // 3 &#125;); return array;&#125; 这就是你的读函数。按顺序看看编过号的注释，有这些： __block 关键字允许对象在 Block 内可变。没有它，array 在 Block 内部就只是只读的，你的代码甚至不能通过编译。 在 concurrentPhotoQueue 上同步调度来执行读操作。 将相片数组存储在 array 内并返回它。 最后，你需要实例化你的 concurrentPhotoQueue 属性。修改 sharedManager 以便像下面这样初始化队列： 123456789101112131415+ (instancetype)sharedManager&#123; static PhotoManager *sharedPhotoManager = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; sharedPhotoManager = [[PhotoManager alloc] init]; sharedPhotoManager-&gt;_photosArray = [NSMutableArray array]; // ADD THIS: sharedPhotoManager-&gt;_concurrentPhotoQueue = dispatch_queue_create(&quot;com.selander.GooglyPuff.photoQueue&quot;, DISPATCH_QUEUE_CONCURRENT); &#125;); return sharedPhotoManager;&#125; 这里使用 dispatch_queue_create 初始化 concurrentPhotoQueue 为一个并发队列。第一个参数是反向DNS样式命名惯例；确保它是描述性的，将有助于调试。第二个参数指定你的队列是串行还是并发。 注意：当你在网上搜索例子时，你会经常看人们传递 0 或者 NULL 给 dispatch_queue_create 的第二个参数。这是一个创建串行队列的过时方式；明确你的参数总是更好。 恭喜——你的 PhotoManager 单例现在是线程安全的了。不论你在何处或怎样读或写你的照片，你都有这样的自信，即它将以安全的方式完成，不会出现任何惊吓。 A Visual Review of Queueing 队列的视觉回顾依然没有 100% 地掌握 GCD 的要领？确保你可以使用 GCD 函数轻松地创建简单的例子，使用断点和 NSLog 语句保证自己明白当下发生的情况。 我在下面提供了两个 GIF动画来帮助你巩固对 dispatch_async 和 dispatch_sync 的理解。包含在每个 GIF 中的代码可以提供视觉辅助；仔细注意 GIF 左边显示代码断点的每一步，以及右边相关队列的状态。 dispatch_sync 回顾123456789101112- (void)viewDidLoad&#123; [super viewDidLoad]; dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; NSLog(@&quot;First Log&quot;); &#125;); NSLog(@&quot;Second Log&quot;);&#125; 下面是图中几个步骤的说明： 主队列一路按顺序执行任务——接着是一个实例化 UIViewController 的任务，其中包含了 viewDidLoad 。 viewDidLoad 在主线程执行。 主线程目前在 viewDidLoad 内，正要到达 dispatch_sync 。 dispatch_sync Block 被添加到一个全局队列中，将在稍后执行。进程将在主线程挂起直到该 Block 完成。同时，全局队列并发处理任务；要记得 Block 在全局队列中将按照 FIFO 顺序出列，但可以并发执行。 全局队列处理 dispatch_sync Block 加入之前已经出现在队列中的任务。 终于，轮到 dispatch_sync Block 。 这个 Block 完成，因此主线程上的任务可以恢复。 viewDidLoad 方法完成，主队列继续处理其他任务。 dispatch_sync 添加任务到一个队列并等待直到任务完成。dispatch_async 做类似的事情，但不同之处是它不会等待任务的完成，而是立即继续“调用线程”的其它任务。 dispatch_async 回顾123456789101112- (void)viewDidLoad&#123; [super viewDidLoad]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; NSLog(@&quot;First Log&quot;); &#125;); NSLog(@&quot;Second Log&quot;);&#125; 主队列一路按顺序执行任务——接着是一个实例化 UIViewController 的任务，其中包含了 viewDidLoad 。 viewDidLoad 在主线程执行。 主线程目前在 viewDidLoad 内，正要到达 dispatch_async 。 dispatch_async Block 被添加到一个全局队列中，将在稍后执行。 viewDidLoad 在添加 dispatch_async 到全局队列后继续进行，主线程把注意力转向剩下的任务。同时，全局队列并发地处理它未完成地任务。记住 Block 在全局队列中将按照 FIFO 顺序出列，但可以并发执行。 添加到 dispatch_async 的代码块开始执行。 dispatch_async Block 完成，两个 NSLog 语句将它们的输出放在控制台上。 在这个特定的实例中，第二个 NSLog 语句执行，跟着是第一个 NSLog 语句。并不总是这样——着取决于给定时刻硬件正在做的事情，而且你无法控制或知晓哪个语句会先执行。“第一个” NSLog 在某些调用情况下会第一个执行。 下一步怎么走？在本教程中，你学习了如何让你的代码线程安全，以及在执行 CPU 密集型任务时如何保持主线程的响应性。 你可以下载 GooglyPuff 项目，它包含了目前所有本教程中编写的实现。在本教程的第二部分，你将继续改进这个项目。 如果你计划优化你自己的应用，那你应该用 Instruments 中的 Time Profile 模版分析你的工作。对这个工具的使用超出了本教程的范围，你可以看看 如何使用Instruments 来得到一个很好的概述。 同时请确保在真实设备上分析，而在模拟器上测试会对程序速度产生非常不准确的印象。 在教程的下一部分，你将更加深入到 GCD 的 API 中，做一些更 Cool 的东西。 如果你有任何问题或评论，可自由地加入下方的讨论！ 文章转自 https://github.com/nixzhu/dev-blog]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS状态栏操作]]></title>
    <url>%2F2017%2F08%2F03%2F00-%E6%8A%80%E6%9C%AF-iOS%2FiOS%E7%8A%B6%E6%80%81%E6%A0%8F%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[隐藏及显示问题 在iOS开发中，我们一般不会操作状态栏，最多在启动图隐藏状态栏，其他全部是显示状态，但有少数App可能会有特殊需求，如：阅读类App。下面来讲一讲iOS状态栏的一些操作问题 方案总结 在Info.plist 加 Status bar is initially hidden 在Info.plist 加 View controller-based status bar appearance 使用代码全局设置 1@property(readwrite, nonatomic,getter=isStatusBarHidden) BOOL statusBarHidden NS_DEPRECATED_IOS(2_0, 9_0, "Use -[UIViewController prefersStatusBarHidden]") __TVOS_PROHIBITED; 使用代码单独控制器设置 1(BOOL)prefersStatusBarHidden NS_AVAILABLE_IOS(7_0) __TVOS_PROHIBITED; // Defaults to NO 感觉各种方法特别乱，有一些可能是历史原因，如：UIApplication 全局设置的方法在iOS 9后已经不推荐使用。 操作方式 这里暂把代码全局设置的方式忽略不计。 启动界面的状态栏隐藏及显示（没有添加默认是 显示）Status bar is initially hidden YES隐藏 NO显示 App界面状态栏隐藏及显示（没有添加默认是显示）View controller-based status bar appearance 的设置必须在 Status bar is initially hidden 为YESYES显示 NO隐藏 在当个界面对状态栏隐藏及显示（没有添加默认是 显示）重写此方法，返回 YES隐藏 NO显示 123- (BOOL)prefersStatusBarHidden &#123;return YES;&#125; 必须保证View controller-based status bar appearance 置为YES的情况下 情况分类和Demo启动界面显示状态栏 + 全部界面显示状态栏 不做任何操作，默认即可 Demo 启动界面显示状态栏 + 全部界面隐藏状态栏 在Info.plist 加 View controller-based status bar appearance 设YES 全部控制器重写prefersStatusBarHidden 返回YES Demo) 启动界面显示状态栏 + 界面自定义状态栏的显示和隐藏 在Info.plist 加 View controller-based status bar appearance 设YES 在需要隐藏的控制器重写prefersStatusBarHidden 返回YES 在需要显示的控制器重写prefersStatusBarHidden 返回NO（或者不重写）Demo 启动界面隐藏状态栏 + 全部界面显示状态栏 在Info.plist 加 Status bar is initially hidden 设YES Demo 启动界面隐藏状态栏 + 全部界面隐藏状态栏 在Info.plist 加 Status bar is initially hidden 设YES 在Info.plist 加 View controller-based status bar appearance 设 NODemo 启动界面隐藏状态栏 + 界面自定义状态栏的显示和隐藏 在Info.plist 加 Status bar is initially hidden 设YES 在Info.plist 加 View controller-based status bar appearance 设YES（或者不加） 在需要隐藏的控制器重写prefersStatusBarHidden 返回YES 在需要显示的控制器重写prefersStatusBarHidden 返回NO（或者不重写）Demo 颜色问题 正在完善中…]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毕业两年的一点感悟和成长]]></title>
    <url>%2F2017%2F07%2F13%2F05-%E7%94%9F%E6%B4%BB-%E6%84%9F%E5%8F%B9%2F%E6%AF%95%E4%B8%9A%E4%B8%A4%E5%B9%B4%E7%9A%84%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F%E5%92%8C%E6%88%90%E9%95%BF%2F</url>
    <content type="text"><![CDATA[自15年踏出校门以来，经历了许许多多，已收获了许许多多，已想了许许多多。 教育的重要性 学历 学历是块敲门砖，还是挺重要的，不说清华北大，能上985、211就尽量吧。😭 偏科 尽量不要偏科把，呵呵，我也不想啊，不要认为你某一科很厉害，那可能只是表象，可以去各种奥赛上看看就知道。如果在这里也很牛，那么你肯定不偏科😀，说多了多少泪。 英语 谁叫美国这么强大呢，没办法，能学就学吧。起码比汉语好学吧，高考英语30分的经验告诉你。😭 工作公司选择 不签合同的公司，千万不要去，这好像的废话。但博主曾经就经历过，那叫一个酸爽，你懂的。 学习 没事多捣鼓，找找乐子也挺好的。 生活奶爸路过 2017-01 已升级为奶爸。😁老婆一个人带宝宝辛苦了。💪]]></content>
      <categories>
        <category>05-生活-感叹</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC与JavaScript交互]]></title>
    <url>%2F2017%2F06%2F03%2F00-%E6%8A%80%E6%9C%AF-iOS%2FOC%E4%B8%8EJavaScript%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[简单介绍 在我们平时的开发中，可能都会使用一下UIWebView或者WKWebview有时候需要一些简单的交互，如：Web想调用相机扫描二维码，扫描成功后APP端需给Web端做一定的反馈。下面以UIWebView为例简单模拟一个场景，Web端需要调起APP端扫描，同时扫描到内容后APP端把扫描的结果反馈给Web端 OC 调用 Web 的方法，实际是使用UIWebView的如下方法 1- (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script; 此方法给Web传递一段需要执行的JavaScript代码，而且是同步执行，建议不要直接使用[ ]调用 1[self.webView stringByEvaluatingJavaScriptFromString:javaScriptParameter]; 而是使用下面的方法 1- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait; Web端Web端代码123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; body&#123; margin-top: 50px; &#125; &lt;/style&gt; &lt;title&gt;测试网页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="idhong://liangdahong?method=scan&amp;callMethod=openCamera"&gt;扫描二维码做网页跳转&lt;/a&gt; &lt;p&gt;&lt;/p&gt; &lt;a href="idhong://liangdahong?method=scan&amp;callMethod=codingSearch"&gt;扫描二维码codingSearch搜索&lt;/a&gt; &lt;script type="text/javascript"&gt; function openCamera(str)&#123; alert("Web 提示 \n 扫描成功（" + str + ")准备跳转界面"); window.location.href = str; &#125; function codingSearch(str)&#123; window.location.href = "http://www.coding.so/s?kw=" + str; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 我们可以抽奖一个html文件保存如上h5代码,放入demo中。 APP端 我们创建demo，使用UIWebView价值刚才的html文件 实现如下协议 1234- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType;- (void)webViewDidStartLoad:(UIWebView *) webView;- (void)webViewDidFinishLoad:(UIWebView *) webView;- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error; 我们主要是如下方法里面操作 1- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType; 加载成功以后界面显示如下： 当点击 扫描二维码codingSearch搜索时会调用下面的方法 1- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType; 同时可以在方法里面做相关的操作，如果是指定的操作就调起相关功能，如：调起扫描等。当扫描成功以后使用 1- (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script; 反馈给Web端，当然这里的方法名等协议需要两端商量确定好即可。 推荐使用WebViewJavascriptBridge APP内加载H5 解析URL中的数据信息 12345678910111213141516171819202122232425262728293031323334353637// &lt;a href=&quot;idhong://liangdahong?method=scan&amp;callMethod=openCamera&quot;&gt;扫描二维码做网页跳转&lt;/a&gt;- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; // 获取URL NSURL *url = [request URL]; // url.scheme 获取协议 // url.host 主机地址 // url.query 参数 // 1 判断是否为自定义的协议 idhong://liangdahong?method=scan&amp;callMethod=openCamera if ([url.scheme isEqualToString:@&quot;idhong&quot;] &amp;&amp; [url.host isEqualToString:@&quot;liangdahong&quot;]) &#123; // 2 获取参数 NSMutableDictionary *mutableDictionary = [@&#123;&#125; mutableCopy]; [[url.query componentsSeparatedByString:@&quot;&amp;&quot;] enumerateObjectsUsingBlock:^(NSString * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; NSArray *arr = [obj componentsSeparatedByString:@&quot;=&quot;]; if (arr.count == 2) &#123; mutableDictionary[arr[0]] = arr[1]; &#125; &#125;]; // 3 获取JS调用OC的方法的方法名 NSString *method = mutableDictionary[@&quot;method&quot;]; // 4 获取OC回调的JS的方法的方法名 NSString *callMethod = mutableDictionary[@&quot;callMethod&quot;]; // 5 调用定义好的协议和相关方法 // 6 如果是调用扫描功能 if ([method isEqualToString:@&quot;scan&quot;]) &#123; BMScanVC *vc = [BMScanVC new]; vc.block = ^(NSString *scan) &#123; // 7 构建OC回调到js的 JavaScriptFromString NSString *javaScriptParameter = [NSString stringWithFormat:@&quot;%@(\&quot;%@\&quot;)&quot;, callMethod, scan]; // 8 回调JS [self.webView stringByEvaluatingJavaScriptFromString:javaScriptParameter]; &#125;; [self.navigationController pushViewController:vc animated:YES]; &#125; return NO; &#125; return YES;&#125; ​ OC和JavaScript交互时使用的JS函数 给图片添加点击事件 123456789101112131415161718192021// 1.JSfunction addImageCick()&#123; var objs = document.getElementsByTagName(&quot;img&quot;); for(var i=0;i&lt;objs.length;i++)&#123; objs[i].onclick=function() &#123; document.location=&quot;myweb:imageClick:&quot;+this.src; &#125;; &#125;; return objs.length;&#125;;// 2. 点击事件、同时传图片编号function imageClick(i, url)&#123; alert(i + &quot;\n&quot; + url);&#125;function addImageCick()&#123; var imgs = document.getElementsByTagName(&quot;img&quot;); for (var i=0;i&lt;imgs.length;i++)&#123; imgs[i].setAttribute(&quot;onClick&quot;,&quot;imageClick(&quot;+i+&quot;, this.src)&quot;); &#125;&#125; 获取图片的size data 12345678910111213141516171819function getImageData(i)&#123; var imgs = document.getElementsByTagName(&quot;img&quot;); var img=imgs[i]; var canvas=document.createElement(&quot;canvas&quot;); var context=canvas.getContext(&quot;2d&quot;); canvas.width=img.width; canvas.height=img.height; context.drawImage(img,0,0,img.width,img.height); return canvas.toDataURL(&quot;image/png&quot;)&#125;function getImageRect(i)&#123; var imgs = document.getElementsByTagName(&quot;img&quot;); var rect; rect = imgs[i].getBoundingClientRect().left+&quot;::&quot;; rect = rect+imgs[i].getBoundingClientRect().top+&quot;::&quot;; rect = rect+imgs[i].width+&quot;::&quot;; rect = rect+imgs[i].height; return rect;&#125; 获取所有图片 123456789function getAllImageUrl()&#123; var imgs = document.getElementsByTagName(&quot;img&quot;); var urlArray = []; for (var i=0;i&lt;imgs.length;i++)&#123; var src = imgs[i].src; urlArray.push(src); &#125; return urlArray.toString();&#125; 最后的话 完整的demo在这里]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 系统控件的一些用法]]></title>
    <url>%2F2017%2F05%2F11%2F00-%E6%8A%80%E6%9C%AF-iOS%2FiOS-%E7%B3%BB%E7%BB%9F%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[UIViewtransform 属性CGAffineTransformMake 变换原理1@property(nonatomic) CGAffineTransform transform; // default is CGAffineTransformIdentity. animatable 当我们使用 CGAffineTransformMake 方法时实际是创建一个CGAffineTransform的结构体,此结构体定义如下： 12345678struct CGAffineTransform &#123; CGFloat a, b, c, d; CGFloat tx, ty;&#125;;CG_EXTERN CGAffineTransform CGAffineTransformMake(CGFloat a, CGFloat b, CGFloat c, CGFloat d, CGFloat tx, CGFloat ty) CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0); 其中a` b cd txty可以组成如下3X3` 的矩阵，如下： 123456B = [ ] a b 0 c d 0 tx ty 1 [ ] 当使用 Transform 变换时实际是把view上所有的点通过 矩阵B计算得新的点。假设 view上一点 1A = [x y 1] A * B 可以得到变换后的点 1A` = [(a*x+c*y+tx) (b*x+d*y+ty) (1) ] 其中的 矩阵 * 矩阵 的计算可参考大学 线性代数使用给不同的字值自然可以达到不同效果 其中Apple封装了一些常用的方法,包括： 平移（Translation） 缩放（Scale） 旋转（Rotation） 剪切（Shear） 翻转（Flip） 平移（Translation) 由上面的计算可以得到 当 1234a = 1c = 0b = 0d = 1 时 1A` = [(x+tx) (y+ty) (1) ] 使用CGAffineTransformMake(1, 0, 0, 1, tx, ty);即可。系统提供了类似的方法 12345/* Return a transform which translates by `(tx, ty)': t' = [ 1 0 0 1 tx ty ] */CG_EXTERN CGAffineTransform CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty) CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0); 由Apple注释可以发现前面的分析正确,那么其他的种类已基本一个思路。 参考 此属性主要是用来操作UIView的平移，旋转，伸缩。 CGAffineTransformIdentity （默认。当我们想恢复原始状态时可以使用此方法） CGAffineTransformMakeRotation 旋转 123456789101112131415[UIView animateWithDuration:0.3 animations:^&#123; // 0 &lt; x &lt;= M_PI 顺时针旋转 // -M_PI &lt;= x &lt; 0 逆时针旋转 // 总结：总是以最近，尽量顺时针，最多旋转180°的方式到达目的地 /* self.myView.transform = CGAffineTransformMakeRotation(M_PI); // 顺时针旋转 180° self.myView.transform = CGAffineTransformMakeRotation(M_PI_2); // 顺时针旋转 90° self.myView.transform = CGAffineTransformMakeRotation(M_PI_4); // 顺时针旋转 45° self.myView.transform = CGAffineTransformMakeRotation(-M_PI); // 逆时针旋转 180° self.myView.transform = CGAffineTransformMakeRotation(-M_PI_2); // 逆时针旋转 90° self.myView.transform = CGAffineTransformMakeRotation(-M_PI_4); // 逆时针旋转 45° */ self.myView.transform = CGAffineTransformMakeRotation(M_PI * 1.5); // 逆时针旋转 90°&#125;]; 演示如下： CGAffineTransformMakeScale 伸缩 123456[UIView animateWithDuration:0.3 animations:^&#123; // 宽高伸缩比例 // 宽变为 sx * width // 高变为 sy * height self.myView.transform = CGAffineTransformMakeScale(0.6, 0.5); // 宽变为 0.6 * height 高变为 0.5 * height&#125;]; CGAffineTransformMakeTranslation 平移操作 1234567[UIView animateWithDuration:0.3 animations:^&#123; // xy移动距离 // x变为 x + tx // y变为 y + ty self.myView.transform = CGAffineTransformMakeTranslation(10, 10); &#125;];&#125;]; 系统API说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** 结构体 B = [ ] a b 0 c d 0 tx ty 1 [ ] view 上所有点经过 变换为 A`,变换为 * B A(X,Y,1) * B = A`([(a*x+c*y+tx),(b*x+d*y+ty),(1)) */struct CGAffineTransform &#123; CGFloat a, b, c, d; CGFloat tx, ty;&#125;;/* The identity transform: [ 1 0 0 1 0 0 ]. */// [(a*x+c*y+tx) (b*x+d*y+ty) (1) ] --&gt; [(x) (y) (1) ] 还原初始位置// 还原初始状态CG_EXTERN const CGAffineTransform CGAffineTransformIdentityCG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);/* Return the transform [ a b c d tx ty ]. */// [(a*x+c*y+tx) (b*x+d*y+ty) (1) ] --&gt; [(a*x+c*y+tx) (b*x+d*y+ty) (1) ]// 自定义形变CG_EXTERN CGAffineTransform CGAffineTransformMake(CGFloat a, CGFloat b, CGFloat c, CGFloat d, CGFloat tx, CGFloat ty)CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);/* Return a transform which translates by `(tx, ty)': t' = [ 1 0 0 1 tx ty ] */// [(a*x+c*y+tx) (b*x+d*y+ty) (1) ] --&gt; [(x+tx) (y+ty) (1) ] 平移// 平移CG_EXTERN CGAffineTransform CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty) CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);/* Return a transform which scales by `(sx, sy)': t' = [ sx 0 0 sy 0 0 ] */// [(a*x+c*y+tx) (b*x+d*y+ty) (1) ] --&gt; [(sx*x) (sy*y) (1) ]// 缩放CG_EXTERN CGAffineTransform CGAffineTransformMakeScale(CGFloat sx, CGFloat sy)CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);/* Return a transform which rotates by `angle' radians: t' = [ cos(angle) sin(angle) -sin(angle) cos(angle) 0 0 ] */// 旋转CG_EXTERN CGAffineTransform CGAffineTransformMakeRotation(CGFloat angle)CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);/* Return true if `t' is the identity transform, false otherwise. */// 是否为初始值CG_EXTERN bool CGAffineTransformIsIdentity(CGAffineTransform t)CG_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0);/* Translate `t' by `(tx, ty)' and return the result: t' = [ 1 0 0 1 tx ty ] * t */// 在 t' 的状态下发生下一次变换平移CG_EXTERN CGAffineTransform CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty) CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);/* Scale `t' by `(sx, sy)' and return the result: t' = [ sx 0 0 sy 0 0 ] * t */// 在 t' 的状态下发生下一次变换 缩放CG_EXTERN CGAffineTransform CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy) CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);/* Rotate `t' by `angle' radians and return the result: t' = [ cos(angle) sin(angle) -sin(angle) cos(angle) 0 0 ] * t */// 在 t' 的状态下发生下一次变换 旋转CG_EXTERN CGAffineTransform CGAffineTransformRotate(CGAffineTransform t, CGFloat angle) CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);/* Invert `t' and return the result. If `t' has zero determinant, then `t' is returned unchanged. */// 对t 反向旋转CG_EXTERN CGAffineTransform CGAffineTransformInvert(CGAffineTransform t)CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);/* Concatenate `t2' to `t1' and return the result: t' = t1 * t2 */// 组合 t1 t2CG_EXTERN CGAffineTransform CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2) CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);/* Return true if `t1' and `t2' are equal, false otherwise. */// 判断是否相同CG_EXTERN bool CGAffineTransformEqualToTransform(CGAffineTransform t1, CGAffineTransform t2) CG_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0);/* Transform `point' by `t' and return the result: p' = p * t where p = [ x y 1 ]. */// 得到新的中心CGPoint (没用过)CG_EXTERN CGPoint CGPointApplyAffineTransform(CGPoint point, CGAffineTransform t) CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);/* Transform `size' by `t' and return the result: s' = s * t where s = [ width height 0 ]. */// 得到新的size CGSize (没用过)CG_EXTERN CGSize CGSizeApplyAffineTransform(CGSize size, CGAffineTransform t)CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);/* Transform `rect' by `t' and return the result. Since affine transforms do not preserve rectangles in general, this function returns the smallest rectangle which contains the transformed corner points of `rect'. If `t' consists solely of scales, flips and translations, then the returned rectangle coincides with the rectangle constructed from the four transformed corners. */// 得到新的rect CGRect (没用过)CG_EXTERN CGRect CGRectApplyAffineTransform(CGRect rect, CGAffineTransform t)CG_AVAILABLE_STARTING(__MAC_10_4, __IPHONE_2_0); UIScrollViewUIScrollView123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126@property(nonatomic) CGPoint contentOffset; // default CGPointZero 当前滚动到的位置@property(nonatomic) CGSize contentSize; // default CGSizeZero 滚动范围@property(nonatomic) UIEdgeInsets contentInset; // default UIEdgeInsetsZero. add additional scroll area around content 额外增加的滚动范围@property(nullable,nonatomic,weak) id&lt;UIScrollViewDelegate&gt; delegate; // default nil. weak reference 代理// default NO. if YES, try to lock vertical or horizontal scrolling while dragging// 方向锁定（在一个方向滚动时 另一个方向不允许滚动）@property(nonatomic,getter=isDirectionalLockEnabled) BOOL directionalLockEnabled;// default YES. if YES, bounces past edge of content and back again 弹簧效果@property(nonatomic) BOOL bounces;// default NO. if YES and bounces is YES, even if content is smaller than bounds, allow drag vertically// 垂直方向的弹簧效果@property(nonatomic) BOOL alwaysBounceVertical;// default NO. if YES and bounces is YES, even if content is smaller than bounds, allow drag horizontally// 水平方向的弹簧效果@property(nonatomic) BOOL alwaysBounceHorizontal;// default NO. if YES, stop on multiples of view bounds// 启动分页@property(nonatomic,getter=isPagingEnabled) BOOL pagingEnabled __TVOS_PROHIBITED;// default YES. turn off any dragging temporarily// 是否可以拖动@property(nonatomic,getter=isScrollEnabled) BOOL scrollEnabled;// default YES. show indicator while we are tracking. fades out after tracking// 是否显示水平滚动条@property(nonatomic) BOOL showsHorizontalScrollIndicator;// default YES. show indicator while we are tracking. fades out after tracking// 是否显示垂直滚动条@property(nonatomic) BOOL showsVerticalScrollIndicator;// default is UIEdgeInsetsZero. adjust indicators inside of insets// 调整滚动显示器的边距@property(nonatomic) UIEdgeInsets scrollIndicatorInsets;// default is UIScrollViewIndicatorStyleDefault// scrollView 的样式@property(nonatomic) UIScrollViewIndicatorStyle indicatorStyle;// UIKIT_EXTERN const CGFloat UIScrollViewDecelerationRateNormal NS_AVAILABLE_IOS(3_0);// UIKIT_EXTERN const CGFloat UIScrollViewDecelerationRateFast NS_AVAILABLE_IOS(3_0);// 滚动的速度@property(nonatomic) CGFloat decelerationRate NS_AVAILABLE_IOS(3_0);// tvos 上使用@property(nonatomic) UIScrollViewIndexDisplayMode indexDisplayMode API_AVAILABLE(tvos(10.2));// 设置滚动的位置 是否动画- (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated; // animate at constant velocity to new offset// 滚动到具体位置- (void)scrollRectToVisible:(CGRect)rect animated:(BOOL)animated; // scroll so rect is just visible (nearest edges). nothing if rect completely visible// 让滚动条显示（但只会显示一段时间会自动隐藏 可以使用分类重写imageView的 alpha 方法来控制，因为scroll的滚动条是 imageView）- (void)flashScrollIndicators; // displays the scroll indicators for a short time. This should be done whenever you bring the scroll view to front./* Scrolling with no scroll bars is a bit complex. on touch down, we don't know if the user will want to scroll or track a subview like a control. on touch down, we start a timer and also look at any movement. if the time elapses without sufficient change in position, we start sending events to the hit view in the content subview. if the user then drags far enough, we switch back to dragging and cancel any tracking in the subview. the methods below are called by the scroll view and give subclasses override points to add in custom behaviour. you can remove the delay in delivery of touchesBegan:withEvent: to subviews by setting delaysContentTouches to NO. */// 是否正在跟踪@property(nonatomic,readonly,getter=isTracking) BOOL tracking; // returns YES if user has touched. may not yet have started dragging// 是否正在拖拽@property(nonatomic,readonly,getter=isDragging) BOOL dragging; // returns YES if user has started scrolling. this may require some time and or distance to move to initiate dragging// 是否正在减速@property(nonatomic,readonly,getter=isDecelerating) BOOL decelerating; // returns YES if user isn't dragging (touch up) but scroll view is still moving@property(nonatomic) BOOL delaysContentTouches; // default is YES. if NO, we immediately call -touchesShouldBegin:withEvent:inContentView:. this has no effect on presses@property(nonatomic) BOOL canCancelContentTouches; // default is YES. if NO, then once we start tracking, we don't try to drag if the touch moves. this has no effect on presses// override points for subclasses to control delivery of touch events to subviews of the scroll view// called before touches are delivered to a subview of the scroll view. if it returns NO the touches will not be delivered to the subview// this has no effect on presses// default returns YES- (BOOL)touchesShouldBegin:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event inContentView:(UIView *)view;// called before scrolling begins if touches have already been delivered to a subview of the scroll view. if it returns NO the touches will continue to be delivered to the subview and scrolling will not occur// not called if canCancelContentTouches is NO. default returns YES if view isn't a UIControl// this has no effect on presses- (BOOL)touchesShouldCancelInContentView:(UIView *)view;/* the following properties and methods are for zooming. as the user tracks with two fingers, we adjust the offset and the scale of the content. When the gesture ends, you should update the content as necessary. Note that the gesture can end and a finger could still be down. While the gesture is in progress, we do not send any tracking calls to the subview. the delegate must implement both viewForZoomingInScrollView: and scrollViewDidEndZooming:withView:atScale: in order for zooming to work and the max/min zoom scale must be different note that we are not scaling the actual scroll view but the 'content view' returned by the delegate. the delegate must return a subview, not the scroll view itself, from viewForZoomingInScrollview: */@property(nonatomic) CGFloat minimumZoomScale; // default is 1.0@property(nonatomic) CGFloat maximumZoomScale; // default is 1.0. must be &gt; minimum zoom scale to enable zooming@property(nonatomic) CGFloat zoomScale NS_AVAILABLE_IOS(3_0); // default is 1.0- (void)setZoomScale:(CGFloat)scale animated:(BOOL)animated NS_AVAILABLE_IOS(3_0);- (void)zoomToRect:(CGRect)rect animated:(BOOL)animated NS_AVAILABLE_IOS(3_0);@property(nonatomic) BOOL bouncesZoom; // default is YES. if set, user can go past min/max zoom while gesturing and the zoom will animate to the min/max value at gesture end@property(nonatomic,readonly,getter=isZooming) BOOL zooming; // returns YES if user in zoom gesture@property(nonatomic,readonly,getter=isZoomBouncing) BOOL zoomBouncing; // returns YES if we are in the middle of zooming back to the min/max value// When the user taps the status bar, the scroll view beneath the touch which is closest to the status bar will be scrolled to top, but only if its `scrollsToTop` property is YES, its delegate does not return NO from `shouldScrollViewScrollToTop`, and it is not already at the top.// On iPhone, we execute this gesture only if there's one on-screen scroll view with `scrollsToTop` == YES. If more than one is found, none will be scrolled.@property(nonatomic) BOOL scrollsToTop __TVOS_PROHIBITED; // default is YES.// Use these accessors to configure the scroll view's built-in gesture recognizers.// Do not change the gestures' delegates or override the getters for these properties.// Change `panGestureRecognizer.allowedTouchTypes` to limit scrolling to a particular set of touch types.@property(nonatomic, readonly) UIPanGestureRecognizer *panGestureRecognizer NS_AVAILABLE_IOS(5_0);// `pinchGestureRecognizer` will return nil when zooming is disabled.@property(nullable, nonatomic, readonly) UIPinchGestureRecognizer *pinchGestureRecognizer NS_AVAILABLE_IOS(5_0);// `directionalPressGestureRecognizer` is disabled by default, but can be enabled to perform scrolling in response to up / down / left / right arrow button presses directly, instead of scrolling indirectly in response to focus updates.@property(nonatomic, readonly) UIGestureRecognizer *directionalPressGestureRecognizer UIKIT_AVAILABLE_TVOS_ONLY(9_0);@property(nonatomic) UIScrollViewKeyboardDismissMode keyboardDismissMode NS_AVAILABLE_IOS(7_0); // default is UIScrollViewKeyboardDismissModeNone@property (nonatomic, strong, nullable) UIRefreshControl *refreshControl NS_AVAILABLE_IOS(10_0) __TVOS_PROHIBITED; UIScrollViewDelegate 参考http://www.jianshu.com/p/5391997cbdd2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 正在滚动时 scrollViewDidScroll// any offset changes- (void)scrollViewDidScroll:(UIScrollView *)scrollView; // 正在缩放时 scrollViewDidZoom// any zoom scale changes- (void)scrollViewDidZoom:(UIScrollView *)scrollView NS_AVAILABLE_IOS(3_2); // 将要开始拖拽时（一次有效拖拽）手刚接触到scroll时 scrollViewWillBeginDragging// called on start of dragging (may require some time and or distance to move)- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView;// called on finger up if the user dragged. velocity is in points/millisecond. // targetContentOffset may be changed to adjust where the scroll view comes to rest// 就要结束拖拽时 手将要离开scroll时 scrollViewWillEndDragging velocity当前的速度 // targetContentOffset此次滚动结束的目标偏远- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset NS_AVAILABLE_IOS(5_0);// called on finger up if the user dragged. decelerate is true if it will continue moving afterwards// 已经结束拖拽时 手刚离开scroll时 scrollViewDidEndDragging decelerate是否会继续向前滚动一段距离- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;// called on finger up as we are moving// 将要开始减速时 手刚离开时- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView; // called when scroll view grinds to a halt// 已经结束减速时 停下来时- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView; // // called when setContentOffset/scrollRectVisible:animated: finishes. not called if not animating// 已经滚动滚动（使用代码设置的滚动时）- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView; // return a view that will be scaled. if delegate returns nil, nothing happens// 返回需要缩放的view- (nullable UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView; // called before the scroll view begins zooming its content// 将要开始缩放- (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(nullable UIView *)view NS_AVAILABLE_IOS(3_2); // scale between minimum and maximum. called after any 'bounce' animations// 已结束缩放 view缩放的view scale缩放比例- (void)scrollViewDidEndZooming:(UIScrollView *)scrollView withView:(nullable UIView *)view atScale:(CGFloat)scale; // return a yes if you want to scroll to the top. if not defined, assumes YES// 点击状态栏时是否可以返回顶部- (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView; // called when scrolling animation finished. may be called immediately if already at top// 点击状态栏后回到顶部结束- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView; iOS沙盒沙盒目录NSString *homeDirectory = NSHomeDirectory(); home/Documents NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0] ①存放内容 我们可以将应用程序的数据文件保存在该目录下。不过这些数据类型仅限于不可再生的数据，可再生的数据文件应该存放在Library/Cache目录下。 ②会被iTunes同步 home/Library/Caches NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0] ①存放内容主要是缓存文件，用户使用过程中缓存都可以保存在这个目录中。前面说过，Documents目录用于保存不可再生的文件，那么这个目录就用于保存那些可再生的文件，比如网络请求的数据。鉴于此，应用程序通常还需要负责删除这些文件,注意：存储不足时，系统会清理此文件夹。 ②不会被iTunes同步 home/Library/Preferences [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory,NSUserDomainMask,YES)[0] stringByAppendingPathComponent:@&quot;Preferences&quot;]; ①存放内容应用程序的偏好设置文件。我们使用NSUserDefaults写的设置数据都会保存到该目录下的一个plist文件中，这就是所谓的写道plist中！ ②会被iTunes同步 home/tmp NSTemporaryDirectory(); 存储放临时文件，退出App后自动删除 ，可以任意操作此文件夹,不会被iTunes同步 home/MyApp.app [[NSBundle mainBundle] bundlePath] ①存放内容该目录包含了应用程序本身的数据，包括资源文件和可执行文件等。程序启动以后，会根据需要从该目录中动态加载代码或资源到内存，这里用到了lazy loading的思想。 ②整个目录是只读的为了防止被篡改，应用在安装的时候会将该目录签名。非越狱情况下，该目录中内容是无法更改的；在越狱设备上如果更改了目录内容，对应的签名就会被改变，这种情况下苹果官网描述的后果是应用程序将无法启动，我没实践过。 ③不会被iTunes同步 appearance123456789101112131415// 设置 UINavigationBar 上的 item 的颜色，包括 item 和 backItem[UINavigationBar appearance].tintColor= [UIColor redColor];// 设置 UINavigationBar 的背景颜色[UINavigationBar appearance].barTintColor = [UIColor blueColor]; // 设置 UINavigationBar 上的标题的属性[UINavigationBar appearance].titleTextAttributes =@&#123;NSFontAttributeName: [UIFont boldSystemFontOfSize:40],NSForegroundColorAttributeName : [UIColor whiteColor],&#125;;// 设置 UITabBar 上的 item 的颜色[UITabBar appearance].tintColor = [UIColor redColor];// 设置 UITabBar 的背景颜色[UITabBar appearance].barTintColor = [UIColor blueColor]; AFN1234567891011121314151617AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; &#123; // 请求格式化 manager.requestSerializer = [AFJSONRequestSerializer serializer];&#125;&#123; // 响应 AFHTTPResponseSerializer *serializer=[AFHTTPResponseSerializer serializer]; serializer.acceptableContentTypes = [NSSet setWithObjects:@&quot;text/html&quot;, @&quot;application/json&quot;, @&quot;text/json&quot; , @&quot;text/javascript&quot;, @&quot;video/mp4&quot;, nil]; manager.responseSerializer = serializer;&#125; 保存图片到相册123456789101112131415161718192021- (void)loadImageFinished:(UIImage *)image&#123; UIImageWriteToSavedPhotosAlbum(image, self, @selector(image:didFinishSavingWithError:contextInfo:), (__bridge void *)self);&#125;- (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo&#123; [MEMEITUOKHUD dismiss]; if (error) &#123; UIAlertController *alertVC = [UIAlertController alertControllerWithTitle:@&quot;保存失败&quot; message:error.domain preferredStyle:UIAlertControllerStyleAlert]; [alertVC addAction:[UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; &#125;]]; [self presentViewController:alertVC animated:YES completion:nil]; &#125; else &#123; UIAlertController *alertVC = [UIAlertController alertControllerWithTitle:@&quot;保存成功&quot; message:nil preferredStyle:UIAlertControllerStyleAlert]; [alertVC addAction:[UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123; &#125;]]; [self presentViewController:alertVC animated:YES completion:nil]; &#125;&#125; 显示模式 UIViewContentMode 1234567891011121314151617181920212223242526272829303132333435typedef NS_ENUM(NSInteger, UIViewContentMode) &#123; // 图片强行变形缩放显示满 UIImageView 为止 UIViewContentModeScaleToFill, // 图片等比例缩放到完全显示到内部，而且保证最少有一边填满 UIImageView UIViewContentModeScaleAspectFit, // 图片等比例缩放到 `较短` 一边也填满 UIImageView 为止，多余的裁剪掉 UIViewContentModeScaleAspectFill, // 这个不知道是什么鬼 // 调用 setNeedsDisplay 方法时,就会重新渲染图片 UIViewContentModeRedraw, // 不拉伸（压缩）图片，取特定位置，裁剪图片，不变形 UIViewContentModeCenter, //顶部 UIViewContentModeTop, //底部 UIViewContentModeBottom, //左边 UIViewContentModeLeft, //右边 UIViewContentModeRight, //左上 UIViewContentModeTopLeft, //右上 UIViewContentModeTopRight, //左下 UIViewContentModeBottomLeft, //右下 UIViewContentModeBottomRight,&#125;; iOS开发的一些尺寸规范iPhone尺寸规格12345iPhone4/4S 320x480 iPhone5/5C/5S 320x568 iPhone6/6S/7/8 375x667 iPhone6P/6SP/7P/8P 414x736 iPhone X 375x812 LaunchImage 启动图 只适配 iphone 时的启动图如下 12345640x960.png640x1136.png750x1334.png1125x2436.png1242x2208.png iconhttps://icon.wuruihong.com/ 123456789101112131415161718192021222324icon-20-ipad.pngicon-20@2x-ipad.pngicon-20@2x.pngicon-20@3x.pngicon-29-ipad.pngicon-29.pngicon-29@2x-ipad.pngicon-29@2x.pngicon-29@3x.pngicon-40.pngicon-40@2x.pngicon-40@3x.pngicon-50.pngicon-50@2x.pngicon-57.pngicon-57@2x.pngicon-60@2x.pngicon-60@3x.pngicon-72.pngicon-72@2x.pngicon-76.pngicon-76@2x.pngicon-83.5@2x.pngicon-1024.png iOS系统权限123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- 保存图片到相册相册 --&gt; &lt;key&gt; NSPhotoLibraryAddUsageDescription &lt;/key&gt; &lt;string&gt;为了把您涂鸦好的图片保存到相册，需要您提供授权&lt;/string&gt; &lt;!-- 获取相册的图片 --&gt; &lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问相册&lt;/string&gt; &lt;!-- 相机 --&gt; &lt;key&gt;NSCameraUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问相机&lt;/string&gt; &lt;!-- 麦克风 --&gt; &lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问麦克风&lt;/string&gt; &lt;!-- 位置 --&gt; &lt;key&gt;NSLocationUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问位置&lt;/string&gt; &lt;!-- 在使用期间访问位置 --&gt; &lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能在使用期间访问位置&lt;/string&gt; &lt;!-- 始终访问位置 --&gt; &lt;key&gt;NSLocationAlwaysUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能始终访问位置&lt;/string&gt; &lt;!-- 日历 --&gt; &lt;key&gt;NSCalendarsUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问日历&lt;/string&gt; &lt;!-- 提醒事项 --&gt; &lt;key&gt;NSRemindersUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问提醒事项&lt;/string&gt; &lt;!-- 运动与健身 --&gt; &lt;key&gt;NSMotionUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问运动与健身&lt;/string&gt; &lt;!-- 健康更新 --&gt; &lt;key&gt;NSHealthUpdateUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问健康更新 &lt;/string&gt; &lt;!-- 健康分享 --&gt; &lt;key&gt;NSHealthShareUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问健康分享&lt;/string&gt; &lt;!-- 蓝牙 --&gt; &lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问蓝牙&lt;/string&gt; &lt;!-- 媒体资料库 --&gt; &lt;key&gt;NSAppleMusicUsageDescription&lt;/key&gt; &lt;string&gt;App需要您的同意,才能访问媒体资料库&lt;/string&gt;]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSObject Runtime 杂货铺]]></title>
    <url>%2F2017%2F04%2F25%2F00-%E6%8A%80%E6%9C%AF-iOS%2FNSObject-Runtime-%E6%9D%82%E8%B4%A7%E9%93%BA%2F</url>
    <content type="text"><![CDATA[Blog 介绍 关联Github 1.收集一些关于Runtime的Blog2.一些Runtime实例代码包括介绍 Runtime Blog 待补充 Runtime实例代码对象绑定12345678// 对象绑定objc_setAssociatedObject(&lt;#id object#&gt;, &lt;#const void *key#&gt;, &lt;#id value#&gt;, &lt;#objc_AssociationPolicy policy#&gt;) // 获取绑定的对象objc_getAssociatedObject(&lt;#id object#&gt;, &lt;#const void *key#&gt;) // 删除对象的所有绑定（可以使用 objc_setAssociatedObject 绑定 nil 来解除指定 key 的绑定）objc_removeAssociatedObjects(&lt;#id object#&gt;) 获取类的属性列表1234567891011unsigned int count = 0;// 1.获取属性列表objc_property_t *propertys = class_copyPropertyList(UIViewController.class, &amp;count); // 2.遍历属性while (count--) &#123; const char *propertyName = property_getName(propertys[count]); NSLog(@"属性 ：%@", [NSString stringWithUTF8String:propertyName]);&#125;// 3.释放 propertysfree(propertys); 获取类的成员变量列表12345678910unsigned int count = 0;// 1.获取成员变量列表Ivar *ivar = class_copyIvarList(UIViewController.class, &amp;count);// 2.遍历成员变量列表while (count--) &#123; const char *ivarName = ivar_getName(ivar[count]); NSLog(@"成员变量 ：%@", [NSString stringWithUTF8String:ivarName]);&#125;// 释放 ivarfree(ivar); 获取类的方法列表12345678910unsigned int count = 0;// 1.获取方法列表Method *method = class_copyMethodList(UIViewController.class, &amp;count);// 2.遍历方法列表while (count--) &#123; SEL sel = method_getName(method[count]); NSLog(@"方法 ：%@", NSStringFromSelector(sel));&#125;// 释放 methodfree(method); 获取类的协议列表12345678910unsigned int count = 0;// 1.获取遵守的列表__unsafe_unretained Protocol **protocols = class_copyProtocolList(UIViewController.class, &amp;count);// 2.遍历遵守的遵守列表while (count--) &#123; const char *protocolName = protocol_getName(protocols[count]); NSLog(@"协议 ：%@", [NSString stringWithUTF8String:protocolName]);&#125;// 3.释放 methodfree(protocols); 交换 2 个方法的调用参考1，参考2，参考3在实际使用时需使用+ (void)load {} + dispatch_once保证只交换一次 交换实例方法123456789101112void swizzleInstanceMethod(Class class, SEL originalSelector, SEL swizzledSelector) &#123; // 1.获取旧 Method Method originalMethod = class_getInstanceMethod(class, originalSelector); // 2.获取新 Method Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); // 3.交换方法 if (class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125;&#125; 交换类方法 其实可以看着为交换类的元类的实例方法 1234567891011121314void swizzleClassMethod(Class class, SEL originalSelector, SEL swizzledSelector) &#123; // 0.获取class的元类 Class metaClass = objc_getMetaClass(class_getName(class)); // 1.获取旧 Method Method originalMethod = class_getInstanceMethod(metaClass, originalSelector); // 2.获取新 Method Method swizzledMethod = class_getInstanceMethod(metaClass, swizzledSelector); // 3.交换方法 if (class_addMethod(metaClass, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod))) &#123; class_replaceMethod(metaClass, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125;&#125; 修改一个对象所属于的类型 isa 指针1object_setClass(self, BM_Class); 动态创建类123456Class clas = NSClassFromString(@"BMClass");if (clas)return; // 类已存在// 1.创建类 BMClassclas = objc_allocateClassPair(NSObject.class, "BMClass", 0);// 2.注册类 BMClassobjc_registerClassPair(clas); 动态添加方法 123456789101112131415161718192021222324#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;@interface Person : NSObject- (void)eat;@end@implementation Person@endvoid eat(id self, SEL _cmd) &#123; NSLog(@"%@ %@", NSStringFromSelector(_cmd) ,self);&#125; // 添加方法的 types参数 可以参考Apple官方文档// 构建 Type Encodings (方法参数格式)Method clazzSetMethod = class_getInstanceMethod(Person.class, NSSelectorFromString(@"eat"));const char *settypes = method_getTypeEncoding(clazzSetMethod); // 添加方法 class_addMethod(Person.class, NSSelectorFromString(@"eat"), (IMP) eat, settypes); 添加实例方法 imp 使用函数强转 12345 void addInstanceMethod(Class clas, SEL name, IMP imp) &#123; Method clazzSetMethod = class_getInstanceMethod(clas, name); const char *settypes = method_getTypeEncoding(clazzSetMethod); class_addMethod(clas, name, (IMP) imp, settypes);&#125; 添加实类方法 imp 使用函数强转 123456void addClassMethod(Class clas, SEL name, IMP imp) &#123; Class metaClass = objc_getMetaClass(class_getName(clas)); Method clazzSetMethod = class_getInstanceMethod(metaClass, name); const char *settypes = method_getTypeEncoding(clazzSetMethod); class_addMethod(metaClass, name, (IMP) imp, settypes);&#125; 手动实现KVO 当我们对一个Obj添加 KVO时， Apple会动态的为此对象的 Class 添加一个子类NSKVONotifying_Class，然后把Obj的isa指向NSKVONotifying_Class(Obj已是NSKVONotifying_Class类型的对象)，在为NSKVONotifying_Class增加监控的属性的setter方法，当监控的属性有改变时(触发 setter 方法时，如果没有触发setter来修改属性是无法监控的)，就会触发新加setter，便实现了KVO功能。 核心技术动态创建一个类 修改对象所属的类型 动态添加方法 消息转发 代码实现KVO 为 NSObject 增加一个分类 BMKVO 添加如下方法： 123typedef void(^BMKVOChangedBlock)(id newValue, id oldCalue);- (BOOL)bm_addKVOWithKeyPath:(NSString *)keyPath changedBlock:(BMKVOChangedBlock)changedBlock; 为 .m 文件实现如下： 12345678// 构建中间类名 BMKVO_原类名NSString *kvoClassName = [NSString stringWithFormat:@"BMKVO_%@", [NSString stringWithUTF8String:class_getName(self.class)]];// 创建中间类Class kvoClass = objc_allocateClassPair(self.class, kvoClassName.UTF8String, 0);// 构建 setter 方法名unichar c = [keyPath characterAtIndex:0];NSString *str = [keyPath stringByReplacingCharactersInRange:NSMakeRange(0, 1) withString:[NSString stringWithFormat:@"%c", c-32]];str = [NSString stringWithFormat:@"set%@:", str]; 添加方法 123456// 构建 Type Encodings (方法参数格式)Method clazzSetMethod = class_getInstanceMethod(self.class, NSSelectorFromString(str));const char *settypes = method_getTypeEncoding(clazzSetMethod); // 添加方法 class_addMethod(kvoClass, NSSelectorFromString(str), (IMP)bm_setter, settypes); 其中 Type Encodings 参考官方文档 bm_setter 讲解 上面的 bm_setter是一个函数名,函数实现如下: 123static void bm_setter(id self, SEL _cmd, id newValue) &#123; // 当修改了监控的属性时,会调到此函数，可在这里面做相关的操作&#125; 上面基本完成了 KVO 的监控，虽然我们可以检测到属性的修改，但是目前是无法修改的，所以需要我们在 bm_setter 函数里面做监控回调操作，同时修改属性。这里需要使用 objc_msgSendSuper() 来发送消息修改属性。具体实现如下： 123456789101112131415161718192021222324252627282930static void bm_setter(id self, SEL _cmd, id newValue) &#123; NSString *str = NSStringFromSelector(_cmd); // 1. 去掉set NSRange range = [str rangeOfString:@"set"]; NSString *subStr1 = [str substringFromIndex:range.location + range.length]; // 2. 首字母转换成大写 unichar c = [subStr1 characterAtIndex:0]; NSString *subStr2 = [subStr1 stringByReplacingCharactersInRange:NSMakeRange(0, 1) withString:[NSString stringWithFormat:@"%c", c+32]]; // 3. 去掉最后的: NSRange range2 = [subStr2 rangeOfString:@":"]; NSString *getter = [subStr2 substringToIndex:range2.location]; // 4. 取出旧值 NSString *oldeValue = [self valueForKey:getter]; // 5. 构建 objc_super struct objc_super superClazz = &#123; .receiver = self, .super_class = class_getSuperclass(object_getClass(self)) &#125;; // 6. 发送消息（给 self 发送 _cmd 消息 参数为 newValue） ((void (*)(void *, SEL, id))objc_msgSendSuper)(&amp;superClazz, _cmd, newValue); // 7. 处理监控回调&#125; 把指定对象的NSString属性初始化为 @”” 最近遇到这样一个需求，项目中创建的一个模型，服务器返回的数据可能导致模型中的属性为nil，但我们在使用时必须保证所有的NSString属性如果是nil就使用@”” 代替，有一个常规的方法就是重写getter方法做nil判断，但是如果属性较都时较麻烦，而且增加一个属性又需要修改代码，那么有没有简洁的方法呢？答案是肯定有的，对，肯定是使用runtime来实现。下面的的思路是在init方法中把所有的NSString属性设置为@””。 获取到所有属性 使用kvc取值来 判断是否为nil 如果是nil在判断是否为NSString类型 如果是NSString就使用kvc设置为@”” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@implementation BMModelstatic const char *getPropertyType(objc_property_t property) &#123; const char *attributes = property_getAttributes(property); char buffer[1 + strlen(attributes)]; strcpy(buffer, attributes); char *state = buffer, *attribute; while ((attribute = strsep(&amp;state, ",")) != NULL) &#123; // 非对象类型 if (attribute[0] == 'T' &amp;&amp; attribute[1] != '@') &#123; // 利用NSData复制一份字符串 return (const char *) [[NSData dataWithBytes:(attribute + 1) length:strlen(attribute) - 1] bytes]; // 纯id类型 &#125; else if (attribute[0] == 'T' &amp;&amp; attribute[1] == '@' &amp;&amp; strlen(attribute) == 2) &#123; return "id"; // 对象类型 &#125; else if (attribute[0] == 'T' &amp;&amp; attribute[1] == '@') &#123; return (const char *) [[NSData dataWithBytes:(attribute + 3) length:strlen(attribute) - 4] bytes]; &#125; &#125; return "";&#125;- (instancetype)init &#123; if (self = [super init]) &#123; unsigned int count = 0; // 1.获取属性列表 objc_property_t *propertys = class_copyPropertyList(self.class, &amp;count); // 2.遍历属性 while (count--) &#123; // 取属性 objc_property_t property = propertys[count]; // 获取属性名称 const char *propertyName = property_getName(property); // 获取属性名称 NSString *propertyNameStr = [NSString stringWithUTF8String:propertyName]; // 获取属性类型 const char *propertyTypeName = getPropertyType(property); // 使用kvc获取值 id propertyValue = [self valueForKey:propertyNameStr]; if (!propertyValue) &#123; // 如果值是nil if (strncmp("NSString", propertyTypeName, strlen("NSString")) == 0) &#123; // 如果属性类型是 NSString [self setValue:@"" forKey:propertyNameStr]; &#125; &#125; &#125; // 3.释放 propertys free(propertys); &#125; return self;&#125;@end 基于上面的代码，那么就可以自定义各种场景了吧，对模型做各种自定义初始化就不在话下了。 以上代码参考自:这里 参考 https://developer.apple.com/reference/objectivec/objective_c_runtime 南峰子 Objective-C运行时 http://www.liuchungui.com/blog/2016/03/14/runtimezhi-lei-yu-dui-xiang-zong-jie https://justinyan.me/post/1624 https://dayon.gitbooks.io/-ios/content/chapter8.html http://www.cnblogs.com/whyandinside/archive/2013/02/26/2933552.html http://blog.csdn.net/windyitian/article/details/19810875 https://ming1016.github.io/2015/04/01/objc-runtime/]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS知识点总结]]></title>
    <url>%2F2016%2F09%2F11%2F00-%E6%8A%80%E6%9C%AF-iOS%2FiOS%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[单例Objective-C 写法 1234567891011121314@interface IHUserManager : NSObject+ (instancetype)sharedInstance;@end@implementation IHUserManager+ (instancetype)sharedInstance &#123; static IHUserManager *sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; sharedInstance = [[self alloc] init]; &#125;); return sharedInstance;&#125;@end Swift 写法 1234import Foundationclass IHUserManager &#123; static let sharedInstance = IHUserManager()&#125; block和闭包在对象绑定时的坑分析 在 oc 中，使用 runtime 的对象绑定相信大家都使用过，而且在 block 上的使用也经常看到，在 oc 中可以把 block 直接使用 runtime 通过 key 和其他的对象绑定起来，但在 swift 中闭包不是：AnyObject 类型 使用在进行对象绑定时无法进行。参考：1.stackoverflow.com、2.http://nshipster.cn 需要使用：public func unsafeBitCast&lt;T, U&gt;(x: T, _: U.Type) -&gt; U函数 代码实现 对 UIControl 增加 Block 属性和 Closure 属性 swift 具体的实现如下：123456789101112131415161718192021typealias IHClosure = @convention(block)() -&gt; () extension UIControl &#123; private struct ClosureKey &#123; static var touchUpInsideKey = "touchUpInsideKey" &#125; func ih_addTouchUpInsideClosure(closure: IHClosure) &#123; let obj: AnyObject = unsafeBitCast(closure, AnyObject.self) objc_setAssociatedObject(self, &amp;ClosureKey.touchUpInsideKey, obj, .OBJC_ASSOCIATION_COPY_NONATOMIC) self.addTarget(self, action: #selector(UIControl._touchUpInside), forControlEvents: .TouchUpInside) &#125; @objc private func _touchUpInside() &#123; let obj: AnyObject = objc_getAssociatedObject(self, &amp;ClosureKey.touchUpInsideKey) let closure: IHClosure = unsafeBitCast(obj, IHClosure.self) closure() &#125;&#125; Objective-C 具体的实现如下：1234567891011121314151617#import "UIControl+Block.h"#import &lt;objc/runtime.h&gt; const char kTouchUpInside = '\0'; @implementation UIControl (Block) - (void)ih_addTouchUpInsideWithBlock:(dispatch_block_t)block &#123; objc_setAssociatedObject(self, @selector(_touchControlEvents), block, OBJC_ASSOCIATION_COPY_NONATOMIC); [self addTarget:self action:@selector(_touchControlEvents) forControlEvents:UIControlEventTouchUpInside];&#125; - (void)_touchControlEvents &#123; dispatch_block_t block = objc_getAssociatedObject(self, _cmd); if (block) block();&#125;@end swift 和 oc 之 load方法不同以及处理方案分析 在 oc 开发中，APP统计时，自然会使用到 方法的替换,下面方法 OBJC_EXPORT void method_exchangeImplementations(Method m1, Method m2) __OSX_AVAILABLE_STARTING(__MAC_10_5, __IPHONE_2_0); 通常会为 vc 添加一个 category 同时在 + load 方法里面的其做相应的处理。但在 swift 中系统不允许使用 + load 方法。那么我们可以想办法使用：+ initialize 方法 代码实现oc 具体的实现如下：1234567891011121314151617181920212223242526272829303132#import "UIViewController+Swizzle.h"#import &lt;objc/runtime.h&gt; @implementation UIViewController (Swizzle) + (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // 获取系统的方法的 方法对象 Method orignViewDidLoad = class_getInstanceMethod([UIViewController class], @selector(viewDidLoad)); // 获取准备用来替换的 方法对象 Method replacingMethod = class_getInstanceMethod([UIViewController class], @selector(_viewDidLoad_Swizzling)); BOOL didAddMethod = class_addMethod([self class], @selector(viewDidLoad), method_getImplementation(replacingMethod), method_getTypeEncoding(replacingMethod)); if (didAddMethod) &#123; // 替换一下方法地址 class_replaceMethod([self class], @selector(_viewDidLoad_Swizzling), method_getImplementation(orignViewDidLoad), method_getTypeEncoding(orignViewDidLoad)); &#125;else&#123; // 直接交换的调用 method_exchangeImplementations(orignViewDidLoad, replacingMethod); &#125; &#125;);&#125; + (void)_viewDidLoad_Swizzling &#123; [self _viewDidLoad_Swizzling];&#125;@end swift 具体的实现如下：1234567891011121314151617181920212223242526272829303132extension UIViewController &#123; public override class func initialize() &#123; struct Static &#123; static var token: dispatch_once_t = 0 &#125; if self !== UIViewController.self &#123; return &#125; dispatch_once(&amp;Static.token) &#123; let originalSelector = #selector(UIViewController.viewWillAppear(_:)) let swizzledSelector = #selector(UIViewController.nsh_viewWillAppear(_:)) let originalMethod = class_getInstanceMethod(self, originalSelector) let swizzledMethod = class_getInstanceMethod(self, swizzledSelector) let didAddMethod = class_addMethod(self, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)) if didAddMethod &#123; class_replaceMethod(self, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)) &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125; &#125; func nsh_viewWillAppear(animated: Bool) &#123; self.nsh_viewWillAppear(animated) &#125;&#125; swift 和 oc 之 Log 处理 在 oc 中为: NSLog 在 swift 中为: print 我们在平常的开发中肯定会对 oc 的 NSLog 做一个特殊处理，打印更多的信息，在上线以后关闭日志输出，最简单的实现方式如下： 12345#ifdef DEBUG #define DLog(fmt, ...) NSLog((@"%s [Line %d] " fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__);#else #define DLog(...)#endif 但是在 swift 中没有宏定义，使用也没 oc中的 DEBUG. 简单的代码如下： 12345func IHLog&lt;T&gt;(message: T , file: String = (#file as NSString).lastPathComponent, funcName: String = #function, linNUm: Int = #line) -&gt; () &#123; print("\(file) [\(funcName)] \(linNUm) : \(message)")&#125; 添加环境控制： 优化的代码如下： 1234567 func IHLog&lt;T&gt;(message: T , file: String = (#file as NSString).lastPathComponent, funcName: String = #function, linNUm: Int = #line) -&gt; () &#123; #if IS_DEBUG print("\(file) [\(funcName)] \(linNUm) : \(message)") #endif&#125; PS: IS_DEBUG 是你随便取的哦 在添加的地方必须为: -D+名称，这里我取为 IS_DEBUG 大功告成，release 环境下不会有 log 信息了、O(∩_∩)O哈哈~ Github源码 交换2个值OC使用的方法就不描述了Swift 使用元组123var obj1 = "1"var obj2 = "2"(obj1, obj2) = (obj2, obj1) GCD延时函数1234func delay(_ delay:Double, closure:@escaping ()-&gt;()) &#123; let when = DispatchTime.now() + delay DispatchQueue.main.asyncAfter(deadline: when, execute: closure)&#125; 123delay(1) &#123; //...&#125; SEL123#selector(UIViewController.present(_:animated:completion:))let vc = UIViewController()#selector(vc.self.present(_:animated:completion:)) 获取类 class12self.classself.self 是否属于一个类型123456789// 是否属于一个类型if self is UIViewController &#123;&#125;let obj = NSObject()if obj is [String] &#123; print("c")&#125;if obj is [Any] &#123;&#125; copy mutableCopy123456// copy mutableCopyvar arr = [String]()let arr1 = (arr as NSArray).mutableCopy()let arr2 = (arr as NSArray).copy()arr = arr1 as! Array&lt;String&gt;arr = arr2 as! Array&lt;String&gt; for in123456789for i in 1...2 &#123;&#125;for i in 1..&lt;2 &#123;&#125;for obj in array&#123;&#125;for (i, obj) in (array?.enumerated())! &#123; array?[i] = (obj as! NSArray).mutableCopy() as! [Any]&#125; 属性 参考1 参考2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class Person: NSObject &#123; var name = ""&#125;class BMPerson: Person &#123; /// 存储属性 var name1 = "" var name2: String = "" var name3: String? = "" var name4: String? /// 懒加载，swift lazy 和 oc懒加载不同，swift的懒加载永远只会走一次，不是和oc一样做非nil 判断 lazy var name6 = "c" lazy var name7: String = "c" lazy var view1: UIView = &#123; let view = UIView() view.frame = CGRect.init(x: 0, y: 0, width: 100, height: 100) view.backgroundColor = .red return view &#125;() /// 计算属性，不会生成功成员变量，等于oc中重写了set get 方法 var name8: String? &#123; get &#123; print("get") return "" &#125; set &#123; print("set") &#125; &#125; /// 重写set get 方法 并且增加私有的成员变量 private var _name9: String? var name9: String? &#123; get &#123; print("get") return _name9 &#125; set &#123; print("set") _name9 = newValue &#125; &#125; var name10: String? &#123; willSet &#123; print("get") &#125; didSet &#123; print("set") &#125; &#125; var name11: String? &#123; willSet &#123; print("get") &#125; &#125; /// 初始化方法对属性的设定，以及在 willSet 和 didSet 中对属性的再次设定都不会再次触发属性观察的调用，一般来说这会是你所需要的行为，可以放心使用能够。 var name12: String? &#123; didSet &#123; print("set") var FA = false FA = arc4random() % 2 == 0 if FA &#123; print("NO") name12 = "CC" &#125; &#125; &#125; /// 监控分类继承的属性变化 override var name: String &#123; willSet &#123; print("分类的属性 将要修改") &#125; didSet &#123; print("分类的属性 将已经修改") &#125; &#125; /// 只读属性 private var _name8 : String? var name8: String? &#123; get &#123; return _name8 &#125; &#125;&#125; 元组 在 Swift 中创建元组的方式很简单，语法类似数组，但需要把方括号替换为圆括号： 0x00 1let firstHighScore = ("Mary", 9001) 与数组不同的是，元组中的元素可以是任意类型。上面代码中 firstHighScore 元组就包含一个 String 类型的元素和一个 Int 类型的元素。 0x01 另外，在创建元组时你还可以给元组中的元素命名： 1let secondHighScore = (name: "James", score: 4096) 这样可以让我们在使用元组的时候明确的指定某个元素，非常有用。在后面的文章中大家可以看到给元素命名的好处。 以上就是创建元组的两种方式，非常简单和简洁。你不需要像创建 struct 一样写出它的结构和内部属性，也不需要像创建 class 一样要写初始化方法。你只需要把你想用的、任何类型的值放在圆括号内，用逗号隔开即可。如果你愿意你还可以给每个元素命名，提高元组使用效率。 从元组中读元素 从元组中读取元素有几种方式，但一般我们会选择最适合当前应用场景的方式，并且确保选择的方式是在当前情况下最简单的一种。 0x00 如果我们没有给元组的元素命名，我们可以用点语法，通过定义好的元组变量或常量获取它的第 1 个到第 n 个元素： 123let firstHighScore = ("Mary", 9001)firstHighScore.0 // MaryfirstHighScore.1 // 9001 0x01 如果你觉得上述这种方法会造成语义的不明确，那么我们还可以将元组赋值给一个带有元素名称的元组（元素名称个数要对应）： 123let (firstName, firstScore) = firstHighScorefirstName // MaryfirstScore // 9001 0x02 如果你只想读取 firstHighScore 元组中的分数，那么你可以这样写： 12let (_, firstScore) = firstHighScorefirstScore // 9001 0x03 元组元素有命名如果我们已经给元组中的元素命名了名称，那么我们可以这样写： 1234let secondName = secondHighScore.namelet secondScore = secondHighScore.scoresecondName // JamessecondScore // 4096 0x04 将元组作为函数返回值我们可以将元组作为函数的返回值，下面这个函数的返回值就是我们之前定义过的 secondHighScore 元组： 123456func getAHighScore() -&gt; (name: String, score: Int)&#123; let theName = "Patricia" let theScore = 3894 return (theName, theScore)&#125; 为什么说上述函数的返回值是 secondHighScore 元组呢？因为 getAHighScore 函数返回的元组元素个数、元素名称、元素类型均和 secondHighScore 相同。 其实将元组作为函数的返回值时也可以不必对元素进行命名，只要你明白每个元素代表的含义即可： 123456func getAHighScore() -&gt; (String, Int)&#123; let theName = "Patricia" let theScore = 3894 return (theName, theScore)&#125; 如果你不确定返回的元组一定不为 nil ，那么你可以返回一个可选的元组类型： 1234func maybeGetHighScore() -&gt; (String, Int)?&#123; return nil&#125; 因为是可选的元组类型，所以当返回的元组不为 nil 时，你需要对元组进行解包： 123456789if let possibleScore = maybeGetHighScore()&#123; possibleScore.0 possibleScore.1&#125;else&#123; println("Nothing Here")&#125; 注意：当你定义了一个没有返回值的函数时，其实该函数是返回一个空的元组 ()。 元组的访问级别元组的访问级别取决于它包含的元素。比如元组里的元素都是 private 级别的，那么该元组也是 private 级别的。但这里有一个遵循最小的原则，也就是说如果一个元组中有两个元素，一个为private级别，另一个为 public 级别，那么该元组遵循最小原则，它的访问级别为 private 。 元组是值类型关于值类型和引用类型的知识这里不再累赘，我们通过一个代码示例来看看元组是哪种类型： 123456var someScore = ("John", 55)var anotherScore = someScoreanotherScore.0 = "Robert"println(anotherScore.0) //Outputs: "Robert"println(someScore.0) //Outputs: "John" 通过上述的代码示例可以看出，我把 someScore 元组赋值给了 anotherScore ，然后修改了 anotherScore 的第1个元素的值，最后分别打印了 someScore 和 anotherScore 第 1 个元素的值。 someScore 元组第一个元素的值为 Robert ，而 anotherScore 元组第一个元素的值仍然为 John 。由此可见元组是值类型。 文章来自这里 其他文章 1 Swift init 方法 在我们刚刚接触 Swift 时，可能会遇到 init 构造方法 的各种坑，各种报错，那么 Apple 为什么要这样做呢？难道是无聊虐开发者吗？当然不是，其实我们在使用 Objective-C 编码时，对于新手来说太多坑了，比如：在 init 中调各种方法，访问各种属性等，在 Objective-C 中其实 Apple 是不推荐在 init 中访问属性的，因为此时可能部分属性根本没有初始化，可能导致一系列的问题存在。到了 Swift 时，Apple 做了强制措施，彻底解决类似的问题。 Apple 在 Swift 中的 init 方法做各种限制的终极目标就是为了 保证使用者不关使用什么方式创建对象，均保证在初始化完成前所有的属性都被初始化，明白这目的时，对 Swift 的 init 就比较好理解了,具体的可以参考下面的文章，就不再一一分析了哈，逃. http://swifter.tips/init-keywords/ https://www.jianshu.com/p/b1ab25ab00c1 iOS的一点调试技巧 下面使用GIF简单快速介绍几种断点调试 普通断点 普通断点编辑为条件断点 全局断点 符号断点 值监控 http://blog.csdn.net/u012729522/article/details/53184711 https://daiweilai.github.io/2015/04/13/iOS各种调试技巧/ https://objccn.io/issue-19-2/ copy mutableCopy 对 NSString写在前面 在iOS开发中可能有时候会接触到copy和mutableCopy这两个方法，而且其相关的内存问题经常出没于面试题中，本文简单介绍下mutableCopy及copy与NSString和集合类的相关问题。 copy, mutableCopy对NSString操作 在对NSString进行copy或者mutableCopy操作时可以使用下图的内存分配情况来表述 由上可得， copy 对 NSString 是浅拷贝，只拷贝指 NSString为什么要使用copy修饰写在前面 NSString 属性为什么应该使用copy修饰，使用strong为什么不行？我们可能都知道NSString/Blocks类型的属性使用copy来修饰，why？最近看到这篇blog感觉讲得较完善，那么我也把自己的一点体会和理解记录下吧，欢迎指正。 我们先定义一个测试类BMPerson 1234567@interface BMPerson : NSObject@property (strong, nonatomic) NSString *strStrong; ///&lt; strStrong@property (copy, nonatomic) NSString *strCopy; ///&lt; strCopy@end@implementation BMPerson@end 在main函数中执行如下代码： 1234567NSString *str = @"abc";BMPerson *per = [BMPerson new];per.strStrong = str;per.strCopy = str;NSLog(@"修改str前：per.strStrong = %@ per.strCopy = %@", per.strStrong, per.strCopy);str = @"qwe";NSLog(@"修改str前：per.strStrong = %@ per.strCopy = %@", per.strStrong, per.strCopy); 会输出如下的log 12修改str前：per.strStrong = abc per.strCopy = abc修改str前：per.strStrong = abc per.strCopy = abc 似乎是strong和copy没有任何区别，那么我们换一种方式看看，使用下面的代码测试 1234567NSMutableString *str = [NSMutableString stringWithFormat:@"abc"];BMPerson *per = [BMPerson new];per.strStrong = str;per.strCopy = str;NSLog(@"修改str前：per.strStrong = %@ per.strCopy = %@", per.strStrong, per.strCopy);[str appendString:@"+a"];NSLog(@"修改str前：per.strStrong = %@ per.strCopy = %@", per.strStrong, per.strCopy); 会输出如下的log 12修改str前：per.strStrong = abc per.strCopy = abc修改str前：per.strStrong = abc+a per.strCopy = abc 我们发现本来给 per.strStrong 赋值的是 @“abc”，但在修改了str后发现per.strStrong的值也变了，但是使用copy修饰的并不会变化，在这篇blog的基础上简单画了下内存分配图如下： 第一种方式 第二种方式 由上面的图我们应该可以发现问题所在（如果不清楚可以下方留言哈），所以NSSring类型的属性时我们尽量使用copy修饰吧。 最后 DEMO地址 参考 http://ibloodline.com/articles/2016/07/07/copy.html iOS逆向之获取第三方App头文件 之前随便看了下iOS逆向的知识，下面的一个最简单的使用，获取第三方App头文件，如：微信，支付宝等。 操作步骤 首先需要用一个工具class-dump点我下载 下载好以后解压如下图： 把class-dump-3.5文件夹下的class-dump文件夹拖入/usr/local/bin 目录下 打开终端 cd /usr/local/bin 再 执行 sudo chmod 777/usr/local/bin/class-dump 输入密码 下载PP助手或者其他可以下载越狱应用的应用（正版需要砸壳），下载越狱应用后解压 执行 class-dump -H /Users/daredos/Desktop/微信-6.3.23\(越狱应用\)/Payload/WeChat.app -o /Users/daredos/Desktop/wx /Users/daredos/Desktop/微信-6.3.23\(越狱应用\)/Payload/WeChat.app 表示App全路径 /Users/daredos/Desktop/wx 表示获取到的.h 存放的路径 效果图 在Storyboard 及 Xib 中为 TableView 设置 HeaderView 和 FooterView 本项目主要是介绍在Storyboard（下面检测SB）及Xib中给UITableView设置tableHeaderView，tableFooterView的方法。默认认为已经基本熟悉SB/Xib的使用哈。 在平时的项目开发中，可能使用SB或者Xib会特别快，当然喜欢代码的就可以忽略了哈。我们在用UITableView可能会使用到tableHeaderView，tableFooterView这2个属性，在有一些需求来说是得心应手。之前都是使用代码添加UITableView的tableHeaderView，tableFooterView，虽然也挺方便，那么是否可以使用xib直接添加呢？在网上搜了下，答案是可以的哈，下面的简单介绍下添加的方式。 SB 中给UITableView设置tableHeaderView，tableFooterView Xib 中给UITableView设置tableHeaderView，tableFooterView 运行结果 怎么样自适应高度可以添加如下代码完成自适应，参考于这里 1234567891011121314151617- (void)viewDidLayoutSubviews &#123; [super viewDidLayoutSubviews]; &#123; CGFloat height = [self.tableView.tableFooterView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height; CGRect footerFrame = self.tableView.tableFooterView.frame; footerFrame.size.height = height; self.tableView.tableFooterView.frame = footerFrame; self.tableView.tableFooterView = self.tableView.tableFooterView; &#125; &#123; CGFloat height = [self.tableView.tableHeaderView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize].height; CGRect headerFrame = self.tableView.tableHeaderView.frame; headerFrame.size.height = height; self.tableView.tableHeaderView.frame = headerFrame; self.tableView.tableHeaderView = self.tableView.tableHeaderView; &#125;&#125; 项目源码 Demo源码 参考 在Storyboard中为UITableView添加Header和Footer 关于SB中的TableView和XIB中的TableView iOS开发之@weakify, @strongify 为什么在使用Block时需要注意使用 @weakify 和 @strongify 不使用 @weakify我们在使用MJRefresh时如果不使用@weakify且如下编写代码 1234567self.tableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^&#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; // 这里使用了 self 没有使用__weak [self.tableView.mj_header endRefreshing]; [self.tableView reloadData]; &#125;);&#125;]; 可以使用腾讯微信读书开源的MLeaksFinder很容易检测到内存泄露 不使用 @strongify 下面举一个不使用 @strongify 会出现的问题，代码如下： 12345678910111213141516__weak typeof(self) wself = self;dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_global_queue(0, 0), ^&#123; if (self) &#123; sleep(2); NSLog(@"%@", @[wself]); &#125; &#125;);&#125;);dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; sleep(2); dispatch_async(dispatch_get_main_queue(), ^&#123; [self.navigationController popViewControllerAnimated:YES]; &#125;);&#125;); 会直接崩溃，而且我们这里做了判空处理。 总结 由上面的问题可见在使用Block时注意使用@weakify 和 @strongify 是如此的重要，那么上面的代码安全的方式应该是如下代码. 12345678910__weak typeof(self) wself = self;self.tableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^&#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; __strong typeof(wself) self = wself; if (self) &#123; [self.tableView.mj_header endRefreshing]; [self.tableView reloadData]; &#125; &#125;);&#125;]; 1234567891011121314151617181920__weak typeof(self) wself = self;dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_global_queue(0, 0), ^&#123; __strong typeof(wself) self = wself; if (self) &#123; sleep(2); NSLog(@"%@", @[self]); &#125; &#125;);&#125;);dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; sleep(2); dispatch_async(dispatch_get_main_queue(), ^&#123; __strong typeof(wself) self = wself; if (self) &#123; [self.navigationController popViewControllerAnimated:YES]; &#125; &#125;);&#125;); 使用我们在使用Block如果使用了self而且可能有相互引用的情况，那么应该注意 @weakify 和 @strongify 以及 必要的判空操作。 本Demo源码 iOS开发之自定义View的一些坑 我们做几个简单的例子哈 自定义一个View View的m文件中有代码如下: 1234567891011121314151617@implementation BMView- (instancetype)init &#123; if (self = [super init]) &#123; NSLog(@"init"); &#125; return self;&#125;- (instancetype)initWithFrame:(CGRect)frame &#123; if (self = [super initWithFrame:frame]) &#123; NSLog(@"initWithFrame"); &#125; return self;&#125;@end 使用如下代码： 1234567891011NSLog(@"new ");[BMView new];NSLog(@"\n ");NSLog(@"alloc init");[[BMView alloc] init];NSLog(@"\n ");NSLog(@"alloc initWithFrame");[[BMView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];NSLog(@"\n "); 输出如下： 12345678910111202.165 ViewDemo[32765:1250187] new 02.165 ViewDemo[32765:1250187] initWithFrame02.165 ViewDemo[32765:1250187] init02.166 ViewDemo[32765:1250187] 02.166 ViewDemo[32765:1250187] alloc init02.166 ViewDemo[32765:1250187] initWithFrame02.166 ViewDemo[32765:1250187] init02.166 ViewDemo[32765:1250187] 02.167 ViewDemo[32765:1250187] alloc initWithFrame02.167 ViewDemo[32765:1250187] initWithFrame 我们发现 使用new和alloc init会调用 initWithFrame init方法 使用initWithFrame会只会调用 initWithFrame方法 自定义BMTableView UITableView1的m文件中有代码如下: 123456789101112131415161718192021222324@implementation BMTableView- (instancetype)init &#123; if (self = [super init]) &#123; NSLog(@"init"); &#125; return self;&#125;- (instancetype)initWithFrame:(CGRect)frame &#123; if (self = [super initWithFrame:frame]) &#123; NSLog(@"initWithFrame"); &#125; return self;&#125;- (instancetype)initWithFrame:(CGRect)frame style:(UITableViewStyle)style &#123; if (self = [super initWithFrame:frame style:style]) &#123; NSLog(@"initWithFrame style"); &#125; return self;&#125;@end 使用如下代码： 123456789101112131415NSLog(@"new");[BMTableView new];NSLog(@"\n");NSLog(@"alloc init");[[BMTableView alloc] init];NSLog(@"\n"); NSLog(@"alloc initWithFrame");[[BMTableView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];NSLog(@"\n"); NSLog(@"alloc initWithFrame style");[[BMTableView alloc] initWithFrame:CGRectMake(100, 100, 100, 100) style:UITableViewStylePlain];NSLog(@"\n"); 输出如下： 1234567891011121314151643.615 ViewDemo[32847:1259789] new43.637 ViewDemo[32847:1259789] initWithFrame style43.637 ViewDemo[32847:1259789] initWithFrame43.637 ViewDemo[32847:1259789] init43.638 ViewDemo[32847:1259789] 43.638 ViewDemo[32847:1259789] alloc init43.639 ViewDemo[32847:1259789] initWithFrame style43.639 ViewDemo[32847:1259789] initWithFrame43.640 ViewDemo[32847:1259789] init43.640 ViewDemo[32847:1259789] 43.640 ViewDemo[32847:1259789] alloc initWithFrame43.641 ViewDemo[32847:1259789] initWithFrame style43.641 ViewDemo[32847:1259789] initWithFrame43.642 ViewDemo[32847:1259789] 43.642 ViewDemo[32847:1259789] alloc initWithFrame style43.642 ViewDemo[32847:1259789] initWithFrame style 我们发现 使用new和alloc init会调用 initWithFrame style initWithFrame init方法 使用initWithFrame会调 initWithFrame style initWithFrame方法 使用initWithFrame style会只会调用 initWithFrame style 方法 why 为什么我们只是单纯的调用了 new 或者 init 就会跑到了各种构造方法中呢？感觉有一些奇怪，其实是见怪不怪。我们可以通过Chameleon查看UIView和UITableView的底层实现便一目了然。 UIView.m UIView的m文件中可看到如下代码UIView.m： 123456789101112- (id)init&#123; return [self initWithFrame:CGRectZero];&#125;- (id)initWithFrame:(CGRect)theFrame&#123; if ((self=[super init])) &#123; // ... &#125; return self;&#125; UITableView.m UITableView的m文件中可看到如下代码: UITableView.m 123456789101112- (id)initWithFrame:(CGRect)frame&#123; return [self initWithFrame:frame style:UITableViewStylePlain];&#125;- (id)initWithFrame:(CGRect)frame style:(UITableViewStyle)theStyle&#123; if ((self = [super initWithFrame:frame])) &#123; // ... &#125; return self;&#125; 看到源码后当然就一目了然了，所以我们在自定义一些UI控件时不要盲目的重写各种构造方法，感觉好高大上，其实就是一个大坑😀，之前博主也踩过😭（可能是我孤陋寡闻了）。感谢团队中阿海的指出。随便提醒下，我们可以通过https://github.com/BigZaphod/Chameleon知道天天使用的UITableView为什么那么纵享丝滑，或者各种好玩的东西。 如何编写initWith... 方法 自定义一个类BMObj,编写如下代码，是否有不合适的地方？ 123456789101112131415- (instancetype)init &#123; if (self = [super init]) &#123; //... &#125; return self;&#125;- (instancetype)initWithName:(NSString *)name age:(int)age &#123; if (self = [super init]) &#123; _name = name; _age = age; //... &#125; return self;&#125; 上面的写法其实有一些问题，正确的编写如下: 1234567891011- (instancetype)init &#123; return [self initWithName:nil age:0];&#125;- (instancetype)initWithName:(NSString *)name age:(int)age &#123; if (self = [super init]) &#123; _name = name; _age = age; &#125; return self;&#125; 之所以这样编写init...是为了达到和系统init...一样的目的，可移步这里查看究竟。同时可以查看一些第三方的写法也如此YYCache。 参考 iOS开发之自定义View的一些坑 https://github.com/BigZaphod/Chameleon 一些小知识点结构体12345678910111213141516171819struct BMerson &#123; int age; double height;&#125;;typedef struct BMerson BMerson;BMerson BMersonMake1(int a, double h) &#123; BMerson p = &#123;1, 1.0&#125;; return p;&#125;BMerson BMersonMake2(int a, double h) &#123; BMerson p = &#123; .age = a, .height = h, &#125;; return p;&#125; const关键字1234567891011121314151617181920212223242526272829303132333435363738394041&#123; int a1 = 0; a1 = 10; const int a2 = 0; printf("%d", a2); // error a2 = 10; int const a3 = 0; printf("%d", a3); // error a3 = 10;&#125; &#123; int a1; int *p1; p1 = &amp;a1; *p1 = 10; const int *p2; const int a2 = 10; p2 = &amp;a2; p2 = &amp;a1; // error *p2 = 10; int const *p3; p3 = &amp;a2; p3 = &amp;a1; // error *p3 = 10; int * const p4 = NULL; // error p4 = &amp;a2; // error p4 = &amp;a1; *p4 = 10; const int * const p5; printf("%p", p5); // error p5 = &amp;a2; // error p5 = &amp;a1; // error *p5 = 10;&#125; iOS中的常量常量 通知名 1234UIKIT_EXTERN NSNotificationName const BMLoginSuccessNotification;// NSNotificationName const BMLoginSuccessNotification = @"BMLoginSuccessNotification";extern NSNotificationName const BMLoginFailureNotification;// NSNotificationName const BMLoginFailureNotification = @"BMLoginFailureNotification"; NSString常量 1234UIKIT_EXTERN NSString *const BMUserName;// NSString *const BMUserName = @"BMUserName";extern NSString *const BMUserKey;// NSString *const BMUserKey = @"BMUserKey"; 值常量 1234UIKIT_EXTERN const CGFloat BMNavHeight;const CGFloat BMNavHeight = 10.0f;extern const CGFloat BMNavWidth;const CGFloat BMNavWidth = 10.0f; Apple 尺寸 设备型号 屏幕尺寸 开发尺寸 像素尺寸 倍图 4/4S 3.5英寸 320*480 640*960 @2X 5/5S/5C/SE 4.0英寸 320*568 640*1136 @2X 6/6S/7/8 4.7英寸 375*667 750*1134 @2X 6P/6SP/7P/8P 5.5英寸 414*736 1242*2208 @3X X 5.8英寸 375*812 1125*2436 @3X iPad Mini 4 / iPad Air 2 / iPad Pro (9.7) 9.7英寸 768*1024 1536*2048 @2X iPad Pro(12.9) / iPad Pro(12.9) (第二代) 12.9英寸 1024*1036 2048*2732 @2X iPad Pro(10.5) 10.5英寸 1112*834 2224*1668 @2X 最后 http://nshipster.cn/swift-objc-runtime http://www.hmttommy.com/2015/12/11/AddCategoryProperty http://stackoverflow.com/questions/29106891/how-do-i-pass-in-a-void-block-to-objc-setassociatedobject-in-swift http://swifter.tips/singleton]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种资料收集区]]></title>
    <url>%2F2016%2F09%2F10%2F00-%E6%8A%80%E6%9C%AF-iOS%2F%E5%90%84%E7%A7%8D%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[一些学习网站 google.com google.com.hk github objc.io objc 中国 NSHipster NSHipster 中文 Stackoverflow oleb.net https://www.natashatherobot.com http://www.w3school.com.cn http://www.Raywenderlich.com http://tutsplus.com/ https://designcode.io/ http://subjc.com/ https://maniacdev.com/ 阮一峰 廖雪峰 天才 王垠 IT社区 http://www.cnblogs.com/ http://www.csdn.net/ http://www.51cto.com http://www.cocoachina.com http://www.techcn.com.cn/ http://mobilehub.io/ 一些收集资料的blog 收藏的iOS技术网站汇总(持续更新) iOS学习资源汇总(开源项目、第三方库、技术博客等等) GitHub上史上最全的iOS开源项目分类汇总 GitHub 上 iOS 开源库 Top 100 http://www.jianshu.com/p/b7c4a787a597?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=qq 一个收集了 502 款开源 iOS 应用的开源项目 http://www.jianshu.com/p/e5353a1a752c iOS开发常用三方库、插件、知名博客等等 各种优化UITableView 自适应Cell的两种方式 sunnyxx 优化UITableViewCell高度计算的那些事 TableView优化技巧 个人博客 唐巧的技术博客 Why’s blog - 汪海的实验室 阿毛的蛋疼地 Ted’s Homepage coding with objc &amp; swift Yuan博客 KooFrank’s Blog 庞海礁的个人空间 猫&middot;仁波切 Lex Tang 代码手工艺人 Cocoabit webfrogs Chun Tips hello it works Luke’s Homepage 克伟的博客 Kevin Blog 破船之家 Kenshin Cui’s Blog YIFEIYANG–易飞扬的博客 Vienta’s Cell 阿峰的技术窝窝 Limboy 无网不剩 玉令天下的Blog 码农人生 言无不尽 里脊串的开发随笔 nixzhu on scriptogr.am txx’s blog Nonomori 技术哥的博客 念茜的博客 Casa Taloyum 萧宸宇 不掏蜂窝的熊 Travis’ Blog 亚庆的 Blog NSHipster 土土哥的技术Blog I’m Allen I’m TualatriX DavidDay&rsquo;s Blog 王中周的技术博客 Nico 刘坤的技术博客 Xcode Dev sunnyxx的技术博客 answer_huang 煲仔饭 会写代码的猪 OneV’s Den 摇滚诗人 Lancy’s Blog Wonderffee’s Blog Shining IO 不会开机的男孩 老谭笔记 腾讯微信bang，JSPatch开发者 一名94后iOS开发者 标哥的技术博客 唐巧总结的40个国人iOS技术博客 百度程序员 讲了一些runtime http://oncenote.com/ Mac常用命令 刘坤的技术博客-阿里 Tian Wei Yu uiscrollview与autolayout的所有 http://www.jianshu.com/p/b7c4a787a597?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=qq http://www.cocoachina.com/ios/20150701/12301.html YYCache源码分析(一) http://blog.devtang.com/2015/11/02/mvc-and-mvvm/ 较完整的APP Github 上的 iOS 开源项目 介绍 http://www.cnblogs.com/Piosa/archive/2013/02/26/2933905.html http://www.thinkandbuild.it/ http://robb.is/ http://commandshift.co.uk/ http://indieambitions.com/ http://nvie.com/ http://stuartkhall.com/ http://blog.ittybittyapps.com/ http://adoptioncurve.net/ 开源项目 一款天气预报的应用（已在AppStore上线) 知乎 GitHub 上有哪些完整的 iOS-App 源码值得参考 源码分析 简书 iOS源码解读 Draveness/analyze 强力推荐 iOS 源码解读 GitHub 上有哪些完整的 iOS-App 源码值得参考 http://www.jianshu.com/u/019503ab19f1 http://www.jianshu.com/p/b4bea1549a66 https://www.cnblogs.com/ludashi/p/5591572.html 团队博客 美团点评技术团队blog 滴滴团队blog 微信读书团队blog 去哪儿团队blog APP架构方面 Casa Taloyum 讲了一些网络层架构问题 刘坤的技术博客，讲了一些网络层架构问题 其他 项目多余资源检测工具 项目代码行数统计 Xcode历史版本下载 Xcoded代码块 iOS 调试包/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport 自动打包构建框架 https://github.com/fastlane/fastlane 一些网站 爱情守望者_致力于分享最精彩的Mac软件 精品MAC应用分享 Mac 上优秀的 iO S设备 AirPlay 屏幕镜像工具 脚本之家 科学上网 Ti 1 Ti 2 Ti 3 算法RSA RSA算法原理（一） RSA算法原理（二） 参考 http://www.jianshu.com/p/e5353a1a752c]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Runtime为现有的类添加Weak属性]]></title>
    <url>%2F2016%2F08%2F10%2F00-%E6%8A%80%E6%9C%AF-iOS%2F%E4%BD%BF%E7%94%A8Runtime%E4%B8%BA%E7%8E%B0%E6%9C%89%E7%9A%84%E7%B1%BB%E6%B7%BB%E5%8A%A0Weak%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[写在前面 在为现有的类增加属性时，我们首先会想到使用Runtime的对象绑定来处理，对象绑定也是我们在平时的开发中经常使用的伎俩,但是这里想增加的是weak类型的属性，查看Apple API 在对象绑定时没有提供此类型，如果有，那就没有这篇blog了，那么weak有什么特殊性呢？最简单的是引用计数不 +1，不存在相互引用 在属性释放时会自动置nil 适用于对象等。 思考🤔与实现方案1方案描述 那么我们怎么实现类似的功能呢？当然是从assign出手，其特性是引用计数不+1，不存在相互引用 在属性释放时不会自动置nil等。那么我们可以使用assign来模拟实现weak属性，只需要在属性释放时自动置nil即可。 方案实现 简单封装为如下的使用方式 123- (void)bm_setWeekAssociatedObjectWithKey:(const void *)key value:(id)value OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0);- (id)bm_getWeakAssociatedObjectWithKey:(const void *)key OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0); 具体实现请查看Demo 方案2 使用NSPointerArray处理 参考https://github.com/ChenYilong/iOSInterviewQuestions]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods 的简单使用]]></title>
    <url>%2F2016%2F08%2F06%2F00-%E6%8A%80%E6%9C%AF-iOS%2FCocoapods-%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[之前做项目时，基本没有使用过 cocoapods，因为听道上的人说，使用 cocoapods 好麻烦，有时候出现一下坑的事情都不知道怎么弄，好坑的说，但是由于项目慢慢的迭代，导致使用的 第三方越来越多，而且还牵涉到 第三方库的版本问题，瞬间感觉好麻烦，还是玩玩 cocoapods 吧，本文主要讲述 cocoapods的使用 以初始化项目的一些注意点。 前提在已经安装好 cocoapods 的情况下 ~/Library/Caches/CocoaPods/ ~/Library/Caches/CocoaPods/Pods ~/.cocoapods/repos/master rm ~/Library/Caches/CocoaPods/search_index.json pod setup pod repo update pod install –no-repo-update pod update –no-repo-update 使用 Cocoapods初步使用pod1、使用 Xcode 创建一个名为： myCocoapods 的项目 2、创建 .gitignore 文件 touch .gitignore，配置好我们平常需要忽略的相关文件，打开 Pods/ 可以参考github官方之gitignore 3、cd 到刚才的项目 4、pod init 如果是升级 Xcode8 后，可能执行 pod init 后没有任何反应或者其他错误查找资料得:执行 sudo gem install -n /usr/local/bin cocoapods --pre后可正常使用参考自 5、pod update 6、在 Podfile 中添加相应的第三方 最简单的版本选择:参考 1234567891011121314151617181920# 取最新版本pod 'MJRefresh',# 取3.1.12pod 'MJRefresh', ‘3.1.12'# [3.1.12 ...]pod 'MJRefresh', ‘&gt;=3.1.12'# (3.1.12 ...]pod 'MJRefresh', ‘&gt;3.1.12'# [0.0.0 3.1.12]pod 'MJRefresh', ‘&lt;=3.1.12'# [0.0.0 3.1.12)pod 'MJRefresh', ‘&lt;3.1.12'# [3.1.12 3.2.0)pod 'MJRefresh', ‘~&gt;3.1.12' 7、 在 pod update 或者 pod update --verbose --no-repo-update 8、把项目 push 到仓库 9、项目的初始化基本OK，另一个开发到来以后直接去 git 仓库 clone 项目下来 10、然后 pod update 或者 pod update --verbose --no-repo-update 一下即可正常使用了 11、项目结构如下： Demo链接 pod的一些命令列出所有本地已经缓存的第三方库1pod cache list 输出如下 1234567iCarousel:- Version: 1.8.2Type: ReleaseSpec: /Users/vivi/Library/Caches/CocoaPods/Pods/Specs/Release/iCarousel/1.8.podspec.jsonPod: /Users/vivi/Library/Caches/CocoaPods/Pods/Release/iCarousel/1.8.2-67c8alibextobjc:... 清除指定缓存1pod cache clean libName 清除全部缓存1pod cache clean all 让自己的代码使用 cocoapods 管理1、在github创建项目 2、初始化好项目 3、clone 项目下来 4、到项目root目录下， 创建 spec 文件cd 项目pod spec create 名称 5、编辑 spec 文件 （MJRefresh的spec文件是这样写的，里面具体的含义以后补充，或者 自行Google） 12345678910111213Pod::Spec.new do |s|s.name = 'MJRefresh's.version = '3.1.12's.summary = 'An easy way to use pull-to-refresh's.homepage = 'https://github.com/CoderMJLee/MJRefresh's.license = 'MIT's.authors = &#123;'MJ Lee' =&gt; '199109106@qq.com'&#125;s.platform = :ios, '6.0's.source = &#123;:git =&gt; 'https://github.com/CoderMJLee/MJRefresh.git', :tag =&gt; s.version&#125;s.source_files = 'MJRefresh/**/*.&#123;h,m&#125;'s.resource = 'MJRefresh/MJRefresh.bundle's.requires_arc = trueend 6、新建 tag 且提交项目 git add . git commit -m &#39;0.01&#39; git tag 0.0.1 git push --tags git push origin master 7、验证一下 podspec 文件 pod lib lint 8、如果是第一次提交需验证一下,不是第一次可以不用此步 pod trunk register ios@idhong.com &#39;idhong&#39; --description=‘一些描述’ 此时需要登录邮箱验证一下身份，看提示即可 9、提交给 cocoapods 管理 pod trunk push IHExtension.podspec --allow-warnings 10、如果成功，可能需要等几分钟才可以 search 到你的 lib, 可去cocoapods查看 11、提交好了以后如果还是无法搜索到自己的项目，可以尝试： 123pod setuprm ~/Library/Caches/CocoaPods/search_index.json 12、继续 1pod search XXX 13、如果想多人维护一个库（需先让指定的邮箱注册） pod trunk add-owner IHExtension xxx@xxx.com 14、查看自己的信息 pod trunk me Demo链接 公司公共模块使用 cocoapods 管理pod 的配置文件放在cocoapods官网 配置里的指向github上面的方式 pod 的配置文件放在cocoapods官网 配置里的指向内网外面可以搜到到，但是无法下载，需要打tag 1、如果公司的项目较多，那么许多公共模块，一些工具类如果使用 pod 管理起来就更加方便了。 2、一个方法的只需要把上面配置文件；s.homepage s.source 指向自己的内网就👌,虽然把 pod 的配置文件push 到了cocoapods 官网，但是别人其实无法查看其中的任何内容。 使用和配置都比较简单，但是外面的人会搜到你的模块，只是无法下载 配置文件 使用电脑路径的方式使用还比较简单，而且不需要打 tag，比较适合公共模块在开发阶段，push就可以了 – pod ‘iOS-Echarts’, :path =&gt; ‘../iOS-Echarts’路径为 podspec 在本电脑的的路径，可以把自己的私有第三方放在内网上，然后下载到本地方的一定路径，可以放到 ~/ 的路径那么全部成员的电脑都可以正常使用了，可以自由发挥，但是保证配置完全正确 使用 私有 repo 管理配置文件的方式操作比较复杂，需要打 tag，适合于公共模块已经比较稳定的情况 思路为自己创建私有的spect来管理内部的 lib 的配置文件，就和其他公共第三方放到 cocoapods 官网一样 需要创建一个私有的管理 第三方的配置的 库 创建一个自己的库让私有仓库管理 创建好上面的2个库 添加进去 pod repo add spect的名称 spect的git地址 验证一下 pod spec lint IHKit.podspec --sources=&#39;https://github.com/liangdahong/IHKit.git, https://github.com/CocoaPods/Specs.git&#39; --allow-warnings push到自己的私有仓库进行管理 pod repo push &#39;IHCocoapods&#39; IHKit.podspec --allow-warningspush 时需要在全部配置好的情况下，配置文件填写完整，tag配置ok 完成后就可以正常使用了在 Podfile 声明一下 1234# 官方库source 'https://github.com/CocoaPods/Specs.git'# 私有库 source 'https://github.com/liangdahong/IHCocoapods.git' 想删除一个库，可以用 pod repo remove WTSpecs 如果想删除一个库的一个版本 可以直接到文件夹下删除指定的文件夹 在 push 到 git 就好了 其他人使用时，pod repo add spect的名称 spect的git地址 添加到目录下，以后用更新只需要cd ~/.cocoapods/repos 到指定的目录下 pull 就OK 参考1 参考2 参考3 利用 appledoc 生成 API 文档 克隆项目 git clone https://github.com/tomaz/appledoc.git 到目录下 cd appledoc 安装 sudo sh install-appledoc.sh 查看版本情况 appledoc --version 生成文档 appledoc --no-create-docset --output 生成的文档保存的路径 --project-name &quot;你的项目名称&quot; --company-id &quot;com.idhong&quot; --project-company &quot;公司名称&quot; 需要生成文档的项目 参考1参考2 pod pod init 创建 Podfile 文件 pod setup 更新 pod search afn 搜索第三方库 pod install 安装第三方库 pod install –verbose –no-repo-update pod install –no-repo-update pod update pod update –verbose –no-repo-update pod update –no-repo-update ~/Library/Caches/CocoaPods/search_index.json ~/.cocoapods/repos/]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>Cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回忆我们系安排的实习]]></title>
    <url>%2F2016%2F07%2F01%2F05-%E7%94%9F%E6%B4%BB-%E6%84%9F%E5%8F%B9%2F%E5%9B%9E%E5%BF%86%E6%88%91%E4%BB%AC%E7%B3%BB%E5%AE%89%E6%8E%92%E7%9A%84%E5%AE%9E%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[今天不知道为什么突然想起了大学时学校安排的实习，下面简单说下吧。 美其名曰实习，其实就是去东莞各种电子厂当普工，就是普工也算了，记得去实习的时候学校包了1台大巴车，TM不知道找了几层中介找的车，路线不熟悉，各种转来转去，还以为迷路了，也忍，好不容易转来了传说的实习基地，TM就是一个加工厂，而且是一个特别小的，也忍了，然后去办理手续，哈哈，就和去工厂入职一样，而且还有一些高考完的学生来打暑假工，社会青年办入职手续等（其实我们也是他找的一个中介带过来的，TM一个系主任居然找不到一个实习合作，就算找不到也不至于这样吧，我们自己找啊，又不允许）。哈哈，也忍了，其实当时已饿得精疲力尽，好想休息（可能是为了锻炼我们的意志吧，哈哈），因为是第一天晚上12点的车，当时差不多下午3点了（具体时间忘记了），终于可以带我们去传说的寝室了，到了一看，这次一共来了差不多30人左右（具体忘记了），就2间房间，一间大概20个平方吧，一个洗手间，2个房间，一个客厅，而且TM好像就3，4个上下铺，大搞就8个床位（8个床8个人，2间房16人，来了差不多30人，难道换着睡），呵呵，真他妈无语啊，想想就可怕。广州夏天的天气你懂的（38°左右吧），没有空调。我们那传说的系主任看了下好像实在是放不下我们（😭），哈哈，然后另外在租了一间房子，终于勉勉强强住下了，现在想起真的无语，只记得晚上经常热醒。至于上班环境就不说了，可以搜索下东莞富士康等类似的加工厂，但我敢保证肯定没有富士康等知名加工厂环境好，在看看食堂吧，TM进去一股不知道什么味道，反正去过一场就在也没去过（为哪里长期上班的朋友感到不知扫描感觉，不容易啊），真够心黑啊，熬了几天许多人反应问题，想早点回去，我们传说的系主任各种推迟，各种理由（TM就天天住酒店），最后实在坚持不了了，说干满多少天实习分就优秀，干不满就及格。最后我们大部分人做了差不多一个月回学校了。真是一次难忘的实习啊。]]></content>
      <categories>
        <category>05-生活-感叹</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS系统第三方分享框架Social.framework的使用]]></title>
    <url>%2F2016%2F06%2F01%2F00-%E6%8A%80%E6%9C%AF-iOS%2FiOS%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%96%B9%E5%88%86%E4%BA%AB%E6%A1%86%E6%9E%B6Social-framework%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[iOS系统提供了一个最简单的第三方分享框架Social.framework 但是支持的平台有限，而且几乎没什么人使用，但是使用真的特别特别简单 import Social1#import &lt;Social/Social.h&gt; 创建分享控制器1SLComposeViewController *composeViewController = [SLComposeViewController composeViewControllerForServiceType:SLServiceTypeSinaWeibo]; 开始分享1234[self presentViewController:composeViewController animated:YES completion:nil];// 分享结果监控composeViewController.completionHandler = ^(SLComposeViewControllerResult result)&#123;&#125;; 建议在使用时做一些必要性的判断和处理,应该是有史以来iOS最简单的第三方分享了！]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发的一些终端命令]]></title>
    <url>%2F2016%2F05%2F02%2F00-%E6%8A%80%E6%9C%AF-iOS%2FiOS%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[#iOS开发的一些终端命令 基本命令12// 显示隐藏文件defaults write com.apple.finder AppleShowAllFiles -bool true 12// 隐藏隐藏文件defaults write com.apple.finder AppleShowAllFiles -bool false Git 命令开发常用1234git pull // 查看本地分支情况git checkout . // 恢复修改git commit -m "备注" // 提交代码git push // push 到服务器 分支查看分支123git branch // 查看本地分支情况git branch -r // 查看服务器分支情况git branch -a // 查看所有分支情况 创建123git checkout branch_name // 切换分支git checkout -b newBranch_name // 创建新分支 git push origin newBranch_name // 把创建的分支 push 到服务器 删除1git push origin :branch_name 删除分支 tag 操作查看 tag 情况1git tag 新建tag12git tag tagName || git tag -a v0.1 -m "备注信息" // 打taggit push -u origin tagName // push tag 删除 tag12git tag -d tagName // 删除本地taggit push origin : tagName // push tag 参考自 廖雪峰的官方网站 cocoapods常用12345678pod installpod install --no-repo-updatepod updatepod update --no-repo-updatepod search xxxpod setup 其他POD 缓存管理 列出所有本地已经缓存的第三方库 1pod cache list 结果如下: 1234567iCarousel: - Version: 1.8.2 Type: Release Spec: /Users/vivi/Library/Caches/CocoaPods/Pods/Specs/Release/iCarousel/1.8.podspec.json Pod: /Users/vivi/Library/Caches/CocoaPods/Pods/Release/iCarousel/1.8.2-67c8alibextobjc:... 清除指定第三方缓存 1pod cache clean libName 清除全部缓存 1pod cache clean all mac 命令行 别名 cd ~ touch .bash_profile open .bash_profile 1alias ll=&apos;ls&apos; 其中 alias（别名）表示声明一个别名,使用ll 代替ls命令]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种排序算法]]></title>
    <url>%2F2016%2F04%2F10%2F03-%E6%8A%80%E6%9C%AF-%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近准备弄一些简单的算法，先从排序开始吧，也不知道可以坚持多久，先这样。 代码地址 冒泡排序冒泡排序维基百科介绍 冒泡排序（英语：Bubble Sort，台灣另外一種譯名為：泡沫排序）是一種簡單的排序算法。它重複地走訪過要排序的數列，一次比較兩個元素，如果他們的順序錯誤就把他們交換過來。走訪數列的工作是重複地進行直到沒有再需要交換，也就是說該數列已經排序完成。這個算法的名字由來是因為越小的元素會經由交換慢慢「浮」到數列的頂端。 C语言实现原始版本1234567891011void bubbleSort(int *a, int n) &#123; for (int i = 0; i &lt; n - 1; i++) &#123; for (int j = 0; j &lt; n - i - 1; j++) &#123; if (a[j] &gt; a[j + 1]) &#123; int temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; &#125; &#125; &#125;&#125; 一点优化的版本1234567891011121314151617void bubbleSort(int *a, int n) &#123; int flag = 0; for (int i = 0; i &lt; n - 1; i++) &#123; flag = 0; for (int j = 0; j &lt; n - i - 1; j++) &#123; if (a[j] &gt; a[j + 1]) &#123; flag = 1; int temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; &#125; &#125; if (flag == 0) &#123; break; &#125; &#125;&#125; 扩展交换2个变量的一些方法1234567891011121314151617int c1 = 1;int c2 = 100; // 局部变量int temp = c1;c1 = c2;c2 = temp;// 加减法 &amp;&amp; 乘除法c1 = c1 + c2; // c1 = c1 * c2;c2 = c1 - c2; // c2 = c1 / c2;c1 = c1 - c2; // c1 = c1 - c2; // 异或c1 = c1 ^ c2;c2 = c1 ^ c2;c1 = c1 ^ c2; 获取数组中的最大值和最小值12345678910111213void getMaxMin(int *a, int n, int *max, int *min) &#123; int tempMax = a[0]; int tempMin = a[0]; for (int i = 1; i &lt; n; i++) &#123; if (a[i] &gt; tempMax) &#123; tempMax = a[i]; &#125; else if (a[i] &lt; tempMin) &#123; tempMin = a[i]; &#125; &#125; *min = tempMin; *max = tempMax;&#125; 选择排序选择排序维基百科介绍 选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 C语言实现12345678910111213141516void selectionSort(int *a, int n) &#123; int min, temp; for (int i = 0; i &lt; n; i++) &#123; min = i; for (int j = i; j &lt; n; j++) &#123; if (a[min] &gt; a[j] ) &#123; min = j; &#125; &#125; if (min != i) &#123; temp = a[min]; a[min] = a[i]; a[i] = temp; &#125; &#125;&#125; 插入排序插入排序维基百科介绍 插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 C语言实现12345678910111213141516171819202122void insertSort(int *a, int n) &#123; for (int i = 1; i &lt; n; i++) &#123; // 从1 开始取出后面的元素来来插入之前排好的数组中 // 取出 i 位置上的数 int temp = a[i]; // 遍历排序好的数组 for (int j = i; j &gt;= 0; j--) &#123; // 如果取出来的大于a[j-1] 说明已经排序好了 if (a[j-1] &lt; temp) &#123; // 赋值退出此层循环 a[j] = temp; break; &#125; else &#123; // 排序好的数组 a[j] = a[j-1]; a[j] = a[j-1]; &#125; &#125; &#125;&#125; 希尔排序 ShellSort归并排序 MergeSort快速排序 QuickSort堆排序 HeapSort]]></content>
      <categories>
        <category>03-技术-计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发中的一些第三方]]></title>
    <url>%2F2016%2F04%2F09%2F00-%E6%8A%80%E6%9C%AF-iOS%2FiOS%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%AC%E4%B8%89%E6%96%B9%2F</url>
    <content type="text"><![CDATA[下面是本人在做 iOS 开发一段时间以来，总结的一些项目开发必备知识和关键点😊，我会一直更新下去。谢谢你支持！同时更要感谢提供相关库的大神😁。如果有认为非常好的希望M我哦。 Objective-C网络 网络请求 AFNetworking 网络图片处理 SDWebImage 猿题库对 AFN 的封装 YTKNetwork 微信跨平台网络框架 mars UI控件 HUD MBProgressHUD、SVProgressHUD 刷新控件 MJRefresh 广告轮播器 SDCycleScrollView 侧滑菜单 MMDrawerController CoverFlow 效果 iCarousel 模糊效果 FXBlurView RDVTabBar RDVTabBar 启动页 JazzHand 图片浏览 MWPhotoBrowser 照片选择 TZImagePickerController 侧滑 Cell MGSwipeTableCell Facebook 开源的异步渲染库 AsyncDisplayKit 兼容 iOS7 Cell 侧滑多按钮功能 JZTableViewRowAction 富文本 TTTAttributedLabel 富文本 YYText 日历控件 FSCalendar 扁平风格的折线图 / 柱形图 PNChart 基于 Block 的 CA 动画 RBBAnimation 对系统 API (AVFoundation)、ZXing、ZBar的封装LBXScan Xib 桥 XXNibBridge 分页控制器 WMPageController、ARSegmentPager APP 内嵌 Safari TOWebViewController APP 内嵌 Safari SVWebViewController 颜色选择器 Color-Picker-for-iOS 空数据页 DZNEmptyDataSet 框架 键盘处理 IQKeyboardManager 代码布局 Masonry 数据解析 MJExtension Cell 的高度计算优化1 FDTemplateLayoutCell Cell 的高度计算优化2 BMTemplateLayoutCell 网络状态监测 Reachability 第三方管理 CocoaPods 全屏侧滑返回 FDFullscreenPopGesture 缓存，图片处理，数据解析等 YYKit FMDB 数据库 fmdb 热修复 JSPatch、JSPatch平台 日志工具 CocoaLumberjack RAC ReactiveCocoa Facebook 开源的动画框架 pop Socket CocoaAsyncSocket 基于 GPU 的图片处理框架 GPUImage NYXImagesKit NYXImagesKit WebViewJavascriptBridge WebViewJavascriptBridge AFDownloadRequestOperation AFDownloadRequestOperation KVOController KVOController LTNavigationBar LTNavigationBar FMDBMigrationManager FMDBMigrationManager TGRDataSource TGRDataSource 高效的加载 PDF Reader 一款蓝牙操作库 BabyBluetooth 支付宝类似的拖拽重排 BMDragCellCollectionView TableView的各种高度自适应及缓存 https://github.com/asiosldh/UITableView-BMTemplateLayoutCell 工具包 BlocksKit YYKit [sstoolkit] (https://github.com/soffes/sstoolkit) [BFKit] (https://github.com/FabrizioBrancati/BFKit) [BFKit-Swift] (https://github.com/FabrizioBrancati/BFKit-Swift) 不只是打包 Fastlane Swift Alamofire Masonry 的 Swift 版本 SnapKit SDWebImage 的 Swift 版本 AlamofireImage 喵神的网络图片处理库 Kingfisher IQKeyboardManager 的 Swift 版本 IQKeyboardManagerSwift RxSwift Mac 秒生 Model 代码 JSONExport https://github.com/liangdahong/BMExport 使用过的库 网络请求 AFNetworking 网络图片处理 SDWebImage 猿题库对 AFN 的封装YTKNetwork HUD MBProgressHUD、SVProgressHUD 刷新控件 MJRefresh 广告轮播器 SDCycleScrollView 侧滑菜单 MMDrawerController 图片浏览 MWPhotoBrowser 照片选择 TZImagePickerController 兼容 iOS7 Cell 侧滑多按钮功能 JZTableViewRowAction 日历控件 FSCalendar 键盘处理 IQKeyboardManager 代码布局 Masonry 数据解析 MJExtension Cell 的高度计算优化 FDTemplateLayoutCell 网络状态监测 Reachability 第三方管理 CocoaPods 全屏侧滑返回 FDFullscreenPopGesture 热修复 JSPatch、JSPatch平台 日志工具 CocoaLumberjack Facebook 开源的动画框架 pop 基于 GPU 的图片处理框架 GPUImage BFKit-Swift BlocksKit 网络请求 AFN 的 Swift 版本 Alamofire Masonry 的 Swift 版本 SnapKit SDWebImage 的 Swift 版本 AlamofireImage 喵神的网络图片处理库 Kingfisher IQKeyboardManager 的 Swift 版本 IQKeyboardManagerSwift 秒生 Model 代码 JSONExport 对系统 API (AVFoundation) 、 ZXing、ZBar 的封装 LBXScan Xib 桥 XXNibBridge 参考 [参考资料] (http://www.jianshu.com/p/b7c4a787a597?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=qq) 参考资料]]></content>
      <categories>
        <category>00-技术-iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Hexo 搭建个人博客]]></title>
    <url>%2F2016%2F04%2F08%2F04-%E6%8A%80%E6%9C%AF-Hexo%2F%E4%BD%BF%E7%94%A8-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[说在前面 hexo.io 什么是 Hexo ？ Hexo 是一个快速、简洁且高效的博客框架, Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页 来自这里。 Hexo 由一个台湾同胞开发的 Blog 框架 https://github.com/tommy351, 和 Github 或 Coding 配合可以非常简单而免费的搭建一个漂亮的个人 Blog，而且可以自定义域名，下面就简单介绍其使用吧。 购买域名 域名购买可到 阿里云 或者 godaddy 购买即可，大概 60RMB/年，而且可以自定义域名邮箱，看起来高端大气上档次😄。如：ios@liangdahong.com其实没什么 X 用 具体就不介绍了。 环境 Hexo 支持 Windows 和 masOS，需安装好 Node.js Git 具体的安装可自行 Google 安装 Hexo 在安装好环境后，使用如下的命令安装 Hexo 1npm install -g hexo-cli 在安装好 Hexo 后，我们初始化自己的 Blog ，首先创建 Blog 需要保存的文件夹，在进入文件夹下。 12cd blog/ 初始化 Blog 12hexo init 初始化完成后我们可以看到有如下的文件夹结构 1234567891011121314_config.ymlnode_modulespackage-lock.jsonpackage.jsonscaffoldssourcethemes _config.yml 文件是 Blog 的一些基本配置, 具体可以参考官网的说明。 预览, 可使用如下命令预览 Blog，然后在浏览器输入 http://localhost:4000 即可看到 Blog 的效果了 1hexo s 创建一篇文章 1hexo new &quot;你的文章名称&quot; 现在我们在本地已经可以看到 Blog 了，那么我们怎么部署到服务器上呢？ 让别人也可以看到我们的 Blog 我们需要去 Github 创建一个项目，命名为：name.github.io 如：iangdahong.github.io 然后去开启 GitHub Pages 然后在刚才我们初始化的 Blog 的 _config.yml 中做具体的修改。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Hexosubtitle:description:keywords:author: John Doelanguage:timezone:# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = &apos;&apos;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &apos;&apos; per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: 如上，现在我们需要把 Blog 部署到 Github 上， 1234// 生成静态 html 文件hexo g// 部署到 githubhexo d 现在你可以使用 xxxxx.github.io 访问你的 Blog 了。 现在我们使用的是 Hexo 提供的默认主题，其实 github 上已经有大量的开源的漂亮的主题如：next 我们使用自定义的主题， 我们把我们知道的主题 clone 到 themes 下， 然后在 _config.yml 中修改主题为你使用的主题， 在使用如上的方法部署到 github 即可使用自定义的主题了。 基本配置 一些简单的配置开源参考 hexo 和 相应的主题做自定义修改 自定义域名 github 支持自定义域名，在刚才我们创建的项目中可以设置自定义的域名，但需要先做好域名解析，具体的操作可以 Google 下 Https 在之前 github 是不支持 https 的，但在不久前已经支持了 https。 其他配置 其他扩展的较多：评价系统，统计系统，分享，打赏等，可以自行探索。下面的 Blog 提供了许多的扩展设置，可以参考下。 https://segmentfault.com/a/1190000009544924 其他 我们可以会思考一个问题 ？现在我们可以写 Blog 了，那么如果我们换电脑了怎么破？其实 我们在使用 hexo g 命令时，是把我们写好的 Markdown 编译 为 html css 文件。在 public 中，我们使用 hexo d 的时候 其实是吧 public 文件的内容全部同步到 github 上去了，你可以去验证下，所以如果你自己写的 html 可以直接放到 public 中 然后部署上去也一样可以使用。 所以我们刚才创建的的项目存储的是生成的 html 文件，那么我们的源文件呢？ 如果换电脑了就没办法获取了，所以我们可以使用 github 在同步我们的源文件，我们在 github 上在创建一个项目来专门存放 我们的 blog 源文件，同时把 public 忽略调，那么我们在换电脑后只需要配置好环境便随时随地可以愉快的写 blog 了。 Blog 加速，国内时访问 Coding, 国外访问 Github ，需把 Blog 同时部署在 2 个平台，同时域名解析为：国外访问 Github，国内访问 Coding 。 以下博客给于了帮助 1、晋先森从购买域名到域名邮箱，搭建博客等 2、Hexo博客优化配置之–为自己博客添加站内搜索 3、Hexo博客优化配置之–为自己博客添加搜索引擎网页收录 4、hexo+github搭建个人博客 5、http://www.voidking.com/tags/hexo/ 6、 https://segmentfault.com/a/1190000009544924/]]></content>
      <categories>
        <category>04-技术-Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
